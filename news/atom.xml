<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://grafast.org/news</id>
    <title>Grafast Blog</title>
    <updated>2023-10-13T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://grafast.org/news"/>
    <subtitle>Grafast Blog</subtitle>
    <icon>https://grafast.org/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[Step Aside Resolvers - Grafast 0.1 Released!]]></title>
        <id>https://grafast.org/news/2023-10-13-grafast-0.1</id>
        <link href="https://grafast.org/news/2023-10-13-grafast-0.1"/>
        <updated>2023-10-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Grafast is finally here - a new holistic execution engine for GraphQL.]]></summary>
        <content type="html"><![CDATA[<p>Gra<em>fast</em> is finally here <!-- -->‚Äî<!-- --> a new holistic execution engine for GraphQL. It enables greater efficiency across the entire backend stack by leveraging the declarative nature of GraphQL to give your business logic a better understanding of everything it needs to do. It<!-- -->‚Äò<!-- -->s backwards compatible, so you can adopt it incrementally within your existing schema and it<!-- -->‚Äò<!-- -->s finally ready to try with <a href="https://www.npmjs.com/package/grafast" target="_blank" rel="noopener noreferrer">the <code>grafast</code> module on npm</a>; or check out <a href="https://github.com/graphile/crystal/tree/main/grafast/grafast" target="_blank" rel="noopener noreferrer">the source code on GitHub</a>!</p><figure><iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/4ao-zjiOGx8?si=R_CtMfyg0Bxx1YUT" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"></iframe><figcaption>I launched Grafast v0.1 at GraphQL Conf, above is the full video of my talk which covers what Grafast is and how it can improve application performance, reduce operational costs, all without being a significant burden on developers.</figcaption></figure><h2 class="anchor anchorWithStickyNavbar_fF9Z" id="grafast-working-group">Gra<em>fast</em> Working Group<a href="#grafast-working-group" class="hash-link" aria-label="Direct link to grafast-working-group" title="Direct link to grafast-working-group">‚Äã</a></h2><p>There<!-- -->‚Äò<!-- -->s still decisions to be made and edges to be smoothed before Gra<em>fast</em> can become a specification that can be implemented in any language. If the potential of this technology is interesting to you, please <a href="https://github.com/grafast/wg" target="_blank" rel="noopener noreferrer">join the Gra<em>fast</em> working group</a> and get involved. We all deserve our future of easy GraphQL execution efficiency!</p><p>If you don<!-- -->‚Äò<!-- -->t have time to watch the video above, here<!-- -->‚Äò<!-- -->s a little about Gra<em>fast</em>:</p><h2 class="anchor anchorWithStickyNavbar_fF9Z" id="graphqls-execution-model-is-wrong-for-most-servers">‚Äú<!-- -->GraphQL<!-- -->‚Äò<!-- -->s execution model is wrong for most servers<!-- -->‚Äù<a href="#graphqls-execution-model-is-wrong-for-most-servers" class="hash-link" aria-label="Direct link to graphqls-execution-model-is-wrong-for-most-servers" title="Direct link to graphqls-execution-model-is-wrong-for-most-servers">‚Äã</a></h2><p>GraphQL is a declarative language; the requests specify everything that the client is asking for up<!-- -->‚Äì<!-- -->front.</p><p>But the resolver<!-- -->‚Äì<!-- -->based execution model <strong><em>obfuscates</em></strong> this knowledge <!-- -->‚Äî<!-- --> when implemented naively, resolvers can very quickly result in serious performance issues; and even when implemented well they leave a lot to be desired.</p><p>DataLoader is one of the suggested approaches to solve the <!-- -->‚Äú<!-- -->N+1 Problem<!-- -->‚Äù<!-- --> but this is only the most egregious performance issue a GraphQL schema may face <!-- -->‚Äî<!-- --> there are plenty of related issues that can build up as your schemas and operations get more complex.</p><p>I set out not only to solve the well<!-- -->‚Äì<!-- -->known N+1 problem and the more subtle under<!-- -->‚Äì<!-- --> and over<!-- -->‚Äì<!-- -->fetching problems, but to help you achieve the most efficient execution for your GraphQL schema no matter what data sources you<!-- -->‚Äò<!-- -->re working with! The solution? Leverage the declarative nature of GraphQL via a new general purpose query planner.</p><h2 class="anchor anchorWithStickyNavbar_fF9Z" id="step-aside-resolvers-theres-a-new-way-to-execute-graphql">‚Äú<!-- -->Step aside resolvers! There<!-- -->‚Äò<!-- -->s a new way to execute GraphQL<!-- -->‚Äù<a href="#step-aside-resolvers-theres-a-new-way-to-execute-graphql" class="hash-link" aria-label="Direct link to step-aside-resolvers-theres-a-new-way-to-execute-graphql" title="Direct link to step-aside-resolvers-theres-a-new-way-to-execute-graphql">‚Äã</a></h2><figure><p><a target="_blank" href="/assets/files/2023-10-13-introducing-grafast-6e8c193f44b2a72cb8f651fb5169f4bd.png"><img loading="lazy" alt="A flow diagram showing the stages of Grafast: Plan resolvers and the incoming GraphQL request are used to draft a plan, which is then optimized, finalized and executed, then the results are sent." src="/assets/images/2023-10-13-introducing-grafast-6e8c193f44b2a72cb8f651fb5169f4bd.png" width="960" height="540" class="img__Ss2"></a></p><figcaption><p>Grafast calls <!-- -->‚Äú<!-- -->plan resolvers<!-- -->‚Äù<!-- --> to determine the requirements for each field in the GraphQL request, ultimately forming a draft <!-- -->‚Äú<!-- -->operation plan<!-- -->‚Äù<!-- -->. Once drafted, the plan is optimized and executed.</p></figcaption></figure><p>Gra<em>fast</em> has been designed from the ground up to give schema designers the tools they need to ensure their schemas are executing as efficiently as possible, whilst ensuring that writing their logic is still a pleasant experience. To achieve this, Gra<em>fast</em> favours a planning strategy which takes a holistic approach to understanding the incoming operation and unlocks the potential for significant optimizations: optimizations that are not achievable with a resolver<!-- -->‚Äì<!-- -->based execution model unless one puts in herculean effort (and a little sorcery üòâ).</p><p>Gra<em>fast</em>, like GraphQL, is not specific to any particular technology stack, business logic shape or data storage layer. It doesn<!-- -->‚Äò<!-- -->t care if you<!-- -->‚Äò<!-- -->re using relational databases, document stores, ORMs, HTTP APIs, file systems or <em><a href="https://datatracker.ietf.org/doc/html/rfc1149" target="_blank" rel="noopener noreferrer">carrier pigeons</a></em>. Any valid GraphQL schema can be implemented with Gra<em>fast</em>, and a Gra<em>fast</em> schema can query any data source, business logic or service.</p><p>Though it supports traditional resolvers, Gra<em>fast</em> encourages developers to use <!-- -->‚Äú<!-- -->plan resolvers<!-- -->‚Äù<!-- -->: small functions similar to resolvers but which describe the required data, rather than actually fetching it.</p><figure><p><a target="_blank" href="/assets/files/2023-10-13-plan-resolvers-f89c4dbb1e0128a6edc4d22461942cd2.png"><img loading="lazy" alt="A comparison between a traditional resolver and a plan resolver. The plan resolver is about the same length and mirrors the shape of the traditional resolver, but the key difference is it describes how to get the data rather than actually fetching it." src="/assets/images/2023-10-13-plan-resolvers-f89c4dbb1e0128a6edc4d22461942cd2.png" width="960" height="540" class="img__Ss2"></a></p><figcaption><p>Plan resolvers are similar to traditional resolvers, they even follow the same shape, but the key difference is they describe HOW to get the data rather than actually fetch it themselves.</p></figcaption></figure><p>Gra<em>fast</em> takes the GraphQL request and, using the plan resolvers, drafts an execution plan which can be optimized and streamlined. The optimization may involve changing the shape of execution significantly from the shape the GraphQL request would imply, enabling the system to satisfy the requirements of the request in the most efficient manner.</p><p>When the planning phase is complete, Gra<em>fast</em> will execute this highly optimized execution plan, and feed the result into the output plan, which efficiently prepares the result to send to the GraphQL client.</p><p>If another request comes in using the same GraphQL document but different variables, Gra<em>fast</em> can reuse the plan and jump straight to the highly optimized execution phase.</p><p>This greater understanding of the needs of the GraphQL requests unlocks entire new avenues for optimization, without sacrificing tried<!-- -->‚Äì<!-- -->and<!-- -->‚Äì<!-- -->trusted approaches such as caching. The result is greater efficiency <!-- -->‚Äî<!-- --> not just in your GraphQL server, but also in the backend services that it relies on <!-- -->‚Äî<!-- --> letting your team operate with a simpler architecture for much longer, allowing your engineers to focus on shipping better experiences for your customers rather than on the complexities of keeping a complicated architecture running smoothly.</p><blockquote class="twitter-tweet" data-conversation="none" data-theme="light"><p lang="en" dir="ltr"><strong>Probably worth looking into the work<!-- --> <a href="https://twitter.com/Benjie?ref_src=twsrc%5Etfw" target="_blank" rel="noopener noreferrer">@Benjie</a> is doing with Grafast as well. Feels like the missing substrate in the GraphQL world.</strong></p>‚Äî Sean Grove (@sgrove)<!-- --> <a href="https://twitter.com/sgrove/status/1696572548803162477?ref_src=twsrc%5Etfw" target="_blank" rel="noopener noreferrer">August 29, 2023</a></blockquote> <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><p>Gra<em>fast</em> already works and some of my <a href="https://graphile.org/sponsors" target="_blank" rel="noopener noreferrer">sponsors</a> are already running it in production. You can try it out today by following the guide at <a href="https://grafast.org" target="_blank" rel="noopener noreferrer">grafast.org</a>. All that<!-- -->‚Äò<!-- -->s left for me to say now is, if the potential of this new technology is interesting, then please:</p><h2 class="anchor anchorWithStickyNavbar_fF9Z" id="help-shape-the-future-on-24th-october-and-join-the-grafast-working-group">Help shape the future on 24th October and join the <a href="https://github.com/grafast/wg" target="_blank" rel="noopener noreferrer">Gra<em>fast</em> working group</a>!<a href="#help-shape-the-future-on-24th-october-and-join-the-grafast-working-group" class="hash-link" aria-label="Direct link to help-shape-the-future-on-24th-october-and-join-the-grafast-working-group" title="Direct link to help-shape-the-future-on-24th-october-and-join-the-grafast-working-group">‚Äã</a></h2><figure><p><a href="https://github.com/grafast/wg" target="_blank" rel="noopener noreferrer"><img loading="lazy" alt="A cartoon graphic of superheroes looking over their city at sunset. The text reads &amp;quot;Get involved&amp;quot; and there is a link to the Grafast working group hosted on GitHub" src="/assets/images/2023-10-13-get-involved-1da3cb16f8a09642543499d27b4fd702.png" width="960" height="540" class="img__Ss2"></a></p></figure>]]></content>
        <author>
            <name>Benjie</name>
            <uri>https://github.com/Benjie</uri>
        </author>
        <category label="0.1" term="0.1"/>
    </entry>
</feed>