"use strict";(self.webpackChunk_localrepo_postgraphile_website=self.webpackChunk_localrepo_postgraphile_website||[]).push([[6775],{30876:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>d});var a=n(2784);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},h=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),u=p(n),m=i,d=u["".concat(s,".").concat(m)]||u[m]||c[m]||o;return n?a.createElement(d,r(r({ref:t},h),{},{components:n})):a.createElement(d,r({ref:t},h))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},16518:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7896),i=(n(2784),n(30876));const o={layout:"page",path:"/postgraphile/usage-schema/",title:"Usage - Schema Only"},r=void 0,l={unversionedId:"usage-schema",id:"version-4.x/usage-schema",title:"Usage - Schema Only",description:"The PostGraphile middleware gives you a lot of excellent features for running",source:"@site/versioned_docs/version-4.x/usage-schema.md",sourceDirName:".",slug:"/usage-schema",permalink:"/postgraphile/current/usage-schema",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/postgraphile/website/versioned_docs/version-4.x/usage-schema.md",tags:[],version:"4.x",frontMatter:{layout:"page",path:"/postgraphile/usage-schema/",title:"Usage - Schema Only"},sidebar:"docs",previous:{title:"PostGraphile as a Library",permalink:"/postgraphile/current/usage-library"},next:{title:"Performance",permalink:"/postgraphile/current/performance"}},s={},p=[{value:"API: <code>createPostGraphileSchema(pgConfig, schemaName, options)</code>",id:"api-createpostgraphileschemapgconfig-schemaname-options",level:3},{value:"API: <code>watchPostGraphileSchema(pgConfig, schemaName, options, onNewSchema)</code>",id:"api-watchpostgraphileschemapgconfig-schemaname-options-onnewschema",level:3},{value:"API: <code>withPostGraphileContext(options, callback)</code>",id:"api-withpostgraphilecontextoptions-callback",level:3},{value:"Even lower level access",id:"even-lower-level-access",level:3},{value:"Calling a resolver from a resolver",id:"calling-a-resolver-from-a-resolver",level:3},{value:"TypeScript code generation",id:"typescript-code-generation",level:2},{value:"Example",id:"example",level:3},{value:"GraphQL IntelliSense",id:"graphql-intellisense",level:2}],h={toc:p},u="wrapper";function c(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The PostGraphile middleware gives you a lot of excellent features for running\nyour own GraphQL server. However, if you want to execute a PostGraphile query in\nNode.js without having to go through HTTP you can use some other exported\nfunctions that PostGraphile provides."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"To see an example, check out the\n",(0,i.kt)("a",{parentName:"strong",href:"https://github.com/graphile/cookbook/tree/master/examples/schema_only"},"Graphile Cookbook Schema Only Example"),".")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"If you're looking for Apollo Client SSR support for PostGraphile without a\nnetwork roundtrip, check out\n",(0,i.kt)("a",{parentName:"strong",href:"https://github.com/graphile/starter/blob/93a887cc87ea8b19eb048b72e9fb3308bc1d5a82/%40app/lib/src/GraphileApolloLink.ts"},"GraphileApolloLink in Graphile Starter"),".")),(0,i.kt)("p",null,"The first function you will need is ",(0,i.kt)("inlineCode",{parentName:"p"},"createPostGraphileSchema")," (or\n",(0,i.kt)("inlineCode",{parentName:"p"},"watchPostGraphileSchema")," if you want to get a new schema each time the database\nis updated) which creates your PostGraphile GraphQL schema by introspecting your\ndatabase."),(0,i.kt)("p",null,"The function takes very similar arguments to\n",(0,i.kt)("a",{parentName:"p",href:"./usage-library/"},"the ",(0,i.kt)("inlineCode",{parentName:"a"},"postgraphile")," middleware"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"createPostGraphileSchema(\n  process.env.DATABASE_URL || 'postgres:///'\n)\n  .then(schema => { ... })\n  .catch(error => { ... })\n")),(0,i.kt)("p",null,"Now that you have your schema, in order to execute a GraphQL query you must\nsupply an (authenticated) ",(0,i.kt)("inlineCode",{parentName:"p"},"pgClient")," on the context object. The preferred way to\ndo this is via the asynchronous ",(0,i.kt)("inlineCode",{parentName:"p"},"withPostGraphileContext")," function. The context\nobject will contain a PostgreSQL client which has its own transaction with the\ncorrect permission levels for the associated user."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { Pool } = require('pg');\nconst { graphql } = require('graphql');\nconst { withPostGraphileContext } = require('postgraphile');\n\nconst myPgPool = new Pool({ ... });\n\nexport async function performQuery(\n  schema,\n  query,\n  variables,\n  jwtToken,\n  operationName\n) {\n  return await withPostGraphileContext(\n    {\n      pgPool: myPgPool,\n      jwtToken: jwtToken,\n      jwtSecret: \"...\",\n      pgDefaultRole: \"...\"\n    },\n    async context => {\n      // Execute your GraphQL query in this function with the provided\n      // `context` object, which should NOT be used outside of this\n      // function.\n      return await graphql(\n        schema, // The schema from `createPostGraphileSchema`\n        query,\n        null,\n        { ...context }, // You can add more to context if you like\n        variables,\n        operationName\n      );\n    }\n  );\n}\n")),(0,i.kt)("p",null,"(The ",(0,i.kt)("inlineCode",{parentName:"p"},"await")," keywords after the ",(0,i.kt)("inlineCode",{parentName:"p"},"return")," statements aren't required, they're\njust there to clarify the results are promises.)"),(0,i.kt)("h3",{id:"api-createpostgraphileschemapgconfig-schemaname-options"},"API: ",(0,i.kt)("inlineCode",{parentName:"h3"},"createPostGraphileSchema(pgConfig, schemaName, options)")),(0,i.kt)("p",null,"This function takes three arguments (all are optional) and returns a promise to\na GraphQLSchema object."),(0,i.kt)("p",null,"The returned GraphQLSchema will ",(0,i.kt)("strong",{parentName:"p"},"not"),' be updated when your database changes -\nif you require "watch" functionality, please use ',(0,i.kt)("inlineCode",{parentName:"p"},"watchPostGraphileSchema"),"\ninstead (see below). The below options are valid\nfor ",(0,i.kt)("tt",null,(0,i.kt)("a",{parentName:"p",href:"mailto:postgraphile@4.12.3"},"postgraphile@4.12.3")),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"pgConfig")),": An object or string that will be passed to the ","[",(0,i.kt)("inlineCode",{parentName:"li"},"pg"),"][]","\nlibrary and used to connect to a PostgreSQL backend. If you already have a\npool client or a pool instance, when using this function you may pass that\npool client or a ",(0,i.kt)("inlineCode",{parentName:"li"},"pg-pool")," instance directly instead of a config."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"schemaName")),": A string which specifies the PostgreSQL schema that\nPostGraphile will use to create a GraphQL schema. The default schema is the\n",(0,i.kt)("inlineCode",{parentName:"li"},"public")," schema. May be an array for multiple schemas."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"options")),": An object containing other miscellaneous options. Most options\nare shared with the ",(0,i.kt)("inlineCode",{parentName:"li"},"postgraphile")," middleware function. Options could be:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ownerConnectionString"),": Connection string to use to connect to the database\nas a privileged user (e.g. for setting up watch fixtures, logical decoding,\netc)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"subscriptions"),": Enable GraphQL websocket transport support for\nsubscriptions (you still need a subscriptions plugin currently)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"live"),": ","[EXPERIMENTAL]"," Enables live-query support via GraphQL subscriptions\n(sends updated payload any time nested collections/records change)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"websockets"),": Choose which websocket transport libraries to use. Use commas\nto define multiple. Defaults to ",(0,i.kt)("inlineCode",{parentName:"li"},"['v0', 'v1']")," if ",(0,i.kt)("inlineCode",{parentName:"li"},"subscriptions")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"live"),"\nare true, ",(0,i.kt)("inlineCode",{parentName:"li"},"[]")," otherwise"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"websocketOperations"),": Toggle which GraphQL websocket transport operations\nare supported: 'subscriptions' or 'all'. Defaults to ",(0,i.kt)("inlineCode",{parentName:"li"},"subscriptions")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"pgDefaultRole"),": The default Postgres role to use. If no role was provided\nin a provided JWT token, this role will be used."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"dynamicJson"),": By default, JSON and JSONB fields are presented as strings\n(JSON encoded) from the GraphQL schema. Setting this to ",(0,i.kt)("inlineCode",{parentName:"li"},"true")," (recommended)\nenables raw JSON input and output, saving the need to parse / stringify JSON\nmanually."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"setofFunctionsContainNulls"),": If none of your ",(0,i.kt)("inlineCode",{parentName:"li"},"RETURNS SETOF compound_type"),"\nfunctions mix NULLs with the results then you may set this false to reduce\nthe nullables in the GraphQL schema."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"classicIds"),": Enables classic ids for Relay support. Instead of using the\nfield name ",(0,i.kt)("inlineCode",{parentName:"li"},"nodeId")," for globally unique ids, PostGraphile will instead use\nthe field name ",(0,i.kt)("inlineCode",{parentName:"li"},"id")," for its globally unique ids. This means that table ",(0,i.kt)("inlineCode",{parentName:"li"},"id"),"\ncolumns will also get renamed to ",(0,i.kt)("inlineCode",{parentName:"li"},"rowId"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"disableDefaultMutations"),": Setting this to ",(0,i.kt)("inlineCode",{parentName:"li"},"true")," will prevent the creation\nof the default mutation types & fields. Database mutation will only be\npossible through Postgres functions."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ignoreRBAC"),": Set false (recommended) to exclude fields, queries and\nmutations that are not available to any possible user (determined from the\nuser in connection string and any role they can become); set this option\ntrue to skip these checks and create GraphQL fields and types for\neverything. The default is ",(0,i.kt)("inlineCode",{parentName:"li"},"true"),", in v5 the default will change to ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ignoreIndexes"),": Set false (recommended) to exclude filters, orderBy, and\nrelations that would be expensive to access due to missing indexes. Changing\nthis from true to false is a breaking change, but false to true is not, so\nwe recommend you start with it set to ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),". The default is ",(0,i.kt)("inlineCode",{parentName:"li"},"true"),", in v5\nthe default may change to ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"includeExtensionResources"),": By default, tables and functions that come from\nextensions are excluded from the generated GraphQL schema as general\napplications don't need them to be exposed to the end user. You can use this\nflag to include them in the generated schema (not recommended)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"appendPlugins"),": An array of\n",(0,i.kt)("a",{parentName:"li",href:"https://graphile.org/graphile-build/plugins/"},"Graphile Engine")," schema\nplugins to load after the default plugins."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"prependPlugins"),": An array of\n",(0,i.kt)("a",{parentName:"li",href:"https://graphile.org/graphile-build/plugins/"},"Graphile Engine")," schema\nplugins to load before the default plugins (you probably don't want this)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"replaceAllPlugins"),": The full array of\n",(0,i.kt)("a",{parentName:"li",href:"https://graphile.org/graphile-build/plugins/"},"Graphile Engine")," schema\nplugins to use for schema generation (you almost definitely don't want\nthis!)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"skipPlugins"),": An array of\n",(0,i.kt)("a",{parentName:"li",href:"https://graphile.org/graphile-build/plugins/"},"Graphile Engine")," schema\nplugins to skip."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"readCache"),": A file path string or an object. Reads cached values to improve\nstartup time (you may want to do this in production)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"writeCache"),": A file path string. Writes computed values to local cache file\nso startup can be faster (do this during the build phase)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"jwtSecret"),": The secret for your JSON web tokens. This will be used to\nverify tokens in the ",(0,i.kt)("inlineCode",{parentName:"li"},"Authorization")," header, and signing JWT tokens you\nreturn in procedures."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"jwtPublicKey"),": The public key to verify the JWT when signed with RS265 or\nES256 algorithms."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"jwtSignOptions"),": Options with which to perform JWT signing - see\n",(0,i.kt)("a",{parentName:"li",href:"https://github.com/auth0/node-jsonwebtoken#jwtsignpayload-secretorprivatekey-options-callback"},"https://github.com/auth0/node-jsonwebtoken#jwtsignpayload-secretorprivatekey-options-callback")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"jwtPgTypeIdentifier"),": The Postgres type identifier for the compound type\nwhich will be signed as a JWT token if ever found as the return type of a\nprocedure. Can be of the form: ",(0,i.kt)("inlineCode",{parentName:"li"},"my_schema.my_type"),". You may use quotes as\nneeded: ",(0,i.kt)("inlineCode",{parentName:"li"},'"my-special-schema".my_type'),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"legacyRelations"),": Some one-to-one relations were previously detected as\none-to-many - should we export 'only' the old relation shapes, both new and\nold but mark the old ones as 'deprecated' (default), or 'omit' (recommended)\nthe old relation shapes entirely."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"legacyJsonUuid"),": ONLY use this option if you require the v3 typenames\n'Json' and 'Uuid' over 'JSON' and 'UUID'."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"simpleCollections"),': Should we use relay pagination, or simple collections?\n"omit" (default) - relay connections only, "only" (not recommended) - simple\ncollections only (no Relay connections), "both" - both.')))),(0,i.kt)("h3",{id:"api-watchpostgraphileschemapgconfig-schemaname-options-onnewschema"},"API: ",(0,i.kt)("inlineCode",{parentName:"h3"},"watchPostGraphileSchema(pgConfig, schemaName, options, onNewSchema)")),(0,i.kt)("p",null,"This function takes the same options as ",(0,i.kt)("inlineCode",{parentName:"p"},"createPostGraphileSchema"),"; but with one\naddition: a function ",(0,i.kt)("inlineCode",{parentName:"p"},"onNewSchema")," that is called every time a new schema is\ngenerated, passing the new schema as the first argument. ",(0,i.kt)("inlineCode",{parentName:"p"},"onNewSchema")," is\nguaranteed to be called before the ",(0,i.kt)("inlineCode",{parentName:"p"},"watchPostGraphileSchema")," promise resolves.\nIt resolves to an asynchronus function that can be called to stop listening for\nschema changes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'async function main() {\n  let graphqlSchema;\n  const releaseWatcher = await watchPostGraphileSchema(\n    pgPool,\n    pgSchemas,\n    options,\n    (newSchema) => {\n      console.log("Generated new GraphQL schema");\n      graphqlSchema = newSchema;\n    },\n  );\n  // graphqlSchema is **guaranteed** to be set here.\n\n  // ... do stuff with graphqlSchema\n\n  await releaseWatcher();\n}\n')),(0,i.kt)("h3",{id:"api-withpostgraphilecontextoptions-callback"},"API: ",(0,i.kt)("inlineCode",{parentName:"h3"},"withPostGraphileContext(options, callback)")),(0,i.kt)("p",null,"This function sets up a PostGraphile context, calls (and resolves) the callback\nfunction within this context, and then tears the context back down again finally\nresolving to the result of your function (which should be a\nGraphQLExecutionResult from executing a ",(0,i.kt)("inlineCode",{parentName:"p"},"graphql()")," query)."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"options")),": An object of options that are used to create the context object\nthat gets passed into ",(0,i.kt)("inlineCode",{parentName:"li"},"callback"),".",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"pgPool"),": A required instance of a Postgres pool from ",(0,i.kt)("a",{parentName:"li",href:"https://www.npmjs.com/package/pg-pool"},(0,i.kt)("inlineCode",{parentName:"a"},"pg-pool")),". A\nPostgres client will be connected from this pool."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"jwtToken"),": An optional JWT token string. This JWT token represents the\nviewer of your PostGraphile schema. You might get this from the\nAuthorization header."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"jwtSecret"),": see 'jwtSecret' above"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"jwtAudiences"),": see 'jwtAudiences' above"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"jwtRole"),": see 'jwtRole' in the library documentation"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"jwtVerifyOptions"),": see 'jwtVerifyOptions' in the library documentation"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"pgDefaultRole"),": see 'pgDefaultRole' in the library documentation"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"pgSettings"),": A plain object specifying custom config values to set in the\nPostgreSQL transaction (accessed via\n",(0,i.kt)("inlineCode",{parentName:"li"},"current_setting('my.custom.setting')"),") - do ",(0,i.kt)("em",{parentName:"li"},"NOT")," provide a function unlike\nwith the library options"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"strong"},"callback")),": The function which is called with the ",(0,i.kt)("inlineCode",{parentName:"li"},"context")," object which\nwas created. Whatever the return value of this function is will be the return\nvalue of ",(0,i.kt)("inlineCode",{parentName:"li"},"withPostGraphileContext"),".")),(0,i.kt)("h3",{id:"even-lower-level-access"},"Even lower level access"),(0,i.kt)("p",null,"If you really want to get into the nitty-gritty of what's going on, then take a\nlook at the ",(0,i.kt)("inlineCode",{parentName:"p"},"postgraphile-core")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"graphile-build-pg")," modules."),(0,i.kt)("h3",{id:"calling-a-resolver-from-a-resolver"},"Calling a resolver from a resolver"),(0,i.kt)("p",null,"You can issue GraphQL requests from various contexts, including within a\nresolver. To do so you need the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Access to the ",(0,i.kt)("inlineCode",{parentName:"li"},"graphql")," function from the ",(0,i.kt)("inlineCode",{parentName:"li"},"graphql")," module",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"In a PostGraphile plugin, if you have access to the build object (which you\nusually will), you should get this from ",(0,i.kt)("inlineCode",{parentName:"li"},"build.graphql.graphql")),(0,i.kt)("li",{parentName:"ul"},"Failing that, you can ",(0,i.kt)("inlineCode",{parentName:"li"},"import { graphql } from 'graphql'")," or\n",(0,i.kt)("inlineCode",{parentName:"li"},"const { graphql } = require('graphql')"),", but this has caveats."))),(0,i.kt)("li",{parentName:"ul"},"A reference to the GraphQL schema object. You can get this from many sources:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"in a resolver, you should extract it from ",(0,i.kt)("inlineCode",{parentName:"li"},"info.schema")),(0,i.kt)("li",{parentName:"ul"},"if you have access to the PostGraphile middleware, you can issue\n",(0,i.kt)("inlineCode",{parentName:"li"},"await postgraphileMiddleware.getGqlSchema()")),(0,i.kt)("li",{parentName:"ul"},"if you don't need the PostGraphile middleware, you can use\n",(0,i.kt)("inlineCode",{parentName:"li"},"await createPostGraphileSchema(...)")," - see\n",(0,i.kt)("a",{parentName:"li",href:"./usage-schema/"},"schema only usage")," - do this once and cache it because\nit's expensive to compute"))),(0,i.kt)("li",{parentName:"ul"},"A GraphQL operation (aka query, but includes mutations, subscriptions) to\nexecute; this can be a string or an AST"),(0,i.kt)("li",{parentName:"ul"},"The variables to feed to the operation (if necessary)"),(0,i.kt)("li",{parentName:"ul"},"A valid GraphQL context for PostGraphile",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"inside a resolver, you can just pass the resolver's context straight through"),(0,i.kt)("li",{parentName:"ul"},"in other situations, have a look at ",(0,i.kt)("inlineCode",{parentName:"li"},"withPostGraphileContext")," in the\n",(0,i.kt)("a",{parentName:"li",href:"./usage-schema/"},"schema only usage"))))),(0,i.kt)("p",null,"Issuing a GraphQL operation from inside a resolver example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"/*\n * Assuming you have access to a `build` object, e.g. inside a\n * `makeExtendSchemaPlugin`, you can extract the `graphql` function\n * from the `graphql` library here like so:\n */\nconst {\n  graphql: { graphql },\n} = build;\n/*\n * Failing the above: `import { graphql } from 'graphql';` but beware of\n * duplicate `graphql` modules in your `node_modules` causing issues.\n */\n\nasync function myResolver(parent, args, context, info) {\n  // Whatever GraphQL query you wish to issue:\n  const document = /* GraphQL */ `\n    query MyQuery($userId: Int!) {\n      userById(id: $userId) {\n        username\n      }\n    }\n  `;\n  // The name of the operation in your query document (optional)\n  const operationName = \"MyQuery\";\n  // The variables for the query\n  const variables = { userId: args.userId };\n\n  const { data, errors } = await graphql(\n    info.schema,\n    document,\n    null,\n    context,\n    variables,\n    operationName,\n  );\n\n  // TODO: error handling\n\n  return data.userById.username;\n}\n")),(0,i.kt)("h1",{id:"server-side-typescript-support"},"Server-side TypeScript support"),(0,i.kt)("p",null,"PostGraphile takes care of building and serving a GraphQL API for various\nclients to use. But it is not only possible to use the API from external\nclients, it is also possible to use the GraphQL API from within its own backend."),(0,i.kt)("p",null,"High-level overview:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"use graphql-code-generator to create TypeScript types for our GraphQL schema"),(0,i.kt)("li",{parentName:"ul"},"use the generated types to query/mutate your data"),(0,i.kt)("li",{parentName:"ul"},"optional: use a Visual Studio Code extension to get IntelliSense")),(0,i.kt)("h2",{id:"typescript-code-generation"},"TypeScript code generation"),(0,i.kt)("p",null,"We use the ",(0,i.kt)("a",{parentName:"p",href:"https://graphql-code-generator.com/"},"GraphQL code generator")," tools\nto create the TypeScript types in our backend code."),(0,i.kt)("p",null,"The following ",(0,i.kt)("inlineCode",{parentName:"p"},"npm")," packages will create TypeScript types:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@graphql-codegen/cli")," - the CLI tool to create the types"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@graphql-codegen/typescript")," - create the TypeScript types. This is the main\npackage that we need"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@graphql-codegen/typescript-operations")," - generates types for\nqueries/mutations/fragments"),(0,i.kt)("li",{parentName:"ul"},"optionally add a client specific generator: e.g.\n",(0,i.kt)("inlineCode",{parentName:"li"},"@graphql-codegen/typescript-urql"))),(0,i.kt)("p",null,"Steps to get the backend typing support:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Start the development like described in the above section. Follow all the\nsteps to create your GraphQL API with all needed schemas, tables, roles, etc."),(0,i.kt)("li",{parentName:"ol"},"Configure PostGraphile to export the GraphQL schema:",(0,i.kt)("br",{parentName:"li"}),(0,i.kt)("inlineCode",{parentName:"li"},"exportGqlSchemaPath: './src/generated/schema.graphql'")),(0,i.kt)("li",{parentName:"ol"},"Start the project to let PostGraphile create the initial ",(0,i.kt)("inlineCode",{parentName:"li"},"schema.graphql"),"\nfile. Since it's generated you can exclude this file from source control if\nyou want to, but it is handy to see differences in the schema during\ncheck-ins and is useful for other tooling such as ",(0,i.kt)("inlineCode",{parentName:"li"},"eslint-plugin-graphql"),"."),(0,i.kt)("li",{parentName:"ol"},"Import the mentioned ",(0,i.kt)("inlineCode",{parentName:"li"},"npm")," packages. You can find more plugins on their\nwebsite in the\n",(0,i.kt)("a",{parentName:"li",href:"https://graphql-code-generator.com/docs/plugins/index/"},"Plugins")," section."),(0,i.kt)("li",{parentName:"ol"},"Create a file ",(0,i.kt)("inlineCode",{parentName:"li"},"codegen.yml")," in the root of your workspace.",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'overwrite: true\nschema: "./src/generated/schema.graphql"\ngenerates:\n  # Creates the TypeScript types from the schema and any .graphql file\n  src/generated/types.ts:\n    documents: "src/**/*.graphql"\n    plugins:\n      - typescript\n      - typescript-operations\n      - typescript-urql\n    config:\n      withHOC: false\n      withComponent: false\n      withMutationFn: false\nconfig:\n  scalars:\n    DateTime: "string"\n    JSON: "{ [key: string]: any }"\n'))),(0,i.kt)("li",{parentName:"ol"},"Run ",(0,i.kt)("inlineCode",{parentName:"li"},"graphql-codegen --config codegen.yml")," to generate the types."),(0,i.kt)("li",{parentName:"ol"},"The generated types can now be used in your custom business logic code.")),(0,i.kt)("h3",{id:"example"},"Example"),(0,i.kt)("p",null,"We have a movie table that we want to query from our backend system."),(0,i.kt)("p",null,"We can write a small GraphQL query file similar to this. It could be stored in\n",(0,i.kt)("inlineCode",{parentName:"p"},"./src/graphql/getMovies.graphql"),". (NOTE: this example uses the\n",(0,i.kt)("inlineCode",{parentName:"p"},"@graphile-contrib/pg-simplify-inflector")," plugin, your query might need to\ndiffer.)"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-graphql"},"query GetMovies($top: Int!) {\n  movies(first: $top) {\n    nodes {\n      id\n      title\n    }\n  }\n}\n")),(0,i.kt)("p",null,"Save the file and run the code generation task."),(0,i.kt)("p",null,"Alternatively we can create some inline query directly in code like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'import { makeExtendSchemaPlugin, gql } from "graphile-utils";\n\n// inside some function:\n\nconst GetMoviesDocument = gql`\n  query Query {\n    __typename\n    movies(first: 3) {\n      nodes {\n        id\n        title\n      }\n    }\n  }\n`;\n')),(0,i.kt)("p",null,"The query can then be used in your code via the generated types or inline.\nPlease see further down on why there is a need for ",(0,i.kt)("inlineCode",{parentName:"p"},"gql as gqlExtend"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { makeExtendSchemaPlugin, gql, gql as gqlExtend } from 'graphile-utils';\nimport { Build } from 'postgraphile';\nimport {\n  GetMoviesQuery,\n  GetMoviesDocument,\n  GetMoviesQueryVariables,\n} from '../../generated/types';\n\n// doc: https://www.graphile.org/postgraphile/make-extend-schema-plugin/\nexport const BusinessLogicPlugin = makeExtendSchemaPlugin((build: Build) => {\n  const { graphql } = build;\n  return {\n    typeDefs: gqlExtend`\n      extend type Query {\n        topMovieTitles: [String!]\n      }\n    `,\n    resolvers: {\n      Query: {\n        topMovieTitles: async (query, args, context, resolveInfo) => {\n          // Alternatively defined the query inline with intellisense support:\n          const inlineGetMoviesDocument = gql`\n            query Query {\n              __typename\n              movies(first: 3) {\n                nodes {\n                  id\n                  title\n                }\n              }\n            }\n          `;\n          const variables: GetMoviesQueryVariables = {\n            top: 3,\n          };\n\n          // execute the query\n          const queryResult = await graphql.execute<GetMoviesQuery>(\n            resolveInfo.schema,\n            GetMoviesDocument, // or: inlineGetMoviesDocument,\n            undefined,\n            context,\n            variables,\n          );\n\n          if (queryResult.errors) {\n            // do something in error case\n            throw queryResult.errors[0];\n          } else {\n            // the result can then be used to get the returned data\n            const allTitles = queryResult.data?.movies?.nodes.map(\n              movie => movie?.title,\n            );\n\n            return allTitles;\n          }\n        },\n      },\n    },\n  };\n});\n")),(0,i.kt)("h2",{id:"graphql-intellisense"},"GraphQL IntelliSense"),(0,i.kt)("p",null,"The above mentioned steps provide strong typing support. If you are developing\nyour code with VisualStudio Code you can get IntelliSense support both in\n.graphql files and in inline defined gql","`"," template strings."),(0,i.kt)("p",null,"There are multiple extensions in the VSCode marketplace but this guide is\nwritten for the Apollo GraphQL extension."),(0,i.kt)("p",null,"Install the extension and if needed reload VSCode."),(0,i.kt)("p",null,'Add a file "apollo.config.js" into the root of your workspace with the following\ncontent:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'module.exports = {\n  client: {\n    excludes: [\n      "**/node_modules",\n      "**/__tests__",\n      "**/generated/**/*.{ts,tsx,js,jsx,graphql,gql}",\n    ],\n    includes: ["src/**/*.{ts,tsx,js,jsx,graphql,gql}"],\n    service: {\n      name: "client",\n      localSchemaFile: "./src/generated/schema.graphql",\n    },\n  },\n};\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"localSchemaFile"),": this must point to the schema created by PostGraphile"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"excludes"),": this must exclude the ",(0,i.kt)("inlineCode",{parentName:"li"},"node_modules")," folder and any tests. It must\nalso exclude the generated ",(0,i.kt)("inlineCode",{parentName:"li"},"schema.graphql")," and any code that was generated\nbased on that schema."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"includes"),": it should include any file for which you want to have\nIntelliSense. That is at least ",(0,i.kt)("inlineCode",{parentName:"li"},".ts")," and ",(0,i.kt)("inlineCode",{parentName:"li"},".graphql")," but potentially more.")),(0,i.kt)("p",null,"This will support syntax highlighting in your files. BUT - we have a problem. If\nwe adjust our schema e.g. via ",(0,i.kt)("inlineCode",{parentName:"p"},"makeExtendSchemaPlugin")," we define some custom\nextension to the automatically generated GraphQL schema. That means that the\nApollo extension will find this extension both in the generated schema.graphql\nfile as well as in the file with your ",(0,i.kt)("inlineCode",{parentName:"p"},"makeExtendSchemaPlugin"),". Then it\ncomplains that this is not unique and will stop working. So we have to find a\nsolution for that."),(0,i.kt)("p",null,'We should exclude our type extensions from IntelliSense. To do this we can\ncreate a custom mapping to have the gql template string available as the normal\n"gql" but also as a second custom variable like "gql as gqlExtend". Then we can\nwrite our GraphQL schema extension by using the "gqlExtend" template string and\nany inline query by using the normal "gql" template string.'),(0,i.kt)("p",null,"An example could look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'// get gql as two different variables\nimport { makeExtendSchemaPlugin, gql, gql as gqlExtend } from "graphile-utils";\nimport { Build } from "postgraphile";\n\nexport const MyPlugin = makeExtendSchemaPlugin((build: Build) => {\n  const { graphql } = build;\n  return {\n    // use the "gqlExtend" template string here to extend your GraphQL API:\n    typeDefs: gqlExtend`\n      extend type Query {\n        myExtension: [String!]\n      }\n    `,\n    resolvers: {\n      Query: {\n        myExtension: async (query, args, context, resolveInfo) => {\n          // use the normal "gql" template string to define your query inline:\n          const inlineDocument = gql`\n            query Query {\n              __typename\n              movies(first: 3) {\n                nodes {\n                  id\n                  title\n                }\n              }\n            }\n          `;\n\n          // continue with your code\n        },\n      },\n    },\n  };\n});\n')),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Tips and tricks:"),(0,i.kt)("br",{parentName:"p"}),"\n",'This VS code extension was not super stable as of the time of writing. It\nwould crash sometimes if it thought to find conflicting definitions. This\nhappens often when committing code and comparing it side by side or when\nhaving a "bad" graphql file/definition.',(0,i.kt)("br",{parentName:"p"}),"\n","If it stops working then reload the VSCode extension host by typing\n",(0,i.kt)("inlineCode",{parentName:"p"},"Developer: Restart Extension Host"),' in the actions "CTRL+SHIFT+P" field.')))}c.isMDXComponent=!0}}]);