"use strict";(self.webpackChunk_localrepo_postgraphile_website=self.webpackChunk_localrepo_postgraphile_website||[]).push([[7258],{30876:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>b});var a=n(2784);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},h=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,o=e.originalType,s=e.parentName,h=i(e,["components","mdxType","originalType","parentName"]),p=u(n),d=l,b=p["".concat(s,".").concat(d)]||p[d]||c[d]||o;return n?a.createElement(b,r(r({ref:t},h),{},{components:n})):a.createElement(b,r({ref:t},h))}));function b(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var o=n.length,r=new Array(o);r[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[p]="string"==typeof e?e:l,r[1]=i;for(var u=2;u<o;u++)r[u]=n[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},43097:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>i,toc:()=>u});var a=n(7896),l=(n(2784),n(30876));const o={layout:"page",path:"/postgraphile/why-nullable/",title:"Why is it nullable?"},r=void 0,i={unversionedId:"why-nullable",id:"why-nullable",title:"Why is it nullable?",description:"It's common for people, particularly those using strongly typed GraphQL",source:"@site/postgraphile/why-nullable.md",sourceDirName:".",slug:"/why-nullable",permalink:"/postgraphile/next/why-nullable",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/postgraphile/website/postgraphile/why-nullable.md",tags:[],version:"current",frontMatter:{layout:"page",path:"/postgraphile/why-nullable/",title:"Why is it nullable?"},sidebar:"docs",previous:{title:"Introspection?",permalink:"/postgraphile/next/introspection"},next:{title:"Versioning Policy",permalink:"/postgraphile/next/versioning-policy"}},s={},u=[{value:"Nulls in GraphQL",id:"nulls-in-graphql",level:3},{value:"Root (Query, Mutation and Subscription) fields",id:"root-query-mutation-and-subscription-fields",level:3},{value:"Relations: RLS visibility",id:"relations-rls-visibility",level:3},{value:"Fields under mutation payloads",id:"fields-under-mutation-payloads",level:3},{value:"What about nullable nodes in table connections?",id:"what-about-nullable-nodes-in-table-connections",level:3},{value:"What about computed fields?",id:"what-about-computed-fields",level:3},{value:"I&#39;ve read the above, but I still want this particular thing to be non-nullable!",id:"ive-read-the-above-but-i-still-want-this-particular-thing-to-be-non-nullable",level:3}],h={toc:u},p="wrapper";function c(e){let{components:t,...n}=e;return(0,l.kt)(p,(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"It's common for people, particularly those using strongly typed GraphQL\nimplementations such as ReasonML or TypeScript, to ask why certain elements in a\nPostGraphile schema are nullable. A lot of thought has gone into which parts\nshould/should not be nullable, but the reasoning behind these decisions is not\nalways obvious to users, so hopefully this article will help to explain."),(0,l.kt)("h3",{id:"nulls-in-graphql"},"Nulls in GraphQL"),(0,l.kt)("p",null,'In GraphQL, nulls cascade up the tree until they find the first "nullable". So\ntake for example this GraphQL Schema:'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-graphql"},"# This is a bad practice GraphQL schema to demonstrate a point.\n\ntype Numbers {\n  one: Int!\n  two: Int!\n  three: Int!\n}\n\ntype Letters {\n  a: String!\n  b: String!\n  c: String!\n}\n\ntype Query {\n  numbers: Numbers!\n  letters: Letters!\n}\n")),(0,l.kt)("p",null,"and this query:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-graphql"},"{\n  numbers {\n    one\n    two\n    three\n  }\n  letters {\n    a\n    b\n    c\n  }\n}\n")),(0,l.kt)("p",null,"If there was an issue causing the resolver for ",(0,l.kt)("inlineCode",{parentName:"p"},"Numbers.three")," to throw an\nerror, then GraphQL would first try and make the field itself null. It can't,\nbecause it's not nullable, so it would then try and make the parent field\n(",(0,l.kt)("inlineCode",{parentName:"p"},"numbers"),") null. But that's marked as non-nullable too, so the only thing left\nto make nullable would be the entire query itself. This means that all the\nletters, despite producing no errors, would also be omitted from the result."),(0,l.kt)("p",null,"One of the key aims of GraphQL is to deal smoothly with temporary errors - i.e.\nwhen an error occurs it aims to not\n",(0,l.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Don%27t_throw_the_baby_out_with_the_bathwater"},'"throw the baby out with the bathwater"'),'.\nThis is one of the reasons (the main reason, really) that GraphQL treats all\nfields as nullable by default ("errors happen") and allows you to mark things as\nnot null, rather than the other way around which is more common in typed\nlanguages. GraphQL wants you to think about where errors may occur and where\nthey should be limited to, preventing them from flowing over into unrelated\nareas.'),(0,l.kt)("h3",{id:"root-query-mutation-and-subscription-fields"},"Root (Query, Mutation and Subscription) fields"),(0,l.kt)("p",null,"If you're following GraphQL best practices, then all of your root level Query,\nMutation and Subscription fields should be nullable unless you're absolutely\ncertain that they cannot throw an error or be null, and further that none of\ntheir children or grandchildren or great-grandchildren can throw an error or\nreturn a null that would cascade and cause the field itself to be null."),(0,l.kt)("p",null,"In PostGraphile, two of our ",(0,l.kt)("inlineCode",{parentName:"p"},"Query")," fields are not nullable because they adhere\nto this check:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"nodeId")," returns a constant value (the string 'query') so it can never error"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"query")," returns the ",(0,l.kt)("inlineCode",{parentName:"li"},"Query")," object again (it's a Relay 1 hack) and so it has\nall the same guarantees as the Query object")),(0,l.kt)("p",null,"Everything else is nullable, because ",(0,l.kt)("strong",{parentName:"p"},"errors happen")," and we don't want them to\ncascade to sibling fields."),(0,l.kt)("p",null,'To make this even clearer: if our mutation fields were "not nullable" and you\nperformed a mutation such as this:'),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-graphql"},'mutation {\n  createSecret(input: {label: "Foo"}) { secret }\n  someOtherMutation(input: {...}) { ... }\n}\n')),(0,l.kt)("p",null,"If mutations were marked non-nullable and yet for some reason\n",(0,l.kt)("inlineCode",{parentName:"p"},"someOtherMutation")," threw an error, then the entire GraphQL response would come\nback null and you wouldn't see the result of the ",(0,l.kt)("inlineCode",{parentName:"p"},"createSecret")," mutation. As per\nthe GraphQL spec: mutations are independent, thus the ",(0,l.kt)("inlineCode",{parentName:"p"},"createSecret")," mutation\nwould not be rolled back and the value would be created but never shown."),(0,l.kt)("h3",{id:"relations-rls-visibility"},"Relations: RLS visibility"),(0,l.kt)("p",null,"PostgreSQL uses foreign keys to assert that relations exist. Take this SQL\nschema:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"create table person (\n  id serial primary key,\n  username citext not null\n);\n\ncreate table post (\n  id serial primary key,\n  author_id int not null references person on delete cascade,\n  body text not null\n);\n")),(0,l.kt)("p",null,"From this we know that given a ",(0,l.kt)("inlineCode",{parentName:"p"},"Post")," record exists, then the associated\n",(0,l.kt)("inlineCode",{parentName:"p"},"Person")," object must also exist - PostgreSQL guarantees this. So why does\nPostGraphile mark the ",(0,l.kt)("inlineCode",{parentName:"p"},"Post.personByAuthorId")," field as nullable? Well, consider\nthis:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"-- Users can only see their own 'Person'\ncreate policy select_self on person for select using (id = current_user_id());\n-- Users can see all Posts\ncreate policy select_all on post for select using (true);\n")),(0,l.kt)("p",null,"Given the above, it's possible for you to be able to see a Post without you\nbeing allowed to see the associated Person. So even though the person definitely\nexists, that doesn't guarantee that you can see them."),(0,l.kt)("h3",{id:"fields-under-mutation-payloads"},"Fields under mutation payloads"),(0,l.kt)("p",null,"For similar reasons to the Relations above, it's possible for you to be able to\ncreate something but then not see the result of that - it really depends how\nyou've defined your security. For example, if you create a truly anonymous\n\"feedback\" item then there's nothing in it to indicate that you're allowed to\nview it."),(0,l.kt)("h3",{id:"what-about-nullable-nodes-in-table-connections"},"What about nullable nodes in table connections?"),(0,l.kt)("p",null,"This one at first seems obviously a mistake - of course if I request a list of\nrows from a table or function I'm not going to get some rows and some nulls -\nthey'll either all fail or all succeed... Surely? Well, it turns out: no -\nfunctions which return connections (that is\n",(0,l.kt)("inlineCode",{parentName:"p"},"CREATE FUNCTION ...(...) RETURNS SETOF table_type AS ..."),") can return nulls as\nwell as table rows. In my opinion, doing so is a bad practice."),(0,l.kt)("p",null,"If you can commit to never returning null rows in your ",(0,l.kt)("inlineCode",{parentName:"p"},"SETOF")," functions, then\nyou can use the ",(0,l.kt)("inlineCode",{parentName:"p"},"preset.schema.pgForbidSetofFunctionsToReturnNull")," setting to change this\nbehaviour. I recommend this flag; but it's disabled by default to maximise\ncompatibility (also going from nullable to non-nullable is fine, but going the\nother way is a breaking change)."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="graphile.config.mjs"',title:'"graphile.config.mjs"'},"export default {\n  // ...\n  schema: {\n    pgForbidSetofFunctionsToReturnNull: true,\n  },\n};\n")),(0,l.kt)("h3",{id:"what-about-computed-fields"},"What about computed fields?"),(0,l.kt)("p",null,"It's very easy for computed fields (functions) to throw an error due to a logic\nissue in the function. We don't want that bringing down the entire schema so we\nleave these as nullable."),(0,l.kt)("p",null,"I'd be happy to accept a Pull Request that adds functionality marking a function\nas non-nullable via a smart comment (e.g.\n",(0,l.kt)("inlineCode",{parentName:"p"},"COMMENT ON FUNCTION foo_func(foo) IS E'@notNull';"),") - do raise an issue if this\nis of interest to you. Even with this, though, it would be unwise to mark\nroot-level functions as non-nullable - what if the PostgreSQL connection is\nterminated when resolving that field, should that make all the other fields null\ntoo? GraphQL best practices suggest that we should keep errors as localised as\nwe can."),(0,l.kt)("h3",{id:"ive-read-the-above-but-i-still-want-this-particular-thing-to-be-non-nullable"},"I've read the above, but I still want this particular thing to be non-nullable!"),(0,l.kt)("p",null,"Sure! PostGraphile is built with extensibility and customisability in mind - you\ncan fix that with a plugin."),(0,l.kt)("p",null,"Here's a plugin which looks for all forward relation fields (like\n",(0,l.kt)("inlineCode",{parentName:"p"},"personByAuthorId"),") and changes their definition so that their type is the\nGraphQLNonNull-wrapped version of their original type:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},'const NonNullRelationsPlugin: GraphileConfig.Plugin = {\n  name: "NonNullRelationsPlugin",\n  description:\n    "Makes foreign key fields non-nullable if their columns are all `not null`",\n  version: "0.0.0",\n\n  schema: {\n    hooks: {\n      // Hook a field that has already been defined\n      GraphQLObjectType_fields_field(field, build, context) {\n        const {\n          graphql: { GraphQLNonNull, getNullableType },\n          input: { pgRegistry },\n        } = build;\n        // Extract details about why this field was defined.\n        const { isPgSingleRelationField, pgRelationDetails } = context.scope;\n        // See if the field was defined for a singular relation\n        if (isPgSingleRelationField && pgRelationDetails) {\n          // If so, extract details about the relation\n          const { codec, relationName } = pgRelationDetails;\n          // Look up the relation in the registry\n          const relation = pgRegistry.pgRelations[codec.name][relationName];\n          // Determine if every column is non-null\n          const everyColumnIsNonNull = relation.localAttributes.every(\n            (attrName) => codec.attributes[attrName].notNull,\n          );\n          if (!relation.isReferencee && everyColumnIsNonNull) {\n            // If so, change the type of the field to be non-nullable\n            field.type = new GraphQLNonNull(getNullableType(field.type));\n          }\n        }\n        return field;\n      },\n    },\n  },\n};\n')),(0,l.kt)("hr",null),(0,l.kt)("p",null,"If there's other things that are null but you think should not be, please raise\nand issue on GitHub and we'll either fix it, or update this document to explain\nwhy it's nullable."))}c.isMDXComponent=!0}}]);