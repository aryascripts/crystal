"use strict";(self.webpackChunk_localrepo_grafast_website=self.webpackChunk_localrepo_grafast_website||[]).push([[9661],{30876:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var a=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),o=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=o(e.components);return a.createElement(p.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,p=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=o(n),c=r,m=h["".concat(p,".").concat(c)]||h[c]||u[c]||l;return n?a.createElement(m,i(i({ref:t},d),{},{components:n})):a.createElement(m,i({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=c;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[h]="string"==typeof e?e:r,i[1]=s;for(var o=2;o<l;o++)i[o]=n[o];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},44126:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>s,toc:()=>o});var a=n(7896),r=(n(2784),n(30876));const l={sidebar_position:5},i="Plan resolvers",s={unversionedId:"plan-resolvers",id:"plan-resolvers",title:"Plan resolvers",description:"When planning a GraphQL operation, we combine the plans from every field",source:"@site/grafast/plan-resolvers.md",sourceDirName:".",slug:"/plan-resolvers",permalink:"/grafast/plan-resolvers",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/grafast/website/grafast/plan-resolvers.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Servers",permalink:"/grafast/servers"},next:{title:"Step library",permalink:"/grafast/step-library/"}},p={},o=[{value:"Field plan resolvers",id:"field-plan-resolvers",level:2},{value:"Parent step",id:"parent-step",level:3},{value:"Field arguments",id:"field-arguments",level:3},{value:"Example",id:"example",level:3},{value:"Specifying a field plan resolver",id:"specifying-a-field-plan-resolver",level:2},{value:"Asserting an object type&#39;s step",id:"asserting-an-object-types-step",level:3},{value:"Argument and input field plan resolvers",id:"argument-and-input-field-plan-resolvers",level:2},{value:"<code>inputPlan</code> plan resolvers",id:"inputplan-plan-resolvers",level:3},{value:"<code>applyPlan</code> plan resolvers",id:"applyplan-plan-resolvers",level:3},{value:"FieldArgs",id:"fieldargs",level:2},{value:"FieldArgs.get",id:"fieldargsget",level:3},{value:"FieldArgs.getRaw",id:"fieldargsgetraw",level:3},{value:"FieldArgs.apply",id:"fieldargsapply",level:3},{value:"<del>Automatic application of <code>applyPlan</code> plan resolvers</del>",id:"automatic-application-of-applyplan-plan-resolvers",level:2}],d={toc:o},h="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(h,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"plan-resolvers"},"Plan resolvers"),(0,r.kt)("p",null,'When planning a GraphQL operation, we combine the plans from every field\nrequested in the operation into an execution plan that we then optimize. "Field\nplan resolvers" are the functions that detail the plan for each field (there\ncan also be plan resolvers on arguments, input fields, and even enum values;\nbut that\'s more advanced than most people need).'),(0,r.kt)("p",null,"Plan resolvers are synchronous (they must not return promises) since they do\nnot deal with actual runtime data, instead detailing the steps needed to\nprocess all possible data that will be seen at runtime."),(0,r.kt)("h2",{id:"field-plan-resolvers"},"Field plan resolvers"),(0,r.kt)("p",null,"At operation planning time, each time a field is referenced that field's plan\nresolver will be called and the result will be combined into the operation\nplan. When calling the field's resolver, ",(0,r.kt)("grafast",null),' will pass the "parent\nstep" and a "field args" object. The plan resolver may create as many\nintermediate steps as it likes, but it must return exactly one step that\nrepresents the result of the field.'),(0,r.kt)("p",null,"In the case of a field that has a polymorphic type, the step that is returned\nmust be a polymorphic-capable plan (see ",(0,r.kt)("a",{parentName:"p",href:"/grafast/polymorphism"},"polymorphism"),"). In\nthe case of a field that has a list type, the step that is returned must\nproduce lists when executed."),(0,r.kt)("p",null,"A plan resolver can be used instead of, or in addition to, a traditional\nresolver. Since plan resolvers run only when the operation is being planned, not\nwhen it is being executed, they do not have access to any data â”€ only other\nsteps."),(0,r.kt)("p",null,"Like regular resolvers, the first two arguments to a plan resolver represent the\nparent data and the arguments respectively. However, since we're dealing in\npotentials rather than concrete data, both of these are a little different:"),(0,r.kt)("h3",{id:"parent-step"},"Parent step"),(0,r.kt)("p",null,'The first argument, the "parent step," is a step that represents the data from\nthe parent. When the parent field has an object type, the "parent step" is\nsimply the step that the parent field resolved to. When the parent field has a\nlist or polymorphic type, the "parent step" will be the resolved step that\nrepresents an entry from the list or the concrete object type for polymorphism.'),(0,r.kt)("h3",{id:"field-arguments"},"Field arguments"),(0,r.kt)("p",null,'The second argument, the "field arguments" (',(0,r.kt)("inlineCode",{parentName:"p"},"fieldArgs"),"), is an object with\naccess methods to read the arguments. We'll expand on that below in the\n",(0,r.kt)("a",{parentName:"p",href:"#fieldargs"},"FieldArgs")," section."),(0,r.kt)("h3",{id:"example"},"Example"),(0,r.kt)("p",null,"A plan resolver might look something like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'function plan_resolver(\n  $parent: ExecutableStep,\n  args: FieldArgs,\n): ExecutableStep {\n  const $friends = $parent.getRelation("friends");\n  $friends.limit(args.get("limit"));\n  return $friends;\n}\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"By convention, when a variable represents a step we start the variable's name\nwith a ",(0,r.kt)("inlineCode",{parentName:"p"},"$"),".")),(0,r.kt)("p",null,"Of course the actual body of the plan resolver function will vary based on your\nown application's needs."),(0,r.kt)("h2",{id:"specifying-a-field-plan-resolver"},"Specifying a field plan resolver"),(0,r.kt)("p",null,"When building a GraphQL schema programatically, plan resolvers are stored into\n",(0,r.kt)("inlineCode",{parentName:"p"},"extensions.grafast.plan")," of the field; for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{9-15}","{9-15}":!0},'import { GraphQLSchema, GraphQLObjectType, GraphQLInt } from "graphql";\nimport { constant } from "grafast";\n\nconst Query = new GraphQLObjectType({\n  name: "Query",\n  fields: {\n    meaningOfLife: {\n      type: GraphQLInt,\n      extensions: {\n        grafast: {\n          plan() {\n            return constant(42);\n          },\n        },\n      },\n    },\n  },\n});\n\nexport const schema = new GraphQLSchema({\n  query: Query,\n});\n')),(0,r.kt)("p",null,"If you are using ",(0,r.kt)("inlineCode",{parentName:"p"},"makeGrafastSchema")," then the field plan resolver for the field\n",(0,r.kt)("inlineCode",{parentName:"p"},"fieldName")," on the object type ",(0,r.kt)("inlineCode",{parentName:"p"},"typeName")," would be indicated via the\n",(0,r.kt)("inlineCode",{parentName:"p"},"plans[typeName][fieldName]")," property:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{11-13}","{11-13}":!0},'import { makeGrafastSchema, constant } from "grafast";\n\nexport const schema = makeGrafastSchema({\n  typeDefs: /* GraphQL */ `\n    type Query {\n      meaningOfLife: Int\n    }\n  `,\n  plans: {\n    Query: {\n      meaningOfLife() {\n        return constant(42);\n      },\n    },\n  },\n});\n')),(0,r.kt)("h3",{id:"asserting-an-object-types-step"},"Asserting an object type's step"),(0,r.kt)("p",null,"Object types in Gra",(0,r.kt)("em",{parentName:"p"},"fast")," can indicate that they must be represented by a\nparticular step or set of steps to guarantee that the methods on those steps\nare available to the field plan resolvers; this can help to catch bugs early."),(0,r.kt)("p",null,"This indication takes one of two forms, either it's explicitly the step class\nitself, or it's an assertion function that checks that the incoming step is of\nan appropriate type and throws an error otherwise."),(0,r.kt)("p",null,"When defining a schema programatically, ",(0,r.kt)("inlineCode",{parentName:"p"},"assertStep")," is defined via\n",(0,r.kt)("inlineCode",{parentName:"p"},"objectTypeConfig.extensions.grafast.assertStep"),", for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{8-14}","{8-14}":!0},'import { GraphQLObjectType } from "graphql";\nimport { ObjectStep } from "grafast";\n\nconst MyObject = new GraphQLObjectType({\n  name: "MyObject",\n  extensions: {\n    grafast: {\n      assertStep: ObjectStep,\n      /* Or:\n        assertStep($step) {\n          if ($step instanceof ObjectStep) return;\n          throw new Error(`Type \'MyObject\' expects a step of type ObjectStep; instead received a step of type \'${$step.constructor.name}\'`);\n        }\n       */\n    },\n  },\n  fields: {\n    a: {\n      extensions: {\n        grafast: {\n          plan($obj: ObjectStep) {\n            return $obj.get("a");\n          },\n        },\n      },\n    },\n  },\n});\n')),(0,r.kt)("p",null,"When defined via ",(0,r.kt)("inlineCode",{parentName:"p"},"makeGrafastSchema")," we cannot call the property ",(0,r.kt)("inlineCode",{parentName:"p"},"assertStep"),"\ndirectly as it might conflict with a field name, so instead we use\n",(0,r.kt)("inlineCode",{parentName:"p"},"__assertStep"),", knowing that GraphQL forbids fields to start with ",(0,r.kt)("inlineCode",{parentName:"p"},"__")," (two\nunderscores) since those names are reserved for introspection:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{11-17}","{11-17}":!0},"import { makeGrafastSchema, ObjectStep } from \"grafast\";\n\nconst schema = makeGrafastSchema({\n  typeDefs: /* GraphQL */ `\n    type MyObject {\n      a: Int\n    }\n  `,\n  plans: {\n    MyObject: {\n      __assertStep: ObjectStep,\n      /* Or:\n        __assertStep($step) {\n          if ($step instanceof ObjectStep) return;\n          throw new Error(`Type 'MyObject' expects a step of type ObjectStep; instead received a step of type '${$step.constructor.name}'`);\n        }\n       */\n      a($obj: ObjectStep) {\n        return $obj.get(\"a\");\n      },\n    },\n  },\n});\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Generally adding a step assertion is optional; however when there's a union or\ninterface type all types within it must agree whether a step is expected or\nnot. If you want to require steps everywhere but you don't care for a particular\ntype what the step actually is, you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"__assertStep: ExecutableStep")," or\n",(0,r.kt)("inlineCode",{parentName:"p"},"__assertStep: () => true"),".")),(0,r.kt)("h2",{id:"argument-and-input-field-plan-resolvers"},"Argument and input field plan resolvers"),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"This section is very advanced and rarely used, so feel free to skip to the next\nsubsection. It's included here only because FieldArgs (the next section) relies\non these behaviors if present.")),(0,r.kt)("p",null,"In addition to field plan resolvers, Gra",(0,r.kt)("em",{parentName:"p"},"fast")," allows you to attach an ",(0,r.kt)("inlineCode",{parentName:"p"},"inputPlan"),"\nand/or an ",(0,r.kt)("inlineCode",{parentName:"p"},"applyPlan")," to individual arguments or to input fields on input\nobjects. These plan resolvers work a little differently."),(0,r.kt)("h3",{id:"inputplan-plan-resolvers"},(0,r.kt)("inlineCode",{parentName:"h3"},"inputPlan")," plan resolvers"),(0,r.kt)("p",null,"An ",(0,r.kt)("inlineCode",{parentName:"p"},"inputPlan")," plan resolver may exist on an argument or an input field. It is\npassed three arguments:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"the parent plan"),(0,r.kt)("li",{parentName:"ol"},"the FieldArgs relative to this argument or input field"),(0,r.kt)("li",{parentName:"ol"},"additional info (TODO: document)")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"inputPlan")," must return a step that shall be used in place of the argument\nor input value's raw value when ",(0,r.kt)("inlineCode",{parentName:"p"},"FieldArgs.get")," references it."),(0,r.kt)("h3",{id:"applyplan-plan-resolvers"},(0,r.kt)("inlineCode",{parentName:"h3"},"applyPlan")," plan resolvers"),(0,r.kt)("p",null,"An ",(0,r.kt)("inlineCode",{parentName:"p"},"applyPlan")," plan resolver may exist on an argument or an input field. It is\npassed three arguments:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"the target step - the step to apply changes to"),(0,r.kt)("li",{parentName:"ol"},"the FieldArgs relative to this argument or input field"),(0,r.kt)("li",{parentName:"ol"},"additional info (TODO: document)")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"applyPlan")," may either manipulate the target step directly, or it may return\na ModifierStep which will gather changes and then apply them all at once. The\nModifierStep is passed to child input fields ",(0,r.kt)("inlineCode",{parentName:"p"},"applyPlan"),' plan resolvers (if any)\nto allow the changes to stack up. This is particularly useful when building\n"patch" objects to be used with a mutation, or "filter" objects to be used\nagainst a collection.'),(0,r.kt)("h2",{id:"fieldargs"},"FieldArgs"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"FieldArgs")," object gives access to the arguments of a field (when used in a\nfield plan resolver) or to the input fields of an input object (when used for\n",(0,r.kt)("inlineCode",{parentName:"p"},"applyPlan"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"inputPlan"),") or similar for other inputs. It contains three methods:"),(0,r.kt)("h3",{id:"fieldargsget"},"FieldArgs.get"),(0,r.kt)("p",null,"Pass this method either the name of the argument you wish to get, or a path to\nthe value you want through arguments and input objects (",(0,r.kt)("em",{parentName:"p"},"but not lists"),"), and\nyou shall receive a step that represents that value."),(0,r.kt)("p",null,"If the argument or input object field has an ",(0,r.kt)("inlineCode",{parentName:"p"},"inputPlan")," method, it will be\ncalled, and the step that it returns will be used instead of the raw step that\nwould represent the value."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"You may also call ",(0,r.kt)("inlineCode",{parentName:"p"},"fieldArgs.get()")," with no arguments to get the value of the\ncurrent argument/input field; but this may only be done inside ",(0,r.kt)("inlineCode",{parentName:"p"},"inputPlan")," or\n",(0,r.kt)("inlineCode",{parentName:"p"},"applyPlan"),".")),(0,r.kt)("h3",{id:"fieldargsgetraw"},"FieldArgs.getRaw"),(0,r.kt)("p",null,"As FieldArgs.get, except it ignores any ",(0,r.kt)("inlineCode",{parentName:"p"},"inputPlan"),"s and just returns a step\nrepresenting the raw value."),(0,r.kt)("h3",{id:"fieldargsapply"},"FieldArgs.apply"),(0,r.kt)("p",null,"Pass this method a step to apply to and either the name of the argument you wish\nto apply, or a path to the input field you want to apply through arguments and\ninput objects (",(0,r.kt)("em",{parentName:"p"},"but not lists"),"), and the ",(0,r.kt)("inlineCode",{parentName:"p"},"applyPlan")," for that argument or input\nfield will be applied to the given step."),(0,r.kt)("p",null,"TODO: expand this section with examples of why you might do these things."),(0,r.kt)("h2",{id:"automatic-application-of-applyplan-plan-resolvers"},(0,r.kt)("del",{parentName:"h2"},"Automatic application of ",(0,r.kt)("inlineCode",{parentName:"del"},"applyPlan")," plan resolvers")),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"This section is now ",(0,r.kt)("em",{parentName:"p"},"wrong"),". We changed this behavior, and now you need to add\n",(0,r.kt)("inlineCode",{parentName:"p"},"autoApplyAfterParentApplyPlan")," or similar in order to trigger your field to\nauto-apply (or ",(0,r.kt)("inlineCode",{parentName:"p"},"autoApplyAfterParentPlan")," for an argument)."),(0,r.kt)("p",{parentName:"admonition"},"TODO: fix this documentation.")),(0,r.kt)("p",null,(0,r.kt)("del",{parentName:"p"},"FieldArgs keeps track of the arguments/input fields that you ",(0,r.kt)("inlineCode",{parentName:"del"},".get()"),",\n",(0,r.kt)("inlineCode",{parentName:"del"},".getRaw()")," or ",(0,r.kt)("inlineCode",{parentName:"del"},".apply()"),", and should there be any left unaccessed that have an\n",(0,r.kt)("inlineCode",{parentName:"del"},"applyPlan")," method, these will automatically be called passing the field plan\nresolver's resulting step as the argument.")),(0,r.kt)("p",null,(0,r.kt)("del",{parentName:"p"},'This, for example, allows you to associate the "first" behavior with the\nargument rather than the plan resolver, such that you could share the\nfirst/last/before/after behavior via a common object that you spread into each\nof your arguments on connections, rather than having to rewrite the logic in\neach of your plan resolver functions.')))}u.isMDXComponent=!0}}]);