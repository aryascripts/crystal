"use strict";(self.webpackChunk_localrepo_postgraphile_website=self.webpackChunk_localrepo_postgraphile_website||[]).push([[7585],{36702:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(48084),r=n(2784);a.o.initialize({startOnLoad:!0,flowchart:{diagramPadding:8,nodeSpacing:20,rankSpacing:40,htmlLabels:!0}});const i=e=>{let{chart:t}=e;return(0,r.useEffect)((()=>{a.o.contentLoaded()}),[]),r.createElement("div",{className:"mermaid"},t)}},61337:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>h});var a=n(7896),r=(n(2784),n(30876)),i=n(36702);const o={title:"Migrating from V4"},l="Migrating from V4",s={unversionedId:"migrating-from-v4/index",id:"migrating-from-v4/index",title:"Migrating from V4",description:'One of the main aims for PostGraphile V5 was to replace the "lookahead engine"',source:"@site/postgraphile/migrating-from-v4/index.mdx",sourceDirName:"migrating-from-v4",slug:"/migrating-from-v4/",permalink:"/postgraphile/next/migrating-from-v4/",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/postgraphile/website/postgraphile/migrating-from-v4/index.mdx",tags:[],version:"current",frontMatter:{title:"Migrating from V4"},sidebar:"docs",previous:{title:"Running PostGraphile as a library in Docker",permalink:"/postgraphile/next/running-postgraphile-as-a-library-in-docker"},next:{title:"V5 New Feature Summary",permalink:"/postgraphile/next/migrating-from-v4/v5-new-feature-summary"}},p={},h=[{value:"Basic configuration",id:"basic-configuration",level:2},{value:"makeV4Preset",id:"makev4preset",level:3},{value:"Larger example",id:"larger-example",level:3},{value:"additionalGraphQLContextFromRequest",id:"additionalgraphqlcontextfromrequest",level:3},{value:"pgSettings",id:"pgsettings",level:3},{value:"Breaking GraphQL schema changes",id:"breaking-graphql-schema-changes",level:2},{value:"Smart tag changes",id:"smart-tag-changes",level:2},{value:"Running",id:"running",level:2},{value:"CLI",id:"cli",level:3},{value:"Library mode",id:"library-mode",level:3},{value:"Schema only mode",id:"schema-only-mode",level:3},{value:"Server",id:"server",level:2},{value:"GraphiQL",id:"graphiql",level:2},{value:"Plugins",id:"plugins",level:2},{value:"Plans, not resolvers",id:"plans-not-resolvers",level:2},{value:"Introspection",id:"introspection",level:2},{value:"Introspection cache",id:"introspection-cache",level:2},{value:"<code>buildSchema</code>",id:"buildschema",level:2},{value:"<code>postgraphile-core</code>",id:"postgraphile-core",level:2},{value:"Module landscape",id:"module-landscape",level:2}],d={toc:h},m="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"migrating-from-v4"},"Migrating from V4"),(0,r.kt)("p",null,"One of the main aims for PostGraphile V5 was to replace the \"lookahead engine\"\nwith something better: easier to reason about, easier to maintain and extend,\neasier for users to interact with, and more capable of handling GraphQL's\npresent and future feature set (V4's lookahead doesn't even support interfaces\nand unions, let alone ",(0,r.kt)("inlineCode",{parentName:"p"},"@stream"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"@defer"),", client controlled nullability, and\neverything else that's coming down the GraphQL pipeline)."),(0,r.kt)("p",null,"We didn't set out to do so, but ultimately this ended up with us writing our own\nGraphQL runtime, called ",(0,r.kt)("a",{parentName:"p",href:"https://grafast.org"},"Gra",(0,r.kt)("em",{parentName:"a"},"fast")),". This runtime is built around a\ncarefully engineered planning phase followed by an highly optimized execution\nphase. This much more powerful system allowed us to generate much more\nefficient SQL queries, and to execute requests much faster than in V4, which\nwas already pretty fast!"),(0,r.kt)("p",null,"However, Gra",(0,r.kt)("em",{parentName:"p"},"fast")," was completely different (not similar in the slightest) to V4's\nlookahead engine, and that lookahead engine was the beating heart of V4.\nReplacing it required us to rebuild the entire stack from scratch on top of\nthese new foundations."),(0,r.kt)("p",null,"Since we had to rebuild everything anyway, we decided to fix a large number of\nissues that had been bugging us for a while... The plugin system has been\nconsolidated and transformed, the configuration system has been consolidated\nand transformed, some of the smart tags (",(0,r.kt)("inlineCode",{parentName:"p"},"@omit"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"@simpleCollections"),", etc)\nhave been replaced with behaviors (",(0,r.kt)("inlineCode",{parentName:"p"},"@behavior"),"), all the plugins have been\nrewritten or replaced, the defaults have evolved, ... but I'm getting ahead of\nmyself."),(0,r.kt)("p",null,"If you're reading this, you probably want to know how to take your PostGraphile\nV4 project and run it in PostGraphile V5 instead with the minimal of fuss. One\nof the reasons that V5 took so long, other than that we invented an entirely\nnew set of technologies and then rebuilt the entire Graphile GraphQL ecosystem\nfrom scratch on top of them, was the amount of effort that we put into trying\nto minimize the amount of effort it will take ",(0,r.kt)("em",{parentName:"p"},"you")," to move to V5."),(0,r.kt)("p",null,"Note that there are subpages dedicated to particular plugin/plugin generators\nthat need their own V5 migration strategy."),(0,r.kt)("p",null,"Let's get started."),(0,r.kt)("h2",{id:"basic-configuration"},"Basic configuration"),(0,r.kt)("p",null,'PostGraphile V5 requires a "preset" to be specified; this allows users to start\nwith the best settings for their intended use case without having to read pages\nof documentation first. It also allows us to evolve the defaults over time\nwithout breaking existing users schemas - ultimately meaning we no longer need a\n"recommended options" section in the docs.'),(0,r.kt)("p",null,"To achieve this, we've introduced a new module: ",(0,r.kt)("a",{parentName:"p",href:"https://star.graphile.org/graphile-config/"},(0,r.kt)("inlineCode",{parentName:"a"},"graphile-config")),". This module\ntakes care of the common concerns relating to configuration, in particular:\npresets, plugins and options. You store your config into a ",(0,r.kt)("inlineCode",{parentName:"p"},"graphile.config.js"),"\n(or ",(0,r.kt)("inlineCode",{parentName:"p"},".ts"),", ",(0,r.kt)("inlineCode",{parentName:"p"},".mjs"),", ",(0,r.kt)("inlineCode",{parentName:"p"},".mts"),") file and this can then be used from the command\nline, library mode, or even schema-only mode - they all share the same\nconfiguration."),(0,r.kt)("h3",{id:"makev4preset"},"makeV4Preset"),(0,r.kt)("p",null,"To make the transition to this new system easier, we've built a ",(0,r.kt)("inlineCode",{parentName:"p"},"makeV4Preset"),"\npreset factory for you that converts a number of the options that you are\nfamiliar with from V4 into their V5 equivalents. To use it, feed your options\ninto its first argument, and combine it with ",(0,r.kt)("inlineCode",{parentName:"p"},"postgraphile/presets/amber")," (our\ninitial preset) to get a completed config:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="graphile.config.js"',title:'"graphile.config.js"'},'import { PostGraphileAmberPreset } from "postgraphile/presets/amber";\n// highlight-next-line\nimport { makeV4Preset } from "postgraphile/presets/v4";\nimport { makePgService } from "postgraphile/adaptors/pg";\n\n/** @type {GraphileConfig.Preset} */\nconst preset = {\n  extends: [\n    PostGraphileAmberPreset,\n    // highlight-start\n    makeV4Preset({\n      /* PUT YOUR V4 OPTIONS HERE, e.g.: */\n      simpleCollections: "both",\n      jwtPgTypeIdentifier: \'"b"."jwt_token"\',\n    }),\n    // highlight-end\n  ],\n\n  pgServices: [\n    makePgService({\n      connectionString: process.env.DATABASE_URL,\n      schemas: ["app_public"],\n    }),\n  ],\n};\n\nexport default preset;\n')),(0,r.kt)("h3",{id:"larger-example"},"Larger example"),(0,r.kt)("p",null,"Here's a larger documented preset with more details:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="graphile.config.js"',title:'"graphile.config.js"'},'import "graphile-config";\n\nimport { PostGraphileAmberPreset } from "postgraphile/presets/amber";\nimport { makeV4Preset } from "postgraphile/presets/v4";\n// Use the \'pg\' module to connect to the database\nimport { makePgService } from "postgraphile/adaptors/pg";\n\n/** @type {GraphileConfig.Preset} */\nconst preset = {\n  extends: [\n    // The initial PostGraphile V5 preset\n    PostGraphileAmberPreset,\n\n    // Change the options and add/remove plugins based on your V4 configuration:\n    makeV4Preset({\n      /* PUT YOUR V4 OPTIONS HERE, e.g.: */\n      simpleCollections: "both",\n      jwtPgTypeIdentifier: \'"b"."jwt_token"\',\n      appendPlugins: [\n        /*...*/\n      ],\n    }),\n\n    // Note some plugins are now "presets", e.g.\n    // `@graphile/simplify-inflection`, those should be listed here instead of `appendPlugins`\n  ],\n\n  plugins: [\n    /*\n     * If you were using `pluginHook` before, the relevant plugins will need\n     * listing here instead. You can also move the `appendPlugins` list here\n     * for consistency if you like.\n     */\n  ],\n\n  /*\n   * PostgreSQL database configuration.\n   *\n   * If you\'re using the CLI you can skip this and use the `-c` and `-s`\n   * options instead, but we advise configuring it here so all the modes of\n   * running PostGraphile can share it.\n   */\n  pgServices: [\n    makePgService({\n      // Database connection string:\n      connectionString: process.env.DATABASE_URL,\n      // List of schemas to expose:\n      schemas: ["app_public"],\n      // Superuser connection string, only needed if you\'re using watch mode:\n      // superuserConnectionString: process.env.SUPERUSER_DATABASE_URL,\n    }),\n  ],\n};\n\nexport default preset;\n')),(0,r.kt)("p",null,"Note that the ",(0,r.kt)("inlineCode",{parentName:"p"},"appendPlugins"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"prependPlugins"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"skipPlugins")," options require\nV5-compatible plugins, and ",(0,r.kt)("inlineCode",{parentName:"p"},"pluginHook")," is no longer supported - please use the\n",(0,r.kt)("inlineCode",{parentName:"p"},"plugins")," configuration key instead."),(0,r.kt)("p",null,"Note also that ",(0,r.kt)("inlineCode",{parentName:"p"},"PgNodeAliasPostGraphile")," (plugin) no longer exists, so instead\nof skipping it with ",(0,r.kt)("inlineCode",{parentName:"p"},"skipPlugins")," you should add the following to your preset:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const preset = {\n  // ...\n  schema: {\n    // ...\n    pgV4UseTableNameForNodeIdentifier: false,\n  },\n};\n")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Not all of the community's V4 plugins have been ported to V5 at time of\nwriting, but with your help hopefully we can fix that! See the ",(0,r.kt)("a",{parentName:"p",href:"/postgraphile/next/community-plugins"},"community\nplugins page")," for details of which plugins have been\nported.")),(0,r.kt)("h3",{id:"additionalgraphqlcontextfromrequest"},"additionalGraphQLContextFromRequest"),(0,r.kt)("p",null,"You can provide this to ",(0,r.kt)("inlineCode",{parentName:"p"},"makeV4Preset({ additionalGraphQLContextFromRequest })"),", so no specific action is required."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"If you want to do this the V5 way then the replacement is the\n'grafast.context' option; please see ",(0,r.kt)("a",{parentName:"p",href:"/postgraphile/next/config#grafast-options"},"configuration -\ncontext"),"."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const preset = {\n  //...\n  grafast: {\n    context(ctx) {\n      // Other servers/transports add different details to `ctx`.\n      const { req, res } = ctx.node ?? {};\n      return additionalGraphQLContextFromRequest(req, res);\n    },\n  },\n};\n"))),(0,r.kt)("h3",{id:"pgsettings"},"pgSettings"),(0,r.kt)("p",null,"You can provide this to ",(0,r.kt)("inlineCode",{parentName:"p"},"makeV4Preset({ pgSettings })"),", so no specific action is required."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"If you want to do this the V5 way then the replacement is to\nreturn a ",(0,r.kt)("inlineCode",{parentName:"p"},"pgSettings")," key from the GraphQL context returned from your\n'grafast.context' configuration, for more details see ",(0,r.kt)("a",{parentName:"p",href:"/postgraphile/next/config#grafast-options"},"configuration -\ncontext"),"."),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const preset = {\n  //...\n  grafast: {\n    context(ctx) {\n      // Other servers/transports add different details to `ctx`.\n      const { req } = ctx.node ?? {};\n      return {\n        pgSettings: pgSettings(req);\n      };\n    },\n  },\n};\n"))),(0,r.kt)("h2",{id:"breaking-graphql-schema-changes"},"Breaking GraphQL schema changes"),(0,r.kt)("p",null,"We've done our best to maintain as much compatibility with a V4 GraphQL schema\nas possible when you use ",(0,r.kt)("inlineCode",{parentName:"p"},"makeV4Preset()"),", but some breaking changes persist\n(we'd argue they're for the better!). Of course if any of these are critical\nissues to you they can all be solved by writing a plugin to shape the GraphQL\nAPI how you need, but we suggest that if possible you accept these new changes."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'The long deprecated "legacy relations" are no longer generated.'),(0,r.kt)("li",{parentName:"ul"},"Node IDs for bigint columns have changed (specifically numbers under\n",(0,r.kt)("inlineCode",{parentName:"li"},"MAX_SAFE_INT")," now have quote marks inside the encoding too)"),(0,r.kt)("li",{parentName:"ul"},"In alignment with the\n",(0,r.kt)("a",{parentName:"li",href:"https://relay.dev/graphql/connections.htm"},"Cursor connections specification"),",\nconnection edges are nullable and cursors are not. It seems we implemented\nthis the wrong way around in V4."),(0,r.kt)("li",{parentName:"ul"},"For ",(0,r.kt)("inlineCode",{parentName:"li"},"fooEdge")," fields on mutation payloads, the ",(0,r.kt)("inlineCode",{parentName:"li"},"orderBy")," argument is now\nnon-nullable. It still has a default, so this will only affect you if you were\nexplicitly passing ",(0,r.kt)("inlineCode",{parentName:"li"},"null")," (which seems unlikely since it's not useful)."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"fooEdge")," fields on mutation payloads now only exist if the table has a\nprimary key."),(0,r.kt)("li",{parentName:"ul"},"If you disable ",(0,r.kt)("inlineCode",{parentName:"li"},"NodePlugin")," then the ",(0,r.kt)("inlineCode",{parentName:"li"},"deletedFooId")," field on mutation\npayloads now will not be added to the schema (it never should have been)."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"bytea")," type is now natively supported, exposed as ",(0,r.kt)("inlineCode",{parentName:"li"},"Base64EncodedBinary"))),(0,r.kt)("p",null,"Many of the above issues will not cause any problems for the vast majority of\nyour operations - an engineer from our sponsor Netflix reported all 4,000\nunique queries that their very large and complex V4 internal schema received in\nFeb 2023 validated successfully against their V5 schema - zero breakage!\nDespite the query compatibility, you may still need to migrate some types on\nthe client side."),(0,r.kt)("p",null,"Other changes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The values generated for ",(0,r.kt)("inlineCode",{parentName:"li"},"cursor")," differ. This is not deemed to be a breaking\nchange, as these may change from one release to the next (even patch versions)."),(0,r.kt)("li",{parentName:"ul"},"In some circumstances the location where a ",(0,r.kt)("inlineCode",{parentName:"li"},"null")," is returned or an error is\nthrown may differ slightly between V4 and V5; this will still respect the\nGraphQL schema though, of course."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"PgIndexBehaviorsPlugin")," (the V5 equivalent of ",(0,r.kt)("inlineCode",{parentName:"li"},"--no-ignore-indexes"),') now\nonly removes the backwards ("has many") relation when a relation is\nunindexed, since the forwards ("belongs to") relation is always indexed')),(0,r.kt)("h2",{id:"smart-tag-changes"},"Smart tag changes"),(0,r.kt)("p",null,"Despite the following changes, if you're using ",(0,r.kt)("inlineCode",{parentName:"p"},"makeV4Preset")," then you should\nnot need to take any action - the established V4 behavior should be\nautomatically emulated."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"@uniqueKey")," smart tag is no more; the V4 preset converts it to\n",(0,r.kt)("inlineCode",{parentName:"li"},"@unique ...|@behavior -single -update -delete")," for you."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"@omit")," smart tag is no more; the V4 preset converts it to the\nrelevant ",(0,r.kt)("a",{parentName:"li",href:"/postgraphile/next/behavior"},"behavior")," for you."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"@simpleCollections")," smart tag is no more; the V4 preset converts it to the\nrelevant ",(0,r.kt)("a",{parentName:"li",href:"/postgraphile/next/behavior"},"behavior")," for you."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"@foreignKey")," smart tag must reference a unique constraint or primary\nkey; the V4 preset automatically sets\n",(0,r.kt)("inlineCode",{parentName:"li"},"pgFakeConstraintsAutofixForeignKeyUniqueness: true")," which creates this\n",(0,r.kt)("inlineCode",{parentName:"li"},"unique")," for you (via a smart tag) and gives it the relevant behaviors so\nthat it doesn't turn into more fields/arguments/etc.")),(0,r.kt)("p",null,"The behavior system gives much finer grained control over which things\nshould/should not be exposed in the schema, and how. If you use the V4 preset\nthen we'll automatically translate the old smart tags into their behavior\nequivalents, so you shouldn't need to worry too much about this right now. We\ndo advise that you migrate to the behavior system though, it's much more\npowerful."),(0,r.kt)("h2",{id:"running"},"Running"),(0,r.kt)("h3",{id:"cli"},"CLI"),(0,r.kt)("p",null,"You can run V5 with the ",(0,r.kt)("inlineCode",{parentName:"p"},"postgraphile")," (or ",(0,r.kt)("inlineCode",{parentName:"p"},"pgl"),") command. This command\nautomatically reads the ",(0,r.kt)("inlineCode",{parentName:"p"},"graphile.config.js")," file; you should use that for\nadvanced configuration of the PostGraphile CLI rather than sending loads of CLI\nflags - this enables us to keep the documentation tighter (documenting just one\nset of options rather than 4), gives you auto-complete (if your editor supports\nit) on the options, allows you to easily add comments on why the various\noptions are enabled, and makes it easier to transition between CLI, library and\nschema-only modes."),(0,r.kt)("p",null,"Currently the main options are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"-P")," - the preset to use, e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"-P postgraphile/presets/amber")," (or ",(0,r.kt)("inlineCode",{parentName:"li"},"-P\npgl/amber")," if you're using ",(0,r.kt)("inlineCode",{parentName:"li"},"pgl"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"-p")," - the port to listen on; if not set then it will try and use ",(0,r.kt)("inlineCode",{parentName:"li"},"5678")," but\n",(0,r.kt)("em",{parentName:"li"},"will fallback to a system-assigned port")," so be sure to set this in\nproduction!"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"-n")," - the host to listen on; defaults to 'localhost' (you may want to change\nto '0.0.0.0' in Docker or similar environments)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"-c postgres://...")," - your connection string (same as in V4)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"-S postgres://...")," - your superuser connection string (replaces V4's\n",(0,r.kt)("inlineCode",{parentName:"li"},"-C"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"--owner-connection")," flag)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"-s app_public")," - your list of PostgreSQL schemas (same as in V4)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"-e"),' - enable "explain" - this allows Ruru (formerly called PostGraphiQL) to\nrender the operation plan and SQL queries that were executed'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"-C")," - the config file to load; if not set we'll try and load\n",(0,r.kt)("inlineCode",{parentName:"li"},"graphile.config.js")," (or similar with different extensions) but won't raise\nan error if it doesn't exist")),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"postgraphile -P postgraphile/presets/amber -c postgres:///my_db_name -s public -e\n# or: pgl -P pgl/amber -c postgres:///my_db_name -s public -e\n")),(0,r.kt)("h3",{id:"library-mode"},"Library mode"),(0,r.kt)("p",null,"Load your config from your ",(0,r.kt)("inlineCode",{parentName:"p"},"graphile.config.js")," file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import preset from "./graphile.config.js";\n')),(0,r.kt)("p",null,"Then feed your preset into the\n",(0,r.kt)("inlineCode",{parentName:"p"},"postgraphile")," function to get a PostGraphile instance (",(0,r.kt)("inlineCode",{parentName:"p"},"pgl"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const pgl = postgraphile(preset);\n")),(0,r.kt)("p",null,"In V4 this would have been a middleware, but in V5 we let ",(0,r.kt)("a",{parentName:"p",href:"https://grafast.org/grafserv"},"Grafserv")," handle\nthe webserver portions (rather than PostGraphile having its own internal\nserver), this allows us to provide deep integration with the various JS\nwebservers (much better than we had in V4!). This has, however, necessitated a\ndifferent approach, so instead of a middleware the result of calling\n",(0,r.kt)("inlineCode",{parentName:"p"},"postgraphile()")," is a PostGraphile instance which provides a collection of\nhelper methods."),(0,r.kt)("p",null,"We'll be using the ",(0,r.kt)("inlineCode",{parentName:"p"},"pgl.createServ()")," helper in a moment, but first load the\ncorrect ",(0,r.kt)("a",{parentName:"p",href:"https://grafast.org/grafserv"},"Grafserv")," adaptor for the JS server that you're using:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { grafserv } from "grafserv/node";\n// OR: import { grafserv } from "grafserv/express/v4";\n// OR: import { grafserv } from "grafserv/koa/v2";\n// OR: import { grafserv } from "grafserv/fastify/v4";\n// etc\n')),(0,r.kt)("p",null,"Then feed this into ",(0,r.kt)("inlineCode",{parentName:"p"},"pgl.createServ")," to get a ",(0,r.kt)("inlineCode",{parentName:"p"},"serv")," Grafserv instance:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const serv = pgl.createServ(grafserv);\n")),(0,r.kt)("p",null,"Finally mount the ",(0,r.kt)("inlineCode",{parentName:"p"},"serv")," instance into your server of choice using the API your\nchosen Grafserv adaptor recommends (typically ",(0,r.kt)("inlineCode",{parentName:"p"},"serv.addTo(...)"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { createServer } from "node:http";\nconst server = createServer();\nserver.on("error", (e) => console.error(e));\n\n// highlight-next-line\nserv.addTo(server);\n\nserver.listen(preset.grafserv?.port ?? 5678);\n')),(0,r.kt)("p",null,"Let's pull this all together to see an example using the Node built-in HTTP\nserver:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="server.js"',title:'"server.js"'},'import preset from "./graphile.config.js";\nimport { postgraphile } from "postgraphile";\nimport { grafserv } from "grafserv/node"; // Adaptor for Node\'s HTTP server\nimport { createServer } from "node:http";\n\n// Create an HTTP server (with error handler)\nconst server = createServer();\nserver.on("error", (e) => console.error(e));\n\n// Create a PostGraphile instance (pgl)\nconst pgl = postgraphile(preset);\n// Create a Grafserv (server adaptor) instance for this PostGraphile instance\nconst serv = pgl.createServ(grafserv);\n// Attach a request handler to the server\nserv.addTo(server);\n\n// Start the server\nserver.listen(preset.grafserv?.port ?? 5678);\n')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Node.js' ",(0,r.kt)("inlineCode",{parentName:"p"},"http.createServer()")," does ",(0,r.kt)("em",{parentName:"p"},"not")," need to be passed a request handler -\nyou can attach one later via ",(0,r.kt)("inlineCode",{parentName:"p"},"server.on('request', handler)")," which is exactly\nwhat we do behind the scenes in the example above. The reason for this approach\nis that it gives us a chance to also add a ",(0,r.kt)("inlineCode",{parentName:"p"},"server.on('upgrade', ...)")," handler\nfor dealing with websockets if ",(0,r.kt)("inlineCode",{parentName:"p"},"preset.grafserv.websockets")," is ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),".")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The above code might differ significantly depending on which webserver\nframework you're using. In V4 we tried to support as many servers as possible\nby reducing everything to the lowest common denominator: the Node HTTP ",(0,r.kt)("inlineCode",{parentName:"p"},"req"),"\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"res")," objects. This made it easy to add the middleware, but made it\nchallenging for you to deeply integrate with the various middlewares and\ncapabilities in your webserver of choice. In V5, we have created an independent\nabstraction over HTTP requests which Grafserv handles, and then we provide\ndifferent adaptors (or you can write your own!) to convert back and forth\nbetween your webserver framework and our internal request abstractions."),(0,r.kt)("p",{parentName:"admonition"},"Please see the ",(0,r.kt)("a",{parentName:"p",href:"https://grafast.org/grafserv"},"Grafserv")," documentation for details.")),(0,r.kt)("h3",{id:"schema-only-mode"},"Schema only mode"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"createPostGraphileSchema")," is now just ",(0,r.kt)("inlineCode",{parentName:"p"},"makeSchema")," (and can be imported from\n",(0,r.kt)("inlineCode",{parentName:"p"},"postgraphile")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"graphile-build")," - your choice). It only accepts one argument\nnow - the preset that you'd load from your ",(0,r.kt)("inlineCode",{parentName:"p"},"graphile.config.js")," (or similar)\nfile:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { makeSchema } from "postgraphile";\nimport preset from "./graphile.config.js";\n\n// highlight-next-line\nconst { schema, resolvedPreset } = await makeSchema(preset);\n')),(0,r.kt)("p",null,"There is no need for ",(0,r.kt)("inlineCode",{parentName:"p"},"withPostGraphileContext")," any more; the context no longer\nhas a lifecycle that needs to be carefully managed. Just run the query through\n",(0,r.kt)("inlineCode",{parentName:"p"},"grafast")," as you normally would through ",(0,r.kt)("inlineCode",{parentName:"p"},"graphql"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"context")," will still need to be generated however. The easy option is to\nhave this done automatically by passing the ",(0,r.kt)("inlineCode",{parentName:"p"},"resolvedPreset")," and a\n",(0,r.kt)("inlineCode",{parentName:"p"},"requestContext")," object as part of the args to your ",(0,r.kt)("inlineCode",{parentName:"p"},"grafast")," call:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="schema-only.mjs"',title:'"schema-only.mjs"'},'import { grafast } from "grafast";\nimport { makeSchema } from "postgraphile";\nimport preset from "./graphile.config.js";\n\nconst { schema, resolvedPreset } = await makeSchema(preset);\n\nconst args = {\n  schema,\n  // highlight-next-line\n  resolvedPreset,\n  // highlight-next-line\n  requestContext: {},\n  source: /* GraphQL */ `\n    query MyQuery {\n      __typename\n    }\n  `,\n};\nconst result = await grafast(args);\nconsole.dir(result);\n')),(0,r.kt)("p",null,"Alternatively, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"hookArgs")," method to hook the execution args and\nattach all the relevant context data to it based on your preset and its\nplugins. This is somewhat more involved, please see the ",(0,r.kt)("a",{parentName:"p",href:"/postgraphile/next/usage-schema"},"schema only\nusage")," documentation for that."),(0,r.kt)("h2",{id:"server"},"Server"),(0,r.kt)("p",null,"PostGraphile's HTTP server has been replaced with ",(0,r.kt)("a",{parentName:"p",href:"https://grafast.org/grafserv"},"Grafserv"),", our new\nultra-fast general purpose Gra",(0,r.kt)("em",{parentName:"p"},"fast"),"-powered GraphQL server. Currently this\ndoesn't support the same hooks that V4's server did, but we can certainly extend\nthe hooks support over time. If there's a particular hook you need, please reach\nout."),(0,r.kt)("h2",{id:"graphiql"},"GraphiQL"),(0,r.kt)("p",null,"Our beloved PostGraphiQL has been transformed into a more modern general purpose\nGraphiQL called ",(0,r.kt)("a",{parentName:"p",href:"https://grafast.org/ruru"},"Ruru"),". This still integrates into the server, but you can\nalso run it directly from the command line now too! It doesn't have a plugin\nsystem yet, but it will \ud83d\ude01"),(0,r.kt)("p",null,"You can try ruru out against any GraphQL API (not only those made by\nPostGraphile) via:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npx ruru@beta -PSe http://localhost:5678/graphql\n")),(0,r.kt)("h2",{id:"plugins"},"Plugins"),(0,r.kt)("p",null,"The plugin architecture has been transformed: whereas plugins previously were\nfunctions, they are now declarative objects. For example a plugin that adds the\n",(0,r.kt)("inlineCode",{parentName:"p"},"Query.four")," field might have looked like this in V4:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="V4AddQueryFourFieldPlugin.js"',title:'"V4AddQueryFourFieldPlugin.js"'},'// Version 4 example; will not work with V5!\n// highlight-start\nmodule.exports = (builder) => {\n  builder.hook("GraphQLObjectType:fields", (fields, build, context) => {\n    // highlight-end\n    const {\n      graphql: { GraphQLInt },\n    } = build;\n    const { Self } = context;\n    if (Self.name !== "Query") return fields;\n    return build.extend(\n      fields,\n      {\n        four: {\n          type: GraphQLInt,\n          // highlight-start\n          resolve() {\n            return 4;\n          },\n          // highlight-end\n        },\n      },\n      "Adding Query.four",\n    );\n  });\n};\n')),(0,r.kt)("p",null,"In V5 the equivalent would be:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="V5AddQueryFourFieldPlugin.js"',title:'"V5AddQueryFourFieldPlugin.js"'},'// highlight-start\nconst { constant } = require("grafast");\nmodule.exports = {\n  name: "AddQueryFourFieldPlugin",\n  version: "0.0.0",\n  schema: {\n    hooks: {\n      GraphQLObjectType_fields(fields, build, context) {\n        // highlight-end\n        const {\n          graphql: { GraphQLInt },\n        } = build;\n        const { Self } = context;\n        if (Self.name !== "Query") return fields;\n        return build.extend(\n          fields,\n          {\n            four: {\n              type: GraphQLInt,\n              // highlight-start\n              plan() {\n                return constant(4);\n              },\n              // highlight-end\n            },\n          },\n          "Adding Query.four",\n        );\n      },\n    },\n  },\n};\n')),(0,r.kt)("p",null,"The callback itself is very similar, the hook name has been renamed to use\nunderscores instead of colons (",(0,r.kt)("inlineCode",{parentName:"p"},"GraphQLObjectType:fields")," ->\n",(0,r.kt)("inlineCode",{parentName:"p"},"GraphQLObjectType_fields"),"), and rather than explicitly calling a ",(0,r.kt)("inlineCode",{parentName:"p"},"hook"),"\nfunction to register it, it's implicitly registered by being part of the plugin\nobject."),(0,r.kt)("p",null,"This new structure allows the system to learn more about the plugin before\nactually running it, and can improve the debugging messages when things go\nwrong."),(0,r.kt)("p",null,"Keep in mind that we no longer have the lookahead system so\n",(0,r.kt)("inlineCode",{parentName:"p"},"addArgDataGenerator")," and its ilk no longer exist, instead we declare a\n",(0,r.kt)("a",{parentName:"p",href:"https://grafast.org/grafast/plan-resolvers/#applyplan-plan-resolvers"},"Gra",(0,r.kt)("em",{parentName:"a"},"fast")," ",(0,r.kt)("inlineCode",{parentName:"a"},"applyPlan")),"\nor similar plan resolver."),(0,r.kt)("h2",{id:"plans-not-resolvers"},"Plans, not resolvers"),(0,r.kt)("p",null,"The new system uses ",(0,r.kt)("a",{parentName:"p",href:"https://grafast.org"},"Gra",(0,r.kt)("em",{parentName:"a"},"fast"))," which has a plan based system, so\nrather than writing traditional GraphQL resolvers for each field, you will write\n",(0,r.kt)("a",{parentName:"p",href:"https://grafast.org/grafast/plan-resolvers"},"Gra",(0,r.kt)("em",{parentName:"a"},"fast")," plan resolvers"),". This makes the system a lot more powerful and is a\nlot more intuitive than our lookahead system once you've spent a little time\nlearning it. It also completely removes the need for old awkward-to-use\ndirectives such as ",(0,r.kt)("inlineCode",{parentName:"p"},"@pgQuery")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"@requires"),"! (See\n",(0,r.kt)("a",{parentName:"p",href:"./make-extend-schema-plugin"},"makeExtendSchemaPlugin migration")," for details on\nmigrating these directives.)"),(0,r.kt)("h2",{id:"introspection"},"Introspection"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"build.pgIntrospectionResultsByKind")," is no more; instead we have a new library\n",(0,r.kt)("a",{parentName:"p",href:"https://npmjs.com/package/pg-introspection"},"pg-introspection")," that takes care of introspection and has parts of the\nPostgreSQL documentation built in via TypeScript hints."),(0,r.kt)("p",null,"The schema build process has been split into two phases:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"gather"),": looks at the introspection results and uses them to generate\nresources, codecs, relations and behaviors (the four building blocks)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"schema"),": looks at these resources, codecs, relations and behaviors and\ngenerates a GraphQL schema from them")),(0,r.kt)("p",null,"Generally introspection data is not available during the ",(0,r.kt)("inlineCode",{parentName:"p"},"schema")," phase; which\nalso means that you can manually write your own\nresources/codecs/relations/behaviors and have a GraphQL schema autogenerated by\nthem independent of what your PostgreSQL schema actually is!"),(0,r.kt)("h2",{id:"introspection-cache"},"Introspection cache"),(0,r.kt)("p",null,"There is no introspection cache any more, so no ",(0,r.kt)("inlineCode",{parentName:"p"},"--read-cache"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"--write-cache"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"readCache")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"writeCache"),". Instead you can build the GraphQL schema and then\n",(0,r.kt)("a",{parentName:"p",href:"/postgraphile/next/exporting-schema"},"export it as executable code")," using\n",(0,r.kt)("inlineCode",{parentName:"p"},"graphile-export"),". In production you simply run this exported\ncode - there's no need for database introspection, schema building plugins,\netc - and you instantly get your schema without the complexities (or\ndependencies!) required in building it dynamically."),(0,r.kt)("h2",{id:"buildschema"},(0,r.kt)("inlineCode",{parentName:"h2"},"buildSchema")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"buildSchema")," is now synchronous - you need to run the asynchronous gather phase\nfirst. The arguments have also changed: first is the preset (this encompasses\nthe list of plugins which was previously the first argument, and any settings\nwhich were previously the second argument), second comes the result of gather\nand finally comes the shared object which contains inflection."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { resolvePresets } from "graphile-config";\nimport { buildInflection, gather, buildSchema } from "graphile-build";\nimport preset from "./graphile.config.js";\n\nconst resolvedPreset = resolvePresets([preset]);\nconst shared = { inflection: buildInflection(resolvedPreset) };\nconst input = await gather(resolvedPreset, shared);\nconst schema = buildSchema(resolvedPreset, input, shared);\n')),(0,r.kt)("h2",{id:"postgraphile-core"},(0,r.kt)("inlineCode",{parentName:"h2"},"postgraphile-core")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"postgraphile-core")," is no more (look ma, I'm a poet!); here's how to replace\n",(0,r.kt)("inlineCode",{parentName:"p"},"createPostGraphileSchema"),":"),(0,r.kt)("p",null,"Before:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { createPostGraphileSchema } from "postgraphile-core";\n\n// ...\n\nconst schema = await createPostGraphileSchema(DATABASE_URL, "public", {\n  // options\n});\n')),(0,r.kt)("p",null,"After:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { makeSchema } from "postgraphile";\nimport preset from "./graphile.config.js";\n\nconst { schema, resolvedPreset } = await makeSchema(preset);\n')),(0,r.kt)("h2",{id:"module-landscape"},"Module landscape"),(0,r.kt)("p",null,"In PostGraphile V4 the main modules you'd deal with were:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"postgraphile")," - orchestration layer and CLI/server/middleware for our GraphQL schema, plus ",(0,r.kt)("inlineCode",{parentName:"li"},"pluginHook"),' "server plugins" functionality, and the home of "PostGraphiQL" our embedded PostGraphile-flavoured GraphiQL.'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"postgraphile-core")," - integration layer between the ",(0,r.kt)("inlineCode",{parentName:"li"},"postgraphile")," module and the ",(0,r.kt)("inlineCode",{parentName:"li"},"graphile-build")," system that builds our GraphQL schema."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"graphile-build")," - contains the schema plugin system, ability to build a GraphQL schema from plugins, basic plugins for all GraphQL schemas, and of course the complex lookahead system. Nothing specific to databases at all."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"graphile-build-pg")," - a collection of plugins for ",(0,r.kt)("inlineCode",{parentName:"li"},"graphile-build")," that teach it about PostgreSQL databases, including introspecting the database and generating all the GraphQL types/fields/etc and their resolvers and look-ahead information"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pg-sql2")," - build SQL via template literals."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"graphile-utils")," - a collection of plugin generators to help you extend your ",(0,r.kt)("inlineCode",{parentName:"li"},"graphile-engine"),"-based schema")),(0,r.kt)("p",null,"In PostGraphile V5, we have split things up into more packages that each have a specific focus:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"postgraphile")," - much thinner now, acts as just the orchestration layer and CLI"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"graphile-config")," - system for managing presets and plugins"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"grafserv")," - our Gra",(0,r.kt)("em",{parentName:"li"},"fast")," optimized Node.js webserver interface layer - replaces the server/middleware that was previously in ",(0,r.kt)("inlineCode",{parentName:"li"},"postgraphile")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"grafast"),' - the runtime for our GraphQL schemas - performs planning and execution of GraphQL requests - replaces the "lookahead" system that was previously in ',(0,r.kt)("inlineCode",{parentName:"li"},"graphile-build"),"; not related to automatically building a GraphQL schema; completely generic - has no knowledge of databases"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@dataplan/pg"),' - "step classes" for Gra',(0,r.kt)("em",{parentName:"li"},"fast")," to use to communicate with PostgreSQL databases; not related to automatically building a GraphQL schema"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@dataplan/json"),' - "step classes" for Gra',(0,r.kt)("em",{parentName:"li"},"fast")," to use to parse/stringify JSON"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ruru")," - our Gra",(0,r.kt)("em",{parentName:"li"},"fast")," enhanced GraphiQL distribution that can either be served by ",(0,r.kt)("inlineCode",{parentName:"li"},"grafserv")," directly or used standalone on the CLI"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ruru-components")," - the underlying React components used in ",(0,r.kt)("inlineCode",{parentName:"li"},"ruru")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"graphile-build")," - ability to build a GraphQL schema from ",(0,r.kt)("inlineCode",{parentName:"li"},"graphile-config")," plugins via the ",(0,r.kt)("inlineCode",{parentName:"li"},"gather")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"schema")," phases, basic plugins for all GraphQL schemas"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"graphile-build-pg")," - a collection of plugins for ",(0,r.kt)("inlineCode",{parentName:"li"},"graphile-build")," that teach it about PostgreSQL databases, including introspecting the database and generating all the GraphQL types/fields/etc and their plans."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pg-introspection")," - a strongly typed PostgreSQL introspection library"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"pg-sql2")," - build SQL via template literals."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"graphile-export")," - ability to export an in-memory PostGraphile GraphQL schema to executable code that can be written to a file"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"graphile")," - swiss army knife CLI with utilities for dealing with everything else"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"graphile-utils")," - a collection of plugin generators to help you extend your ",(0,r.kt)("inlineCode",{parentName:"li"},"graphile-build"),"-based schema"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"eslint-plugin-graphile-export")," - ESLint plugin to help ensure your code is compatible with being exported via ",(0,r.kt)("inlineCode",{parentName:"li"},"graphile-export"))),(0,r.kt)("p",null,"One major advantage of this approach is that when you export your GraphQL schema as executable code, very few of these dependencies will be needed, making your runtime dependencies much smaller. Another advantage is that it increases the audience for a lot of these modules, for example ",(0,r.kt)("inlineCode",{parentName:"p"},"grafast")," contains a drop-in replacement for ",(0,r.kt)("inlineCode",{parentName:"p"},"graphql"),"'s ",(0,r.kt)("inlineCode",{parentName:"p"},"execute")," method and can result in much faster GraphQL schemas even without going anywhere near schema autogeneration. A larger audience means more eyes on the code and ultimately higher quality software for everyone."),(0,r.kt)(i.Z,{chart:'\ngraph TD;\n  postgraphile--\x3egrafserv;\n  grafserv--\x3eruru;\n  ruru--\x3eruru-components;\n  postgraphile--\x3egraphile-build;\n  postgraphile--\x3egraphile-config;\n  graphile-config--\x3eCONFIG["graphile.config.js"];\n  CONFIG--\x3eAMBER["postgraphile/presets/amber"];\n  AMBER--\x3egraphile-build;\n  AMBER--\x3egraphile-build-pg;\n  CONFIG--\x3egraphile-utils;\n  CONFIG--\x3edataplan__pg_adaptors_pg["@dataplan/pg/adaptors/pg"];\n  grafserv--\x3egrafast;\n  graphile-build--\x3egrafast;\n  graphile-build-pg--\x3egrafast;\n  dataplan__pg--\x3egrafast;\n  dataplan__json--\x3egrafast;\n  %% graphile;\n  %% graphile-export;\n  %% eslint-plugin-graphile-export;\n  graphile-build-pg--\x3edataplan__pg["@dataplan/pg"];\n  graphile-build-pg--\x3edataplan__json["@dataplan/json"];\n  graphile-build-pg--\x3epg-introspection;\n  graphile-build-pg--\x3epg-sql2;\n',mdxType:"Mermaid"}))}u.isMDXComponent=!0}}]);