"use strict";(self.webpackChunk_localrepo_postgraphile_website=self.webpackChunk_localrepo_postgraphile_website||[]).push([[4948],{30876:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>m});var i=t(2784);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},s=Object.keys(e);for(i=0;i<s.length;i++)t=s[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(i=0;i<s.length;i++)t=s[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p=i.createContext({}),l=function(e){var n=i.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=l(e.components);return i.createElement(p.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},h=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,s=e.originalType,p=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),c=l(t),h=a,m=c["".concat(p,".").concat(h)]||c[h]||d[h]||s;return t?i.createElement(m,o(o({ref:n},u),{},{components:t})):i.createElement(m,o({ref:n},u))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var s=t.length,o=new Array(s);o[0]=h;var r={};for(var p in n)hasOwnProperty.call(n,p)&&(r[p]=n[p]);r.originalType=e,r[c]="string"==typeof e?e:a,o[1]=r;for(var l=2;l<s;l++)o[l]=t[l];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}h.displayName="MDXCreateElement"},69062:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var i=t(7896),a=(t(2784),t(30876));const s={layout:"page",path:"/postgraphile/subscriptions/",title:"GraphQL Subscriptions"},o=void 0,r={unversionedId:"subscriptions",id:"version-4.x/subscriptions",title:"GraphQL Subscriptions",description:"Subscriptions notify you when an event occurs on the server side.",source:"@site/versioned_docs/version-4.x/subscriptions.md",sourceDirName:".",slug:"/subscriptions",permalink:"/postgraphile/current/subscriptions",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/postgraphile/website/versioned_docs/version-4.x/subscriptions.md",tags:[],version:"4.x",frontMatter:{layout:"page",path:"/postgraphile/subscriptions/",title:"GraphQL Subscriptions"},sidebar:"docs",previous:{title:"PostGraphile Realtime",permalink:"/postgraphile/current/realtime"},next:{title:"Live Queries",permalink:"/postgraphile/current/live-queries"}},p={},l=[{value:"Introduction",id:"introduction",level:3},{value:"Custom Subscriptions",id:"custom-subscriptions",level:3},{value:"Writing the plugin",id:"writing-the-plugin",level:4},{value:"Enabling with the CLI",id:"enabling-with-the-cli",level:4},{value:"Enabling with an Express app",id:"enabling-with-an-express-app",level:4},{value:"Testing your subscription with GraphiQL/GraphQL Playground",id:"testing-your-subscription-with-graphiqlgraphql-playground",level:4},{value:"Simple Subscriptions",id:"simple-subscriptions",level:3},{value:"Enabling with the CLI",id:"enabling-with-the-cli-1",level:4},{value:"Enabling with an Express app",id:"enabling-with-an-express-app-1",level:4},{value:"Using",id:"using",level:4},{value:"Topic prefix",id:"topic-prefix",level:4},{value:"Subscription security",id:"subscription-security",level:4},{value:"Naming your topics",id:"naming-your-topics",level:4},{value:"Example walk-through",id:"example-walk-through",level:4},{value:"Advanced setup",id:"advanced-setup",level:3}],u={toc:l},c="wrapper";function d(e){let{components:n,...t}=e;return(0,a.kt)(c,(0,i.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",{class:"intro"},"Subscriptions notify you when an event occurs on the server side."),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"This feature requires PostGraphile v4.4.0 or higher.")),(0,a.kt)("h3",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"Pass ",(0,a.kt)("inlineCode",{parentName:"p"},"--subscriptions")," (or ",(0,a.kt)("inlineCode",{parentName:"p"},"subscriptions: true"),") to PostGraphile and we'll\nenhance GraphiQL with subscription capabilities and give your PostGraphile\nserver the power of websocket communications. This will enable the websocket\nendpoint."),(0,a.kt)("p",null,"Although you can now use ",(0,a.kt)("inlineCode",{parentName:"p"},"makeExtendSchemaPlugin")," to add your own subscription\nfields using your own realtime events, it's likely that you'll want to add the\n",(0,a.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@graphile/pg-pubsub"},(0,a.kt)("inlineCode",{parentName:"a"},"@graphile/pg-pubsub")," realtime provider plugin"),"\nso that you can leverage PostgreSQL's built-in pubsub support. For example, this\nplugin will allow ",(0,a.kt)("inlineCode",{parentName:"p"},"makeExtendSchemaPlugin")," to use the ",(0,a.kt)("inlineCode",{parentName:"p"},"@pgSubscriptions"),"\ndirective to easily define your own subscriptions using PostgreSQL's\n",(0,a.kt)("inlineCode",{parentName:"p"},"LISTEN"),"/",(0,a.kt)("inlineCode",{parentName:"p"},"NOTIFY")," (recommended for production). This plugin also adds the\n",(0,a.kt)("inlineCode",{parentName:"p"},"--simple-subscriptions")," flag that can be used to add a simple listen\nsubscription field to your GraphQL API (useful for experimentation). See below\nhow to enable the plugin for each approach."),(0,a.kt)("p",null,"If you just use the ",(0,a.kt)("inlineCode",{parentName:"p"},"--subscriptions")," flag alone, you'll notice that your schema\nstill only has ",(0,a.kt)("inlineCode",{parentName:"p"},"query")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"mutation")," operation types. To add subscriptions to\nyour GraphQL schema you'll need a plugin to provide the relevant ",(0,a.kt)("inlineCode",{parentName:"p"},"subscription"),"\nfields (by extending the ",(0,a.kt)("inlineCode",{parentName:"p"},"Subscription")," type) - or you can write your own\n",(0,a.kt)("a",{parentName:"p",href:"./make-extend-schema-plugin/"},"with ",(0,a.kt)("inlineCode",{parentName:"a"},"makeExtendSchemaPlugin")),"."),(0,a.kt)("p",null,"The easiest way to get started is with Simple Subscriptions (see below) but we\nrecommend that you take the Custom Subscriptions approach as it allows you to be\nmuch more expressive about the realtime features of your GraphQL API."),(0,a.kt)("p",null,"NOTE: the endpoint for subscriptions is the same as for GraphQL, except the\nprotocol is changed from ",(0,a.kt)("inlineCode",{parentName:"p"},"http")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"https")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"ws")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"wss")," respectively."),(0,a.kt)("hr",null),(0,a.kt)("h3",{id:"custom-subscriptions"},"Custom Subscriptions"),(0,a.kt)("p",null,"In this implementation, you use PostGraphile's extensibility to define the exact\nsubscriptions you need."),(0,a.kt)("h4",{id:"writing-the-plugin"},"Writing the plugin"),(0,a.kt)("p",null,"Using ",(0,a.kt)("inlineCode",{parentName:"p"},"makeExtendSchemaPlugin")," we can define a new subscription field and the\nsubscription payload type that it returns. Using the\n",(0,a.kt)("inlineCode",{parentName:"p"},"@pgSubscription(topic: ...)")," directive provided by ",(0,a.kt)("inlineCode",{parentName:"p"},"@graphile/pg-pubsub")," we can\nembed a function that will calculate the PostgreSQL topic to subscribe to based\non the arguments and context passed to the GraphQL field (in this case factoring\nin the user ID)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'// MySubscriptionPlugin.js\nconst { makeExtendSchemaPlugin, gql, embed } = require("graphile-utils");\n// or: import { makeExtendSchemaPlugin, gql, embed } from \'graphile-utils\';\n\nconst currentUserTopicFromContext = async (_args, context, _resolveInfo) => {\n  if (context.jwtClaims.user_id) {\n    return `graphql:user:${context.jwtClaims.user_id}`;\n  } else {\n    throw new Error("You\'re not logged in");\n  }\n};\n\nmodule.exports = makeExtendSchemaPlugin(({ pgSql: sql }) => ({\n  typeDefs: gql`\n    type UserSubscriptionPayload {\n      # This is populated by our resolver below\n      user: User\n\n      # This is returned directly from the PostgreSQL subscription payload (JSON object)\n      event: String\n    }\n\n    extend type Subscription {\n      """\n      Triggered when the current user\'s data changes:\n\n      - direct modifications to the user\n      - when their organization membership changes\n      """\n      currentUserUpdated: UserSubscriptionPayload @pgSubscription(topic: ${embed(\n        currentUserTopicFromContext,\n      )})\n    }\n  `,\n\n  resolvers: {\n    UserSubscriptionPayload: {\n      // This method finds the user from the database based on the event\n      // published by PostgreSQL.\n      //\n      // In a future release, we hope to enable you to replace this entire\n      // method with a small schema directive above, should you so desire. It\'s\n      // mostly boilerplate.\n      async user(\n        event,\n        _args,\n        _context,\n        { graphile: { selectGraphQLResultFromTable } },\n      ) {\n        const rows = await selectGraphQLResultFromTable(\n          sql.fragment`app_public.users`,\n          (tableAlias, sqlBuilder) => {\n            sqlBuilder.where(\n              sql.fragment`${tableAlias}.id = ${sql.value(event.subject)}`,\n            );\n          },\n        );\n        return rows[0];\n      },\n    },\n  },\n}));\n')),(0,a.kt)("details",null,(0,a.kt)("summary",null,"I'm using a fairly complex PostgreSQL function so that I can just use `CREATE TRIGGER` to trigger events in future without having to define a function for each trigger. Click this paragraph to expand and see the function."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"create function app_public.graphql_subscription() returns trigger as $$\ndeclare\n  v_process_new bool = (TG_OP = 'INSERT' OR TG_OP = 'UPDATE');\n  v_process_old bool = (TG_OP = 'UPDATE' OR TG_OP = 'DELETE');\n  v_event text = TG_ARGV[0];\n  v_topic_template text = TG_ARGV[1];\n  v_attribute text = TG_ARGV[2];\n  v_record record;\n  v_sub text;\n  v_topic text;\n  v_i int = 0;\n  v_last_topic text;\nbegin\n  -- On UPDATE sometimes topic may be changed for NEW record,\n  -- so we need notify to both topics NEW and OLD.\n  for v_i in 0..1 loop\n    if (v_i = 0) and v_process_new is true then\n      v_record = new;\n    elsif (v_i = 1) and v_process_old is true then\n      v_record = old;\n    else\n      continue;\n    end if;\n     if v_attribute is not null then\n      execute 'select $1.' || quote_ident(v_attribute)\n        using v_record\n        into v_sub;\n    end if;\n    if v_sub is not null then\n      v_topic = replace(v_topic_template, '$1', v_sub);\n    else\n      v_topic = v_topic_template;\n    end if;\n    if v_topic is distinct from v_last_topic then\n      -- This if statement prevents us from triggering the same notification twice\n      v_last_topic = v_topic;\n      perform pg_notify(v_topic, json_build_object(\n        'event', v_event,\n        'subject', v_sub\n      )::text);\n    end if;\n  end loop;\n  return v_record;\nend;\n$$ language plpgsql volatile set search_path from current;\n"))),(0,a.kt)("p",null,"Hooking the database up to a GraphQL subscription is now just the case of\n",(0,a.kt)("inlineCode",{parentName:"p"},"CREATE TRIGGER"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TRIGGER _500_gql_update\n  AFTER UPDATE ON app_public.users\n  FOR EACH ROW\n  EXECUTE PROCEDURE app_public.graphql_subscription(\n    'userChanged', -- the \"event\" string, useful for the client to know what happened\n    'graphql:user:$1', -- the \"topic\" the event will be published to, as a template\n    'id' -- If specified, `$1` above will be replaced with NEW.id or OLD.id from the trigger.\n  );\n\nCREATE TRIGGER _500_gql_update_member\n  AFTER INSERT OR UPDATE OR DELETE ON app_public.organization_members\n  FOR EACH ROW\n  EXECUTE PROCEDURE app_public.graphql_subscription('organizationsChanged', 'graphql:user:$1', 'member_id');\n")),(0,a.kt)("h4",{id:"enabling-with-the-cli"},"Enabling with the CLI"),(0,a.kt)("p",null,"Load the ",(0,a.kt)("inlineCode",{parentName:"p"},"@graphile/pg-pubsub")," ",(0,a.kt)("em",{parentName:"p"},"server")," plugin (",(0,a.kt)("inlineCode",{parentName:"p"},"--plugins"),", or ",(0,a.kt)("inlineCode",{parentName:"p"},"pluginHook")," for\nthe library), our custom subscription ",(0,a.kt)("em",{parentName:"p"},"schema")," plugin (",(0,a.kt)("inlineCode",{parentName:"p"},"--append-plugins"),", or\n",(0,a.kt)("inlineCode",{parentName:"p"},"appendPlugins")," for the library), and enable PostGraphile server's websockets\nsupport with ",(0,a.kt)("inlineCode",{parentName:"p"},"--subscriptions")," (or ",(0,a.kt)("inlineCode",{parentName:"p"},"subscriptions: true")," for the library)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"postgraphile \\\n  --plugins @graphile/pg-pubsub \\\n  --append-plugins `pwd`/MySubscriptionPlugin.js \\\n  --subscriptions \\\n  -c mydb\n")),(0,a.kt)("h4",{id:"enabling-with-an-express-app"},"Enabling with an Express app"),(0,a.kt)("p",null,"When using PostGraphile as a library, you may enable Custom Subscriptions by\npassing the ",(0,a.kt)("inlineCode",{parentName:"p"},"pluginHook")," with the ",(0,a.kt)("inlineCode",{parentName:"p"},"@graphile/pg-pubsub")," plugin, setting\n",(0,a.kt)("inlineCode",{parentName:"p"},"subscriptions: true")," and adding your custom plugin."),(0,a.kt)("p",null,"We emulate part of the Express stack, so if you require sessions you can pass\nadditional Connect/Express middlewares (sorry, we don't support Koa middlewares\nhere at this time) via the ",(0,a.kt)("inlineCode",{parentName:"p"},"websocketMiddlewares")," option."),(0,a.kt)("p",null,"Here's an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const express = require("express");\nconst { postgraphile, makePluginHook } = require("postgraphile");\nconst MySubscriptionPlugin = require("./MySubscriptionPlugin"); // our plugin defined in previous step\nconst { default: PgPubsub } = require("@graphile/pg-pubsub"); // remember to install through yarn/npm\n\nconst pluginHook = makePluginHook([PgPubsub]);\n\nconst postgraphileOptions = {\n  pluginHook, // add the plugin hook. This will make the @pgSubscription avaiable in our schema definitions\n  subscriptions: true, // start the websocket server\n  appendPlugins: [MySubscriptionPlugin], // Load our plugin\n  websocketMiddlewares: [\n    // Add whatever middlewares you need here, note that they should only\n    // manipulate properties on req/res, they must not sent response data. e.g.:\n    //\n    //   require(\'express-session\')(),\n    //   require(\'passport\').initialize(),\n    //   require(\'passport\').session(),\n  ],\n};\n\nconst app = express();\napp.use(postgraphile(databaseUrl, "app_public", postgraphileOptions));\napp.listen(parseInt(process.env.PORT, 10) || 3000);\n')),(0,a.kt)("h4",{id:"testing-your-subscription-with-graphiqlgraphql-playground"},"Testing your subscription with GraphiQL/GraphQL Playground"),(0,a.kt)("p",null,"To test your subscription you will need to first subscribe and then trigger it."),(0,a.kt)("p",null,"To subscribe, in one GraphiQL tab execute"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},"subscription MySubscription {\n  currentUserUpdated {\n    user\n    event\n  }\n}\n")),(0,a.kt)("p",null,"You should get the answer: ",(0,a.kt)("inlineCode",{parentName:"p"},'"Waiting for subscription to yield data\u2026"')),(0,a.kt)("p",null,"To trigger the subscription, ",(0,a.kt)("em",{parentName:"p"},"in another GraphiQL tab")," run a mutation that\nchanges the user. This will depend on your implementation, for example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},'mutation MyMutation {\n  updateUserById(input: { userPatch: { name: "foo" }, id: 27 }) {\n    clientMutationId\n  }\n}\n')),(0,a.kt)("p",null,"In this tab you will get the regular mutation answer. Going back to the previous\ntab, you will see the subscription payload. You are good to go! This should\nserve as the basis to implement your own custom subscriptions."),(0,a.kt)("hr",null),(0,a.kt)("h3",{id:"simple-subscriptions"},"Simple Subscriptions"),(0,a.kt)("p",null,"In this implementation, we have ",(0,a.kt)("inlineCode",{parentName:"p"},"@graphile/pg-pubsub")," automatically expose a\ngeneric ",(0,a.kt)("inlineCode",{parentName:"p"},"listen")," handler that can be used with arbitrary topics in PostgreSQL \u2014\nit requires very little ahead-of-time planning."),(0,a.kt)("h4",{id:"enabling-with-the-cli-1"},"Enabling with the CLI"),(0,a.kt)("p",null,"To enable Simple Subscriptions via the CLI, just load the ",(0,a.kt)("inlineCode",{parentName:"p"},"@graphile/pg-pubsub"),"\nplugin and pass the ",(0,a.kt)("inlineCode",{parentName:"p"},"--subscriptions")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"--simple-subscriptions")," flags."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"postgraphile \\\n  --plugins @graphile/pg-pubsub \\\n  --subscriptions \\\n  --simple-subscriptions \\\n  -c mydb\n")),(0,a.kt)("h4",{id:"enabling-with-an-express-app-1"},"Enabling with an Express app"),(0,a.kt)("p",null,"When using PostGraphile as a library, you may enable Simple Subscriptions by\npassing the ",(0,a.kt)("inlineCode",{parentName:"p"},"pluginHook")," with the ",(0,a.kt)("inlineCode",{parentName:"p"},"@graphile/pg-pubsub")," plugin and using\n",(0,a.kt)("inlineCode",{parentName:"p"},"simpleSubscriptions: true"),"."),(0,a.kt)("p",null,"We emulate part of the Express stack, so if you require sessions you can pass\nadditional Connect/Express middlewares (sorry, we don't support Koa middlewares\nhere at this time) via the ",(0,a.kt)("inlineCode",{parentName:"p"},"websocketMiddlewares")," option."),(0,a.kt)("p",null,"Here's an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const express = require("express");\nconst { postgraphile, makePluginHook } = require("postgraphile");\nconst { default: PgPubsub } = require("@graphile/pg-pubsub");\n\nconst pluginHook = makePluginHook([PgPubsub]);\n\nconst postgraphileOptions = {\n  pluginHook,\n  subscriptions: true,\n  simpleSubscriptions: true,\n  websocketMiddlewares: [\n    // Add whatever middlewares you need here, note that they should only\n    // manipulate properties on req/res, they must not sent response data. e.g.:\n    //\n    //   require(\'express-session\')(),\n    //   require(\'passport\').initialize(),\n    //   require(\'passport\').session(),\n  ],\n};\n\nconst app = express();\napp.use(postgraphile(databaseUrl, "app_public", postgraphileOptions));\napp.listen(parseInt(process.env.PORT, 10) || 3000);\n')),(0,a.kt)("h4",{id:"using"},"Using"),(0,a.kt)("p",null,"Simple subscriptions exposes a ",(0,a.kt)("inlineCode",{parentName:"p"},"listen")," field to the ",(0,a.kt)("inlineCode",{parentName:"p"},"Subscription")," type that\ncan be used for generic subscriptions to a named topic. This topic can be\ntriggered using PostgreSQL's built in LISTEN/NOTIFY functionality (but remember\nto add the prefix - see below)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},"type ListenPayload {\n  query: Query\n  relatedNode: Node\n  relatedNodeId: ID\n}\n\ntype Subscription {\n  listen(topic: String!): ListenPayload!\n}\n")),(0,a.kt)("p",null,"PostGraphile's built in GraphiQL now supports subscriptions, so you can use it\ndirectly to test your application."),(0,a.kt)("h4",{id:"topic-prefix"},"Topic prefix"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Note"),": ",(0,a.kt)("em",{parentName:"p"},'this section only applies to "simple subscriptions."')),(0,a.kt)("p",null,"All topics requested from GraphQL are automatically prefixed with\n",(0,a.kt)("inlineCode",{parentName:"p"},"postgraphile:"),"*"," to avoid leaking other topics your application may be using"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"GraphQL consumers will not need to know about this, but you will need to\nremember to add it to the topic when you perform ",(0,a.kt)("inlineCode",{parentName:"li"},"NOTIFY")," otherwise\nsubscribers will not see the messages.")),(0,a.kt)("p",null,"*"," ",(0,a.kt)("em",{parentName:"p"},"This is applied by default, but you can override it via\n",(0,a.kt)("inlineCode",{parentName:"em"},"pgSubscriptionPrefix")," setting in the ",(0,a.kt)("inlineCode",{parentName:"em"},"graphileBuildOptions")," object; e.g.\n",(0,a.kt)("inlineCode",{parentName:"em"},'postgraphile(DATABASE_URL, SCHEMAS, {pluginHook, subscriptions: true, graphileBuildOptions: { pgSubscriptionPrefix: "MyPrefix:"}})'),".\nNote further that this setting only applies to simple subscriptions, custom\nsubscriptions have no automatic prefix.")),(0,a.kt)("p",null,"For example a user may perform the following subscription:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},'subscription {\n  listen(topic: "hello") {\n    relatedNodeId\n    relatedNode {\n      nodeId\n      ... on Foo {\n        id\n        title\n      }\n    }\n  }\n}\n')),(0,a.kt)("p",null,"To cause the subscription to receive a message, you could run the following in\nPostgreSQL:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"select pg_notify(\n  'postgraphile:hello',\n  '{}'\n);\n")),(0,a.kt)("p",null,"Resulting in this GraphQL payload:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "data": {\n    "listen": {\n      "relatedNodeId": null,\n      "relatedNode": null\n      }\n    }\n  }\n}\n')),(0,a.kt)("p",null,"Which is sufficient to know that the event ",(0,a.kt)("em",{parentName:"p"},"occurred"),". Chances are that you want\nto know more than this..."),(0,a.kt)("p",null,"It's also possible to send a ",(0,a.kt)("inlineCode",{parentName:"p"},"Node")," along with your GraphQL payload using the\n",(0,a.kt)("inlineCode",{parentName:"p"},"__node__")," field on the ",(0,a.kt)("inlineCode",{parentName:"p"},"pg_notify")," body (which is interpreted as JSON). The\n",(0,a.kt)("inlineCode",{parentName:"p"},"__node__")," field is similar to the ",(0,a.kt)("inlineCode",{parentName:"p"},"nodeId")," (or ",(0,a.kt)("inlineCode",{parentName:"p"},"id")," if you use ",(0,a.kt)("inlineCode",{parentName:"p"},"--classic-ids"),")\nfield in your GraphQL requests, except it's the raw JSON before it gets\nstringified and base64 encoded. (The reason for this is that Postgres' JSON\nfunctions leave some optional spaces in, so when they are base64 encoded the\nstrings do not match.)"),(0,a.kt)("p",null,"Assuming that you have a table of the form\n",(0,a.kt)("inlineCode",{parentName:"p"},"foos(id serial primary key, title text, ...)")," you can add the ",(0,a.kt)("inlineCode",{parentName:"p"},"__node__")," field\nas follows and the record with id=32 will be made available as the ",(0,a.kt)("inlineCode",{parentName:"p"},"relatedNode"),"\nin the GraphQL subscription payload:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"select pg_notify(\n  'postgraphile:hello',\n  json_build_object(\n    '__node__', json_build_array(\n      'foos', -- IMPORTANT: this is not always exactly the table name; base64\n              -- decode an existing nodeId to see what it should be.\n      32      -- The primary key (for multiple keys, list them all).\n    )\n  )::text\n);\n")),(0,a.kt)("p",null,"Resulting in this GraphQL payload:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "data": {\n    "listen": {\n      "relatedNodeId": "WyJmb29zIiwzMl0=",\n      "relatedNode": {\n        "nodeId": "WyJmb29zIiwzMl0=",\n        "id": 32,\n        "title": "Howdy!"\n      }\n    }\n  }\n}\n')),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"NOTE"),": This solution is still taking shape, so it's not yet certain how\nother fields on the NOTIFY message JSON will be exposed via GraphQL. You are\nadvised to treat the content of this message JSON as if it's visible to the\nuser, as at some point it may be.")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"NOTE"),': In PostgreSQL the channel is an "identifier" which by default is\nlimited to 63 characters. Subtracting the ',(0,a.kt)("inlineCode",{parentName:"p"},"postgraphile:")," prefix leaves 50\ncharacters for your topic name.")),(0,a.kt)("h4",{id:"subscription-security"},"Subscription security"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Note"),": ",(0,a.kt)("em",{parentName:"p"},'this section only applies to "simple subscriptions."')),(0,a.kt)("p",null,"By default, any user may subscribe to any topic, whether logged in or not, and\nthey will remain subscribed until they close the connection themselves. This can\ncause a number of security issues; so we give you a method to implement security\naround subscriptions."),(0,a.kt)("p",null,"By specifying ",(0,a.kt)("inlineCode",{parentName:"p"},"--subscription-authorization-function [fn]")," on the PostGraphile\nCLI (or using the ",(0,a.kt)("inlineCode",{parentName:"p"},"subscriptionAuthorizationFunction")," option) you can have\nPostGraphile call the function you specified to ensure that the user is allowed\nto subscribe to the relevant topic. The function must accept one text argument\n",(0,a.kt)("inlineCode",{parentName:"p"},"topic")," and must return a string or raise an exception (note: the ",(0,a.kt)("inlineCode",{parentName:"p"},"topic"),"\nargument WILL be sent including the ",(0,a.kt)("inlineCode",{parentName:"p"},"postgraphile:")," prefix)."),(0,a.kt)("p",null,"A typical implementation will look like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE FUNCTION\n  app_hidden.validate_subscription(topic text)\nRETURNS TEXT AS $$\nBEGIN\n  IF ... THEN\n    RETURN ...::text;\n  ELSE\n    RAISE EXCEPTION 'Subscription denied'\n      USING errcode = '.....';\n  END IF;\nEND;\n$$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;\n")),(0,a.kt)("p",null,"You must define this function with your custom security logic. To use this\nfunction you'd pass the CLI flag:\n",(0,a.kt)("inlineCode",{parentName:"p"},"--subscription-authorization-function app_private.validate_subscription")),(0,a.kt)("p",null,"The text value returned is used to tell the system when to cancel the\nsubscription - if you don't need this functionality then you may return a\n",(0,a.kt)("em",{parentName:"p"},"static")," unique value, e.g. generate a random UUID (manually) and then return\nthis same UUID over and over from your function, e.g.:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE FUNCTION app_hidden.validate_subscription(topic text)\nRETURNS TEXT AS $$\nBEGIN\n  IF ... THEN\n    RETURN '4A2D27CD-7E67-4585-9AD8-50AF17D98E0B'::text;\n  ELSE\n    RAISE EXCEPTION 'Subscription denied' USING errcode = '.....';\n  END IF;\nEND;\n$$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;\n")),(0,a.kt)("p",null,"When a message is published to the topic identified by the return value of this\nfunction (NOTE: this topic will NOT be prefixed with ",(0,a.kt)("inlineCode",{parentName:"p"},"postgraphile:")," because it\nshould be private), the associated subscription will automatically be\nterminated."),(0,a.kt)("h4",{id:"naming-your-topics"},"Naming your topics"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Note"),": ",(0,a.kt)("em",{parentName:"p"},'this section only applies to "simple subscriptions."')),(0,a.kt)("p",null,"You might want to make the topic a combination of things, for example the\nsubject type and identifier - e.g. 'channel:123'. If you do this then your\nfunction could determine which subject the user is attempting to subscribe to,\ncheck the user has access to that subject, and finally return a PostgreSQL topic\nthat will be published to in the event the user is kicked from the channel, e.g.\n",(0,a.kt)("inlineCode",{parentName:"p"},"'channel:123:kick:987'")," (assuming '987' is the id of the current user)."),(0,a.kt)("h4",{id:"example-walk-through"},"Example walk-through"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Note"),": ",(0,a.kt)("em",{parentName:"p"},'this section only applies to "simple subscriptions."')),(0,a.kt)("p",null,"First, set up a ",(0,a.kt)("inlineCode",{parentName:"p"},".postgraphilerc.js")," containing the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'module.exports = {\n  options: {\n    plugins: ["@graphile/pg-pubsub"],\n    connection: "postgres:///subs",\n    schema: ["app_public"],\n    simpleSubscriptions: true,\n  },\n};\n')),(0,a.kt)("p",null,"Next, in terminal 1, run:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"createdb subs || true\npostgraphile\n")),(0,a.kt)("p",null,"In terminal 2, connect to the subs DB using ",(0,a.kt)("inlineCode",{parentName:"p"},"psql subs")," and run the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"create schema if not exists app_public;\ncreate schema if not exists app_private;\n\ncreate table if not exists app_public.foo (\n id serial primary key,\n title text not null\n);\n\ncreate or replace function\n  app_private.validate_subscription(topic text)\n  returns text as\n$$\n select 'CANCEL_ALL_SUBSCRIPTIONS'::text;\n$$ language sql stable;\n")),(0,a.kt)("p",null,"Then using a GraphQL client that supports subscriptions, such as\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/graphcool/graphql-playground"},"GraphQL Playground"),", perform\nthe following subscription:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},'subscription {\n  listen(topic: "hello") {\n    relatedNodeId\n    relatedNode {\n      nodeId\n      ... on Foo {\n        id\n        title\n      }\n    }\n  }\n}\n')),(0,a.kt)("p",null,"You are not expecting an immediate result; first you have to trigger the event.\nTo do so, back in your ",(0,a.kt)("inlineCode",{parentName:"p"},"psql")," session in terminal 2, execute:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"insert into app_public.foo (title) values ('Howdy!') returning *;\nselect pg_notify(\n  'postgraphile:hello',\n  json_build_object(\n    '__node__', json_build_array(\n      'foos',\n      (select max(id) from app_public.foo)\n    )\n  )::text\n);\n")),(0,a.kt)("p",null,"You should find that the event has been received by the client and the 'Howdy!'\nnode has come through. You can run the above a few more times, or experiment a\nbit by changing the values if you like."),(0,a.kt)("p",null,"Finally to cancel the subscription, execute the following SQL:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"select pg_notify(\n  'CANCEL_ALL_SUBSCRIPTIONS',\n  json_build_object()::text\n);\n")),(0,a.kt)("p",null,"You should notice that your client is no longer subscribed."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Bonus"),": the SQL commands in this walk-through can be automated with this\nhandy bash script:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"#!/bin/bash\nset -e\ncreatedb subs || true\npsql -1X -v ON_ERROR_STOP=1 subs << HERE\ncreate schema if not exists app_public;\ncreate table if not exists app_public.foo (\n id serial primary key,\n title text not null\n);\ncreate schema if not exists app_private;\ncreate or replace function app_private.validate_subscription(topic text)\nreturns text as \\$\\$\n select 'CANCEL_ALL_SUBSCRIPTIONS'::text;\n\\$\\$ language sql stable;\nHERE\n\nsleep 1\n\npsql -1X -v ON_ERROR_STOP=1 subs << HERE\n do \\$\\$\n declare\n   v_foo app_public.foo;\n begin\n   insert into app_public.foo (title) values ('Howdy!') returning * into v_foo;\n   perform pg_notify(\n     'postgraphile:hello',\n     json_build_object('__node__', json_build_array('foos', v_foo.id))::text\n   );\n end;\n \\$\\$ language plpgsql;\nHERE\n\nsleep 3\n\npsql -1X -v ON_ERROR_STOP=1 subs << HERE\n do \\$\\$\n declare\n   v_foo app_public.foo;\n begin\n   insert into app_public.foo (title) values ('Goodbye!') returning * into v_foo;\n   perform pg_notify(\n     'postgraphile:hello',\n     json_build_object('__node__', json_build_array('foos', v_foo.id))::text\n   );\n   perform pg_notify(\n     'CANCEL_ALL_SUBSCRIPTIONS',\n     json_build_object()::text\n   );\n end;\n \\$\\$ language plpgsql;\nHERE\n")),(0,a.kt)("h3",{id:"advanced-setup"},"Advanced setup"),(0,a.kt)("p",null,"If you need websockets to be listened for before your first HTTP request comes\nin (most people don't need this) then you must create a ",(0,a.kt)("inlineCode",{parentName:"p"},"rawHTTPServer"),", mount\nyour express ",(0,a.kt)("inlineCode",{parentName:"p"},"app")," in it, and then add subscription support to the raw server\nvia the ",(0,a.kt)("inlineCode",{parentName:"p"},"enhanceHttpServerWithSubscriptions")," function, as shown below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const {\n  postgraphile,\n  makePluginHook,\n  enhanceHttpServerWithSubscriptions,\n} = require("postgraphile");\nconst { default: PgPubsub } = require("@graphile/pg-pubsub");\nconst { createServer } = require("http");\nconst express = require("express");\n\nconst pluginHook = makePluginHook([PgPubsub]);\n\nconst app = express();\nconst rawHTTPServer = createServer(app);\n\nconst postgraphileOptions = {\n  pluginHook,\n  simpleSubscriptions: true,\n  websocketMiddlewares: [\n    // Add whatever middlewares you need here, note that\n    // they should only manipulate properties on req/res,\n    // they must not sent response data. e.g.:\n    //\n    //   require(\'express-session\')(),\n    //   require(\'passport\').initialize(),\n    //   require(\'passport\').session(),\n  ],\n};\n\nconst postgraphileMiddleware = postgraphile(\n  databaseUrl,\n  "app_public",\n  postgraphileOptions,\n);\n\napp.use(postgraphileMiddleware);\n\nenhanceHttpServerWithSubscriptions(rawHTTPServer, postgraphileMiddleware);\n\nrawHTTPServer.listen(parseInt(process.env.PORT, 10) || 3000);\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"enhanceHttpServerWithSubscriptions")," takes two arguments:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"the raw HTTP server from ",(0,a.kt)("inlineCode",{parentName:"li"},"require('http').createServer()")),(0,a.kt)("li",{parentName:"ol"},"the postgraphile middleware (this should be the ",(0,a.kt)("em",{parentName:"li"},"same")," middleware that you\nmount into your Express app)")))}d.isMDXComponent=!0}}]);