"use strict";(self.webpackChunk_localrepo_postgraphile_website=self.webpackChunk_localrepo_postgraphile_website||[]).push([[9600],{30876:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>c});var a=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=p(n),m=r,c=u["".concat(s,".").concat(m)]||u[m]||h[m]||i;return n?a.createElement(c,o(o({ref:t},d),{},{components:n})):a.createElement(c,o({ref:t},d))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},80075:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(7896),r=(n(2784),n(30876));const i={layout:"page",path:"/postgraphile/extending-raw/",title:"Schema Plugins - Graphile Build"},o=void 0,l={unversionedId:"extending-raw",id:"extending-raw",title:"Schema Plugins - Graphile Build",description:"The PostGraphile GraphQL schema is constructed out of a number of Graphile",source:"@site/postgraphile/extending-raw.md",sourceDirName:".",slug:"/extending-raw",permalink:"/postgraphile/next/extending-raw",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/postgraphile/website/postgraphile/extending-raw.md",tags:[],version:"current",frontMatter:{layout:"page",path:"/postgraphile/extending-raw/",title:"Schema Plugins - Graphile Build"},sidebar:"docs",previous:{title:"makePgSmartTagsPlugin",permalink:"/postgraphile/next/make-pg-smart-tags-plugin"},next:{title:"PostGraphile Plugin Gallery",permalink:"/postgraphile/next/plugin-gallery"}},s={},p=[{value:"Adding root query/mutation fields",id:"adding-root-querymutation-fields",level:3},{value:"Removing things from the schema",id:"removing-things-from-the-schema",level:3}],d={toc:p},u="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The PostGraphile GraphQL schema is constructed out of a number of Graphile\nBuild plugins. The core PG-related plugins can be found here:"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/benjie/crystal/tree/main/graphile-build/graphile-build-pg/src/plugins"},"https://github.com/benjie/crystal/tree/main/graphile-build/graphile-build-pg/src/plugins")),(0,r.kt)("p",null,"These plugins introduce small amounts of functionality, and build upon each\nother. The default list of plugins can be found from the ",(0,r.kt)("inlineCode",{parentName:"p"},"defaultPlugins"),"\nexport in\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/benjie/crystal/blob/main/graphile-build/graphile-build-pg/src/preset.ts"},(0,r.kt)("inlineCode",{parentName:"a"},"src/preset.ts")),"\nof the ",(0,r.kt)("inlineCode",{parentName:"p"},"graphile-build-pg")," module."),(0,r.kt)("p",null,"You can extend PostGraphile's GraphQL schema by adding plugins or presets. You\nmay even opt to replace the entire list of plugins used to build the schema.\nGraphile Build plugins are built on top of the ",(0,r.kt)("a",{parentName:"p",href:"http://graphql.org/graphql-js/"},"GraphQL reference JS\nimplementation"),", so it is recommended that you\nhave familiarity with that before attempting to write your own plugins."),(0,r.kt)("h3",{id:"adding-root-querymutation-fields"},"Adding root query/mutation fields"),(0,r.kt)("p",null,"A common request is to add additional root-level fields to your schema, for\nexample to integrate external services. The easiest way to do this is to\n",(0,r.kt)("a",{parentName:"p",href:"./make-extend-schema-plugin/"},"use ",(0,r.kt)("inlineCode",{parentName:"a"},"makeExtendSchemaPlugin"))," to generate a\nplugin that will extend your schema (this can be used to add fields anywhere,\nnot just at the root-level):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="add-http-bin-plugin.js"',title:'"add-http-bin-plugin.js"'},'import { makeExtendSchemaPlugin, gql } from "postgraphile/utils";\nimport fetch from "node-fetch";\n\nexport default makeExtendSchemaPlugin({\n  typeDefs: gql`\n    extend type Query {\n      httpBinHeaders: JSON\n    }\n  `,\n  resolvers: {\n    Query: {\n      async httpBinHeaders() {\n        const response = await fetch("https://httpbin.org/headers");\n        return response.json();\n      },\n    },\n  },\n});\n')),(0,r.kt)("p",null,"If you need to do this using the low-level plugins API for some reason (for\nexample you're defining the fields in a more automated way) then you can use a\n'GraphQLObjectType_fields' hook and to add our new field:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="add-http-bin-plugin-raw.js"',title:'"add-http-bin-plugin-raw.js"'},'import fetch from "node-fetch";\n\nconst AddHttpBinPlugin = {\n  name: "AddHttpBinPlugin",\n  version: "0.0.0",\n\n  schema: {\n    hooks: {\n      GraphQLObjectType_fields(\n        fields, // Input object - the fields for this GraphQLObjectType\n        build, // Build object - handy utils\n        context, // Context object - used for filtering\n      ) {\n        const {\n          extend,\n          getTypeByName,\n          options: { jsonScalarAsString },\n        } = build;\n        const {\n          scope: { isRootQuery },\n        } = context;\n        if (!isRootQuery) {\n          // This isn\'t the object we want to modify:\n          // return the input object unmodified\n          return fields;\n        }\n\n        // We don\'t want to introduce a new JSON type as that will clash,\n        // so let\'s find the JSON type that other fields use:\n        const JSONType = getTypeByName("JSON");\n\n        return extend(fields, {\n          httpBinHeaders: {\n            type: JSONType,\n            async resolve() {\n              const response = await fetch("https://httpbin.org/headers");\n              if (jsonScalarAsString) {\n                // We\'ve been told to provide JSON scalars in stringified format\n                return response.text();\n              } else {\n                // By default, we can just return a dynamic "JSON" scalar\n                return response.json();\n              }\n            },\n          },\n        });\n      },\n    },\n  },\n};\n\nexport default AddHttpBinPlugin;\n')),(0,r.kt)("p",null,"(If you wanted to add a mutation you'd use ",(0,r.kt)("inlineCode",{parentName:"p"},"isRootMutation")," rather than\n",(0,r.kt)("inlineCode",{parentName:"p"},"isRootQuery"),".)"),(0,r.kt)("p",null,"We can then load our plugin into PostGraphile by adding it to our preset:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="graphile.config.mjs"',title:'"graphile.config.mjs"'},'import AddHttpBinPlugin from "./add-http-bin-plugin.js";\n\nexport default {\n  // ...\n  plugins: [AddHttpBinPlugin],\n};\n')),(0,r.kt)("p",null,"Note that the types of added fields can use standard GraphQL objects in\naddition to types generated via the Graphile Build system. (However, if you do\nnot build your object types via Graphile Build's ",(0,r.kt)("inlineCode",{parentName:"p"},"registerObjectType")," (or\nsimilar) then the objects referenced cannot be extended via plugins.)"),(0,r.kt)("h3",{id:"removing-things-from-the-schema"},"Removing things from the schema"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"If you're looking for an easy way to prevent certain tables, fields, functions\nor relations being added to your GraphQL schema, check out\n",(0,r.kt)("a",{parentName:"strong",href:"./smart-comments/"},"smart comments"),".")),(0,r.kt)("p",null,"If you want to prevent a class of things from being added to the schema then\nyou can disable the plugin that adds them; for example if you didn't want\nPostgres functions added you could disable ",(0,r.kt)("inlineCode",{parentName:"p"},"PgCustomTypeFieldPlugin"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="graphile.config.mjs"',title:'"graphile.config.mjs"'},'export default {\n  // ...\n  disabledPlugins: ["PgCustomTypeFieldPlugin"],\n};\n')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"For efficiency's sake, it's advised that rather than removing things from the\nschema, you instead avoid them being generated in the first place using the\ntips above.")),(0,r.kt)("p",null,"However, sometimes the above strategies don't allow you to make the changes you\ndesire. To remove something manually, you need to add a hook to the thing that\nowns the thing you wish to remove - for example if you want to remove a field\n",(0,r.kt)("inlineCode",{parentName:"p"},"bar")," from an object type ",(0,r.kt)("inlineCode",{parentName:"p"},"Foo")," you could hook ",(0,r.kt)("inlineCode",{parentName:"p"},"GraphQLObjectType_fields")," and\nreturn the set of fields less the one you want removed."),(0,r.kt)("p",null,"Here's an example of a plugin generator you could use to generate plugins to\nremove individual fields. This is just to demonstrate how a plugin to do this\nmight work, ",(0,r.kt)("a",{parentName:"p",href:"./smart-comments/"},"smart comments")," are likely a better approach."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'function makeRemoveFieldPlugin(\n  objectName: string,\n  fieldName: string,\n): GraphileConfig.Plugin {\n  return {\n    name: `RemoveField_${objectName}_${fieldName}_Plugin`,\n    description: `Removes the ${objectName}.${fieldName} field from the GraphQL schema`,\n    version: "0.0.0",\n\n    schema: {\n      hooks: {\n        GraphQLObjectType_fields(fields, build, context) {\n          if (context.Self.name !== objectName) return fields;\n          delete fields[fieldName];\n          return fields;\n        },\n      },\n    },\n  };\n}\n\nexport const RemoveFooDotBarPlugin = makeRemoveFieldPlugin("Foo", "bar");\n')))}h.isMDXComponent=!0}}]);