"use strict";(self.webpackChunk_localrepo_grafast_website=self.webpackChunk_localrepo_grafast_website||[]).push([[1933],{36702:(e,t,a)=>{a.d(t,{Z:()=>s});var n=a(48084),i=a(2784);n.o.initialize({startOnLoad:!0,flowchart:{diagramPadding:8,nodeSpacing:20,rankSpacing:40,htmlLabels:!0}});const s=e=>{let{chart:t}=e;return(0,i.useEffect)((()=>{n.o.contentLoaded()}),[]),i.createElement("div",{className:"mermaid"},t)}},99962:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var n=a(7896),i=(a(2784),a(30876)),s=a(36702);const r={toc_max_heading_level:4},o="loadMany",l={unversionedId:"step-library/standard-steps/loadMany",id:"step-library/standard-steps/loadMany",title:"loadMany",description:"Similar to DataLoader's load method, uses the given callback function to",source:"@site/grafast/step-library/standard-steps/loadMany.md",sourceDirName:"step-library/standard-steps",slug:"/step-library/standard-steps/loadMany",permalink:"/grafast/step-library/standard-steps/loadMany",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/grafast/website/grafast/step-library/standard-steps/loadMany.md",tags:[],version:"current",frontMatter:{toc_max_heading_level:4},sidebar:"tutorialSidebar",previous:{title:"listen",permalink:"/grafast/step-library/standard-steps/listen"},next:{title:"loadOne",permalink:"/grafast/step-library/standard-steps/loadOne"}},d={},p=[{value:"Enhancements over DataLoader",id:"enhancements-over-dataloader",level:2},{value:"Attribute and parameter tracking",id:"attribute-and-parameter-tracking",level:3},{value:"Input/output equivalence",id:"inputoutput-equivalence",level:3},{value:"Usage",id:"usage",level:2},{value:"Basic usage",id:"basic-usage",level:3},{value:"Advanced usage",id:"advanced-usage",level:3},{value:"Multiple steps",id:"multiple-steps",level:2}],u={toc:p},c="wrapper";function h(e){let{components:t,...a}=e;return(0,i.kt)(c,(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"loadmany"},"loadMany"),(0,i.kt)("p",null,"Similar to ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/graphql/dataloader"},"DataLoader"),"'s load method, uses the given callback function to\nread many results from your business logic layer. To load just one, see\n",(0,i.kt)("a",{parentName:"p",href:"/grafast/step-library/standard-steps/loadOne"},(0,i.kt)("inlineCode",{parentName:"a"},"loadOne")),"."),(0,i.kt)("h2",{id:"enhancements-over-dataloader"},"Enhancements over DataLoader"),(0,i.kt)("p",null,"Thanks to the planning system in Gra",(0,i.kt)("em",{parentName:"p"},"fast"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"loadOne")," can expose features that\nare not possible in DataLoader."),(0,i.kt)("h3",{id:"attribute-and-parameter-tracking"},"Attribute and parameter tracking"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"loadMany")," step (technically a ",(0,i.kt)("inlineCode",{parentName:"p"},"LoadStep"),") keeps track of the\nattribute names accessed on each of the records returned via\n",(0,i.kt)("inlineCode",{parentName:"p"},".get(attrName)")," and any parameters set via ",(0,i.kt)("inlineCode",{parentName:"p"},".setParam(key, value)"),". This\ninformation will be passed through to your callback function such that you may\nmake more optimal calls to your backend business logic, only retrieving the\ndata you need."),(0,i.kt)("h3",{id:"inputoutput-equivalence"},"Input/output equivalence"),(0,i.kt)("p",null,"If you (optionally) pass an ",(0,i.kt)("inlineCode",{parentName:"p"},"ioEquivalence")," parameter to ",(0,i.kt)("inlineCode",{parentName:"p"},"loadMany")," (the second\nparameter) then you can use it to indicate which field(s) on each record in the\noutput are equivalent to the input(s). This enables an optimization where a\nchained fetch can instead be performed in parallel if the child only depends on\nan output which is equivalent to an input. Hopefully an example will make this\nclearer..."),(0,i.kt)("p",null,"Imagine you're loading the users within a given organization:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-graphql"},"{\n  usersByOrganizationId(id: Int!) {\n    id\n    name\n    organization {\n      id\n      name\n    }\n  }\n}\n")),(0,i.kt)("p",null,"You might have plan resolvers such as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const plans = {\n  Query: {\n    usersByOrganizationId(_, { $id }) {\n      return loadMany($id, batchGetUsersByOrganizationId);\n    },\n  },\n  User: {\n    organization($user) {\n      const $orgId = $user.get("organization_id");\n      return loadOne($orgId, batchGetOrganizationById);\n    },\n  },\n};\n')),(0,i.kt)("p",null,"In it's current state the system doesn't know that the\n",(0,i.kt)("inlineCode",{parentName:"p"},'$user.get("organization_id")')," is equivalent to the ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," argument to our\n",(0,i.kt)("inlineCode",{parentName:"p"},"usersByOrganizationId")," field, so this would result in a chained fetch:"),(0,i.kt)(s.Z,{chart:'stateDiagram\n  direction LR\n  state "batchGetUsersByOrganizationId" as A\n  state "batchGetOrganizationById" as B\n  [*] --\x3e A\n  A --\x3e B\n',mdxType:"Mermaid"}),(0,i.kt)("p",null,"However, we can indicate that the output of the ",(0,i.kt)("inlineCode",{parentName:"p"},"loadMany")," step's records'\n",(0,i.kt)("inlineCode",{parentName:"p"},"organization_id")," property (",(0,i.kt)("inlineCode",{parentName:"p"},'$user.get("organization_id")'),") is equivalent to it's input\n(",(0,i.kt)("inlineCode",{parentName:"p"},"$id"),"):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff",metastring:"{4-5}","{4-5}":!0}," const plans = {\n   Query: {\n     usersByOrganizationId(_, { $id }) {\n-      return loadMany($id, batchGetUsersByOrganizationId);\n+      return loadMany($id, 'organization_id', batchGetUsersByOrganizationId);\n     },\n   },\n   User: {\n     organization($user) {\n       const $orgId = $user.get(\"organization_id\");\n       return loadOne($orgId, batchGetOrganizationById);\n     },\n   },\n };\n")),(0,i.kt)("p",null,"Now the access to ",(0,i.kt)("inlineCode",{parentName:"p"},'$user.get("organization_id")')," will be equivalent to the 'id'\nargument on the ",(0,i.kt)("inlineCode",{parentName:"p"},"usersByOrganizationId")," field - we no longer need to wait for\nthe users to load in order to fetch their organization:"),(0,i.kt)(s.Z,{chart:'stateDiagram\n  direction LR\n  state "batchGetUsersByOrganizationId" as A\n  state "batchGetOrganizationById" as B\n  [*] --\x3e A\n  [*] --\x3e B\n',mdxType:"Mermaid"}),(0,i.kt)("h2",{id:"usage"},"Usage"),(0,i.kt)("h3",{id:"basic-usage"},"Basic usage"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const $userId = $user.get("id");\nconst $friendships = loadMany($userId, getFriendshipsByUserIds);\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"loadMany")," accepts two to four arguments, the first is the step that specifies\nwhich records to load (the ",(0,i.kt)("em",{parentName:"p"},"specifier step"),"), and the last is the callback\nfunction called with these specs responsible for loading them."),(0,i.kt)("p",null,"The callback function is called with two arguments, the first is a list of the\nvalues from the ",(0,i.kt)("em",{parentName:"p"},"specifier step")," and the second is options that may affect the\nfetching of the records."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"For optimal results, we strongly recommend that the callback function is defined\nin a common location so that it can be reused over and over again, rather than\ndefined inline. This will allow LoadManyStep to optimise calls to this function.")),(0,i.kt)("p",null,"An example of the callback function might be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const friendshipsByUserIdCallback = (ids, { attributes }) => {\n  // Your business logic would be called here; e.g. this might be the same\n  // function that your DataLoaders would call, except we can pass additional\n  // information to it:\n  return getFriendshipsByUserIds(ids, { attributes });\n};\n")),(0,i.kt)("p",null,"Optionally a penultimate argument (2nd of 3 arguments, or 3rd of 4 arguments)\ncan indicate the input/output equivalence - this can be:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"null")," to indicate no input/output equivalence"),(0,i.kt)("li",{parentName:"ul"},"a string to indicate that the same named property on the output is equivalent\nto the entire input plan"),(0,i.kt)("li",{parentName:"ul"},"if the step is a ",(0,i.kt)("inlineCode",{parentName:"li"},"list()")," (or similar) plan, an array containing a list of\nkeys (or null for no relation) on the output that are equivalent to the same\nentry in the input"),(0,i.kt)("li",{parentName:"ul"},"if the step is a ",(0,i.kt)("inlineCode",{parentName:"li"},"object()")," (or similar) plan, an object that maps between\nthe attributes of the object and the key(s) in the output that are equivalent\nto the given entry on the input")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Example for a list step"',title:'"Example',for:!0,a:!0,list:!0,'step"':!0},'const $posts = loadMany(\n  list([$organizationId, $userId]),\n  ["organization_id", "user_id"],\n  batchGetMemberPostsByOrganizationIdAndUserId,\n);\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Example for an object step"',title:'"Example',for:!0,an:!0,object:!0,'step"':!0},'const $posts = loadMany(\n  list({ oid: $organizationId, uid: $userId }),\n  { oid: "organization_id", uid: "user_id" },\n  batchGetMemberPostsByOrganizationIdAndUserId,\n);\n')),(0,i.kt)("h3",{id:"advanced-usage"},"Advanced usage"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const $userId = $user.get("id");\nconst $dbClient = context().get("dbClient");\nconst $friendships = loadMany($userId, $dbClient, getFriendshipsByUserIds);\n')),(0,i.kt)("p",null,'In addition to the forms seen in "Basic usage" above, you can pass a second\nstep to ',(0,i.kt)("inlineCode",{parentName:"p"},"loadMany"),". This second step must be a ",(0,i.kt)("a",{parentName:"p",href:"/grafast/step-classes#addUnaryDependency"},(0,i.kt)("strong",{parentName:"a"},"unary\nstep")),", meaning that it must represent\nexactly one value across the entire request (not a batch of values like most\nsteps). Since we know it will have exactly one value, we can pass it into the\ncallback as a single value and our callback will be able to use it directly\nwithout having to perform any manual grouping."),(0,i.kt)("p",null,"This unary dependency is useful for fixed values (for example, those from\nGraphQL field arguments) and values on the GraphQL context such as clients to\nvarious APIs and other data sources."),(0,i.kt)("h2",{id:"multiple-steps"},"Multiple steps"),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"./list"},(0,i.kt)("inlineCode",{parentName:"a"},"list()"))," or ",(0,i.kt)("a",{parentName:"p",href:"./object"},(0,i.kt)("inlineCode",{parentName:"a"},"object()"))," step can be used if you need\nto pass the value of more than one step into your callback:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const $result = loadMany(list([$a, $b, $c]), callback);\n")),(0,i.kt)("p",null,"The first argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"callback")," will then be an array of all the tuples of\nvalues from these plans: ",(0,i.kt)("inlineCode",{parentName:"p"},"ReadonlyArray<[a: AValue, b: BValue, c: CValue]>"),"."))}h.isMDXComponent=!0}}]);