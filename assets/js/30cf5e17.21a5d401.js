"use strict";(self.webpackChunk_localrepo_grafast_website=self.webpackChunk_localrepo_grafast_website||[]).push([[1329],{30876:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var a=n(2784);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),c=s(n),d=i,h=c["".concat(p,".").concat(d)]||c[d]||u[d]||o;return n?a.createElement(h,r(r({ref:t},m),{},{components:n})):a.createElement(h,r({ref:t},m))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=d;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[c]="string"==typeof e?e:i,r[1]=l;for(var s=2;s<o;s++)r[s]=n[s];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},28368:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var a=n(7896),i=(n(2784),n(30876));const o={title:"Polymorphism"},r="Polymorphism in @dataplan/pg",l={unversionedId:"step-library/dataplan-pg/polymorphism",id:"step-library/dataplan-pg/polymorphism",title:"Polymorphism",description:"Polymorphism in PostgreSQL schemas can take many forms. @dataplan/pg has two",source:"@site/grafast/step-library/dataplan-pg/polymorphism.md",sourceDirName:"step-library/dataplan-pg",slug:"/step-library/dataplan-pg/polymorphism",permalink:"/grafast/step-library/dataplan-pg/polymorphism",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/grafast/website/grafast/step-library/dataplan-pg/polymorphism.md",tags:[],version:"current",frontMatter:{title:"Polymorphism"},sidebar:"tutorialSidebar",previous:{title:"pgUpdateSingle",permalink:"/grafast/step-library/dataplan-pg/pgUpdateSingle"},next:{title:"withPgClient and withPgClientTransaction",permalink:"/grafast/step-library/dataplan-pg/withPgClient"}},p={},s=[{value:"Types of polymorphism supported",id:"types-of-polymorphism-supported",level:2},{value:"Single table",id:"single-table",level:3},{value:"Relational table",id:"relational-table",level:3},{value:"Composite type union",id:"composite-type-union",level:3},{value:"Column-based union",id:"column-based-union",level:3},{value:"Completely separate tables",id:"completely-separate-tables",level:3}],m={toc:s},c="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(c,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"polymorphism-in-dataplanpg"},"Polymorphism in @dataplan/pg"),(0,i.kt)("p",null,"Polymorphism in PostgreSQL schemas can take many forms. ",(0,i.kt)("inlineCode",{parentName:"p"},"@dataplan/pg")," has two\nmain ways of dealing with this polymorphism: ",(0,i.kt)("inlineCode",{parentName:"p"},"pgSelect")," (which is polymorphic\ncapable so long as all the data either comes from a single table, or a single\ntable left-joined to additional tables), and ",(0,i.kt)("inlineCode",{parentName:"p"},"pgUnionAll")," (which allows you to\npull data from multiple different (independent) database tables via the SQL\n",(0,i.kt)("inlineCode",{parentName:"p"},"UNION ALL")," construct). These two step classes are similar in many ways, but\n",(0,i.kt)("inlineCode",{parentName:"p"},"pgUnionAll")," is much more limited in order to maintain performance even when\ndealing with complex setups."),(0,i.kt)("p",null,"Read on for examples of these."),(0,i.kt)("h2",{id:"types-of-polymorphism-supported"},"Types of polymorphism supported"),(0,i.kt)("p",null,"There are many ways of modelling polymorphism in the database, and they each\nhave various trade-offs. ",(0,i.kt)("inlineCode",{parentName:"p"},"@dataplan/pg")," currently supports the following\napproaches, but if you use a different method for modelling polymorphism in\nyour database please get in touch - maybe we can add support for that too!"),(0,i.kt)("h3",{id:"single-table"},"Single table"),(0,i.kt)("p",null,"In this form or polymorphism we have a single database table that contains a\n'type' column indicating the type of the row (it needn't be called 'type', and\nit can have any data type - we use enum below but that's not a requirement).\nThe table also contains all fields needed by all the different types in the\ninterface or union",(0,i.kt)("sup",{parentName:"p",id:"fnref-1"},(0,i.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),". For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"create type item_type as enum (\n  'TOPIC',\n  'POST',\n  'DIVIDER',\n  'CHECKLIST',\n  'CHECKLIST_ITEM'\n);\n\ncreate table items (\n  id serial primary key,\n  type item_type not null default 'POST'::item_type,\n\n  -- Shared attributes:\n  parent_id int references items on delete cascade,\n  author_id int not null references people on delete cascade,\n  position bigint not null default 0,\n  created_at timestamptz not null default now(),\n  updated_at timestamptz not null default now(),\n  is_explicitly_archived bool not null default false,\n  archived_at timestamptz,\n\n  -- Attributes that may be used by one or more item subtypes.\n  title text,\n  description text,\n  note text,\n  color text\n);\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"items")," table contains all the information that we need for our GraphQL\ntypes ",(0,i.kt)("inlineCode",{parentName:"p"},"Topic"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Post"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Divider"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Checklist")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ChecklistItem"),"."),(0,i.kt)("p",null,"This style of polymorphism can use ",(0,i.kt)("inlineCode",{parentName:"p"},"pgSelect")," in the same way as you would with\nregular row selection, however the codec on the source your ",(0,i.kt)("inlineCode",{parentName:"p"},"pgSelect")," uses\nmust have the ",(0,i.kt)("inlineCode",{parentName:"p"},"polymorphic")," configuration option set to ",(0,i.kt)("inlineCode",{parentName:"p"},'mode: "single"')," for it\nto work. Something like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'itemResource.codec.polymorphism = {\n  mode: "single",\n  typeAttributes: ["type"],\n  types: {\n    TOPIC: {\n      name: "Topic",\n    },\n    POST: {\n      name: "Post",\n    },\n    DIVIDER: {\n      name: "Divider",\n    },\n    CHECKLIST: {\n      name: "Checklist",\n    },\n    CHECKLIST_ITEM: {\n      name: "ChecklistItem",\n    },\n  },\n};\n')),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Alternatively, if you'd rather not change your source/codec..."),(0,i.kt)("p",null,"If you'd rather not change your source/codec then you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"pgSingleTablePolymorphic"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'// Map the SQL \'type\' values to their GraphQL equivalents\nconst sqlTypeToGraphQLType = (type) =>\n  ({\n    TOPIC: "Topic",\n    POST: "Post",\n    DIVIDER: "Divider",\n    CHECKLIST: "Checklist",\n    CHECKLIST_ITEM: "ChecklistItem",\n  })[type] ?? null;\n// Or: `const sqlTypeToGraphQLType = pascalCase;`\n\n/******/\n\nconst plans = {\n  Comment: {\n    item($comment) {\n      // Get the \'item\' related to this comment\n      const $item = $comment.singleRelation("item");\n\n      // Get the \'type\' column from the item\n      const $type = $item.get("type");\n\n      // Convert the \'type\' value into the name of a GraphQL type\n      const $typeName = lambda($type, sqlTypeToGraphQLType);\n\n      // Return the polymorphic step representing this item\n      return pgSingleTablePolymorphic($typeName, $item);\n    },\n  },\n};\n')),(0,i.kt)("details",null,(0,i.kt)("summary",null,(0,i.kt)("p",null,"It's also possible to use ",(0,i.kt)("inlineCode",{parentName:"p"},"pgPolymorphic")," to plan this style of polymorphism.")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"All ",(0,i.kt)("inlineCode",{parentName:"p"},"plan")," methods just return the ",(0,i.kt)("inlineCode",{parentName:"p"},"$item")," directly, since the ",(0,i.kt)("inlineCode",{parentName:"p"},"$item")," represents all possible types.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const itemsTypeMap = {\n  Topic: {\n    match: (t) => t === "TOPIC",\n    plan: (_, $item) => $item,\n  },\n  Post: {\n    match: (t) => t === "POST",\n    plan: (_, $item) => $item,\n  },\n  Divider: {\n    match: (t) => t === "DIVIDER",\n    plan: (_, $item) => $item,\n  },\n  Checklist: {\n    match: (t) => t === "CHECKLIST",\n    plan: (_, $item) => $item,\n  },\n  ChecklistItem: {\n    match: (t) => t === "CHECKLIST_ITEM",\n    plan: (_, $item) => $item,\n  },\n};\n\n/******/\n\nconst plans = {\n  Comment: {\n    item($comment) {\n      const $item = $comment.singleRelation("item");\n      const $type = $item.get("type");\n      return pgPolymorphic($item, $type, itemsTypeMap);\n    },\n  },\n};\n')))),(0,i.kt)("h3",{id:"relational-table"},"Relational table"),(0,i.kt)("p",null,"Similar to the single table example above, the relational table has a central\ntable with a 'type' column; however the per-type (not shared) fields live on\nseparate tables that can be joined in as necessary. These relational tables\nshare the same primary key as the central table, and the type on the central\ntable indicates which table should be joined to. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"create type item_type as enum (\n  'TOPIC',\n  'POST',\n  'DIVIDER',\n  'CHECKLIST',\n  'CHECKLIST_ITEM'\n);\n\n-- Central table\ncreate table items (\n  id serial primary key,\n  type item_type not null default 'POST'::item_type,\n\n  -- Shared attributes:\n  parent_id int references items on delete cascade,\n  author_id int not null references people on delete cascade,\n  position bigint not null default 0,\n  created_at timestamptz not null default now(),\n  updated_at timestamptz not null default now(),\n  is_explicitly_archived bool not null default false,\n  archived_at timestamptz\n);\n\n-- Tables for each of the subtypes\ncreate table topics (\n  id int primary key references items,\n  title text not null\n);\ncreate table posts (\n  id int primary key references items,\n  title text not null,\n  description text default '-- Enter description here --',\n  note text\n);\ncreate table dividers (\n  id int primary key references items,\n  title text,\n  color text\n);\ncreate table checklists (\n  id int primary key references items,\n  title text not null\n);\ncreate table checklist_items (\n  id int primary key references items,\n  description text not null,\n  note text\n);\n")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"When building the ",(0,i.kt)("inlineCode",{parentName:"p"},"PgResource")," for these tables, the subtables should have\nentries in ",(0,i.kt)("inlineCode",{parentName:"p"},"columns")," for all of the shared columns, with ",(0,i.kt)("inlineCode",{parentName:"p"},'via: "item"'),"\n(replacing ",(0,i.kt)("inlineCode",{parentName:"p"},'"item"')," with the name of the relation that needs to be traversed to\naccess the central table) to indicate that those columns come via the 'item'\nrelationship.")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"This pattern can be used to represent unions too, in this case the central\ntable would probably only have the primary key and type field. However, if\nyou're using this pattern to represent unions then this may indicate an issue\nin your GraphQL data-modelling and that what you actually want is an interface.")),(0,i.kt)("p",null,"This style of polymorphism can use ",(0,i.kt)("inlineCode",{parentName:"p"},"pgSelect")," in the same way as you would with\nregular row selection, however the codec on the source your ",(0,i.kt)("inlineCode",{parentName:"p"},"pgSelect")," uses\nmust have the ",(0,i.kt)("inlineCode",{parentName:"p"},"polymorphic")," configuration option set to ",(0,i.kt)("inlineCode",{parentName:"p"},'mode: "relational"'),"\nfor it to work. Something like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'itemResource.codec.polymorphic = {\n  mode: "relational",\n  typeAttributes: ["type"],\n  types: {\n    TOPIC: {\n      name: "Topic",\n      relationName: "topic",\n    },\n    POST: {\n      name: "Post",\n      relationName: "post",\n    },\n    DIVIDER: {\n      name: "Divider",\n      relationName: "divider",\n    },\n    CHECKLIST: {\n      name: "Checklist",\n      relationName: "checklist",\n    },\n    CHECKLIST_ITEM: {\n      name: "ChecklistItem",\n      relationName: "checklistItem",\n    },\n  },\n};\n')),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"relationName")," in the above configuration is the name of the relation that\nyour central source has which links to the relevant table that contains\nadditional data for this type.")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Alternatively, if you don't want to change your codec..."),(0,i.kt)("p",null,"This style of polymorphism could be planned via ",(0,i.kt)("inlineCode",{parentName:"p"},"pgPolymorphic")," (note the\n",(0,i.kt)("inlineCode",{parentName:"p"},"plan")," method returns a step representing a row from the relevant underlying\ntable):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const itemsTypeMap = {\n  Topic: {\n    match: (t) => t === "TOPIC",\n    plan: (_, $item) => $item.singleRelation("topic"),\n  },\n  Post: {\n    match: (t) => t === "POST",\n    plan: (_, $item) => $item.singleRelation("post"),\n  },\n  Divider: {\n    match: (t) => t === "DIVIDER",\n    plan: (_, $item) => $item.singleRelation("divider"),\n  },\n  Checklist: {\n    match: (t) => t === "CHECKLIST",\n    plan: (_, $item) => $item.singleRelation("checklist"),\n  },\n  ChecklistItem: {\n    match: (t) => t === "CHECKLIST_ITEM",\n    plan: (_, $item) => $item.singleRelation("checklistItem"),\n  },\n};\n\nconst plans = {\n  Comment: {\n    item($comment) {\n      const $item = $comment.singleRelation("item");\n      const $type = $item.get("type");\n      return pgPolymorphic($item, $type, itemsTypeMap);\n    },\n  },\n};\n'))),(0,i.kt)("h3",{id:"composite-type-union"},"Composite type union"),(0,i.kt)("p",null,"One way to indicate a union would be to use a composite type with an attribute\nfor each possible type referencing the primary key of the given type; exactly\none attribute should be non-null at a time. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"create table people (...);\ncreate table posts (...);\ncreate table comments (...);\n\ncreate type entity as (\n  person_id int,\n  post_id int,\n  comment_id int\n);\n")),(0,i.kt)("p",null,"This type could then be used as the return result for functions or as the type\nfor a column to indicate a polymorphic relationship."),(0,i.kt)("p",null,"This type style of polymorphism could be planned via ",(0,i.kt)("inlineCode",{parentName:"p"},"pgPolymorphic")," (note\nwe've modelled the specifier as a tuple):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const entityTypeMap = {\n  Person: {\n    match: (specifier) => specifier[0] != null,\n    plan: ($specifier) => personResource.get({ person_id: $specifier.at(0) }),\n  },\n  Post: {\n    match: (specifier) => specifier[1] != null,\n    plan: ($specifier) => postResource.get({ post_id: $specifier.at(1) }),\n  },\n  Comment: {\n    match: (specifier) => specifier[2] != null,\n    plan: ($specifier) => commentResource.get({ comment_id: $specifier.at(2) }),\n  },\n};\n\nconst plans = {\n  PersonBookmark: {\n    bookmarkedEntity($bookmark) {\n      const $item = $bookmark.get("bookmarked_entity");\n      const $specifier = list([\n        $item.get("person_id"),\n        $item.get("post_id"),\n        $item.get("comment_id"),\n      ]);\n      return pgPolymorphic($item, $specifier, entityTypeMap);\n    },\n  },\n};\n')),(0,i.kt)("h3",{id:"column-based-union"},"Column-based union"),(0,i.kt)("p",null,"Another way to indicate a union relationship would be to add a set of columns\nto a table to point to all the possible entities in the union, and add a rule\nthat exactly one of them must be set."),(0,i.kt)("p",null,"Consider the following GraphQL schema, where a person may have a number\nof favourite entities of various types:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-graphql"},"union PersonFavouriteEntity = Person | Post | Comment\ntype PersonFavourite {\n  id: ID!\n  person: Person!\n  entity: PersonFavouriteEntity!\n}\ntype Person {\n  # ...\n  favourites: [PersonFavourite!]!\n}\ntype Query {\n  person: Person\n}\n")),(0,i.kt)("p",null,"This schema might have the following underlying database table:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"create table person_favourites (\n  id serial primary key,\n  person_id int not null references people on delete cascade,\n  liked_person_id int references people on delete cascade,\n  liked_post_id int references posts on delete cascade,\n  liked_comment_id int references comments on delete cascade\n);\n")),(0,i.kt)("p",null,"Here we might set the rule that exactly one of ",(0,i.kt)("inlineCode",{parentName:"p"},"liked_person_id"),",\n",(0,i.kt)("inlineCode",{parentName:"p"},"liked_post_id")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"liked_comment_id")," must be non-null at a time, and the one\nwhich is non-null would indicate which concrete type the\n",(0,i.kt)("inlineCode",{parentName:"p"},"PersonFavouriteEntity")," represents."),(0,i.kt)("p",null,"We can plan this using a ",(0,i.kt)("inlineCode",{parentName:"p"},"pgUnionAll"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const plans = {\n  Person: {\n    favourites($person) {\n      const $favourites = personFavouritesResource.find({\n        person_id: $person.get("id"),\n      });\n      return each($favourites, ($favourite) => {\n        const $list = pgUnionAll({\n          attributes: {},\n          resourceByTypeName: {\n            Person: personResource,\n            Post: postResource,\n            Comment: pommentResource,\n          },\n          members: [\n            {\n              typeName: "Person",\n              resource: personResource,\n              match: {\n                id: $favourite.get("liked_person_id"),\n              },\n            },\n            {\n              typeName: "Post",\n              resource: postResource,\n              match: {\n                id: $favourite.get("liked_post_id"),\n              },\n            },\n            {\n              typeName: "Comment",\n              resource: commentResource,\n              match: {\n                id: $favourite.get("liked_comment_id"),\n              },\n            },\n          ],\n        });\n        return $list.single();\n      });\n    },\n  },\n};\n')),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Alternatively, you could use ",(0,i.kt)("tt",null,"pgPolymorphic"),":"),(0,i.kt)("p",null,"Planning for this could be very similar to the composite type union above:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const personFavouriteEntityTypeMap = {\n  Person: {\n    match: (specifier) => specifier[0] != null,\n    plan: ($specifier) => personResource.get({ person_id: $specifier.at(0) }),\n  },\n  Post: {\n    match: (specifier) => specifier[1] != null,\n    plan: ($specifier) => postResource.get({ post_id: $specifier.at(1) }),\n  },\n  Comment: {\n    match: (specifier) => specifier[2] != null,\n    plan: ($specifier) => commentResource.get({ comment_id: $specifier.at(2) }),\n  },\n};\n\nconst plans = {\n  Person: {\n    favourites($person) {\n      const $favourites = personFavouritesResource.find({\n        person_id: $person.get("id"),\n      });\n      return each($favourites, ($favourite) => {\n        const $specifier = list([\n          $favourite.get("liked_person_id"),\n          $favourite.get("liked_post_id"),\n          $favourite.get("liked_comment_id"),\n        ]);\n        return pgPolymorphic(\n          $favourite,\n          $specifier,\n          personFavouriteEntityTypeMap,\n        );\n      });\n    },\n  },\n};\n'))),(0,i.kt)("h3",{id:"completely-separate-tables"},"Completely separate tables"),(0,i.kt)("p",null,"If you have two completely different tables (let's say ",(0,i.kt)("inlineCode",{parentName:"p"},"users")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"organizations"),") and you want them to partake in a GraphQL interface or union,\nyou could use ",(0,i.kt)("a",{parentName:"p",href:"/grafast/step-library/dataplan-pg/pgUnionAll"},"pgUnionAll")," to plan them."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const plans = {\n  Query: {\n    allPeopleAndOrganizations() {\n      const $list = pgUnionAll({\n        resourceByTypeName: {\n          Person: personResource,\n          Organization: organizationResource,\n        },\n      });\n      return $list;\n    },\n  },\n};\n")),(0,i.kt)("div",{className:"footnotes"},(0,i.kt)("hr",{parentName:"div"}),(0,i.kt)("ol",{parentName:"div"},(0,i.kt)("li",{parentName:"ol",id:"fn-1"},"Modelling a union in this way might indicate an issue with your GraphQL\ndesign - perhaps you should be using an interface instead?",(0,i.kt)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"↩")))))}u.isMDXComponent=!0}}]);