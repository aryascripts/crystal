"use strict";(self.webpackChunk_localrepo_postgraphile_website=self.webpackChunk_localrepo_postgraphile_website||[]).push([[3559],{30876:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>g});var i=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},s=Object.keys(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=i.createContext({}),l=function(e){var t=i.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=l(e.components);return i.createElement(p.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,p=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=l(n),m=r,g=c["".concat(p,".").concat(m)]||c[m]||d[m]||s;return n?i.createElement(g,a(a({ref:t},u),{},{components:n})):i.createElement(g,a({ref:t},u))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,a=new Array(s);a[0]=m;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o[c]="string"==typeof e?e:r,a[1]=o;for(var l=2;l<s;l++)a[l]=n[l];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},37105:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var i=n(7896),r=(n(2784),n(30876));const s={layout:"page",path:"/postgraphile/subscriptions/",title:"GraphQL Subscriptions"},a=void 0,o={unversionedId:"subscriptions",id:"subscriptions",title:"GraphQL Subscriptions",description:"Subscriptions notify you when an event occurs on the server side. PostGraphile",source:"@site/postgraphile/subscriptions.md",sourceDirName:".",slug:"/subscriptions",permalink:"/postgraphile/next/subscriptions",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/postgraphile/website/postgraphile/subscriptions.md",tags:[],version:"current",frontMatter:{layout:"page",path:"/postgraphile/subscriptions/",title:"GraphQL Subscriptions"},sidebar:"docs",previous:{title:"PostGraphile Realtime",permalink:"/postgraphile/next/realtime"},next:{title:"Background Tasks in PostGraphile",permalink:"/postgraphile/next/background-tasks"}},p={},l=[{value:"Websockets",id:"websockets",level:2},{value:"Adding subscription fields",id:"adding-subscription-fields",level:2},{value:"subscribePlan() and plan()",id:"subscribeplan-and-plan",level:3},{value:"pgSubscriber",id:"pgsubscriber",level:3},{value:"Subscription topic",id:"subscription-topic",level:3},{value:"Example",id:"example",level:3},{value:"Triggering subscriptions manually",id:"triggering-subscriptions-manually",level:2},{value:"Triggering subscriptions automatically",id:"triggering-subscriptions-automatically",level:2},{value:"Testing your subscription with Ruru",id:"testing-your-subscription-with-ruru",level:2}],u={toc:l},c="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Subscriptions notify you when an event occurs on the server side. PostGraphile\nsupports subscriptions out of the box (assuming you are using it with a\nsupported webserver), but you are responsible for adding subscription fields to\nyour schema - without any subscription fields, the ",(0,r.kt)("inlineCode",{parentName:"p"},"subscription")," operation is\nnot possible."),(0,r.kt)("h2",{id:"websockets"},"Websockets"),(0,r.kt)("p",null,"The most common transport for GraphQL subscriptions is via Websockets. To\nenable or disable websocket support in your API, use the\n",(0,r.kt)("inlineCode",{parentName:"p"},"preset.grafserv.websockets")," option:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="graphile.config.mjs"',title:'"graphile.config.mjs"'},"export default {\n  //...\n  grafserv: {\n    websockets: true,\n  },\n};\n")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The endpoint for subscriptions is the same as for GraphQL, except the protocol\nis changed from ",(0,r.kt)("inlineCode",{parentName:"p"},"http")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"https")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"ws")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"wss")," respectively.")),(0,r.kt)("h2",{id:"adding-subscription-fields"},"Adding subscription fields"),(0,r.kt)("p",null,"The easiest way to add subscription fields is by using\n",(0,r.kt)("a",{parentName:"p",href:"./make-extend-schema-plugin"},(0,r.kt)("inlineCode",{parentName:"a"},"makeExtendSchemaPlugin"))," to extend the\n",(0,r.kt)("inlineCode",{parentName:"p"},"Subscription")," type and add your field. Your subscription fields will typically\nleverage the Gra",(0,r.kt)("em",{parentName:"p"},"fast"),"\n",(0,r.kt)("a",{parentName:"p",href:"https://grafast.org/grafast/step-library/standard-steps/listen"},(0,r.kt)("inlineCode",{parentName:"a"},"listen()")),"\nstep to subscribe to events on a pubsub-capable entity."),(0,r.kt)("h3",{id:"subscribeplan-and-plan"},"subscribePlan() and plan()"),(0,r.kt)("p",null,"Unlike the rest of your schema where you typically use the ",(0,r.kt)("inlineCode",{parentName:"p"},"plan()")," plan\nresolver, for subscriptions we need two plan resolvers: ",(0,r.kt)("inlineCode",{parentName:"p"},"subscribePlan()")," which\nwill return a streamable step (essentially wrapping an async iterable), and\n",(0,r.kt)("inlineCode",{parentName:"p"},"plan()")," which will take the payload of each of the events from this stream and\nconvert them into something that the subscription result type can use."),(0,r.kt)("h3",{id:"pgsubscriber"},"pgSubscriber"),(0,r.kt)("p",null,"By default (if your PostgreSQL adaptor supports it), PostGraphile will add a\n",(0,r.kt)("inlineCode",{parentName:"p"},"pgSubscriber")," entry to your GraphQL context. This object is pubsub-capable and\nuses Postgres' ",(0,r.kt)("inlineCode",{parentName:"p"},"LISTEN"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"NOTIFY")," functionality, which is probably the easiest\nway to get started. You can build a step that represents it in your\n",(0,r.kt)("inlineCode",{parentName:"p"},"subscribePlan()")," resolver via:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const $pgSubscriber = context().get("pgSubscriber");\n')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"You can use any pubsub-capable provider with PostGraphile or Gra",(0,r.kt)("em",{parentName:"p"},"fast"),": redis,\nMQTT, EventEmitter, etc; all you need is an abstraction that conforms to the\nexpected interface. See the ",(0,r.kt)("a",{parentName:"p",href:"https://grafast.org/grafast/step-library/standard-steps/listen"},(0,r.kt)("inlineCode",{parentName:"a"},"listen()"),"\ndocumentation"),"\nfor specifics.")),(0,r.kt)("h3",{id:"subscription-topic"},"Subscription topic"),(0,r.kt)("p",null,"You will also need a topic to listen on. PostgreSQL topics are limited to 63\ncharacters. This topic can be anything you like within PostgreSQL's\nconstraints, but it's typically useful to include the primary key of the entity\nyou're subscribing to in it. In the example below we'll use\n",(0,r.kt)("inlineCode",{parentName:"p"},"forum:FORUM_ID:message")," as the topic for when a new message is posted to a\nforum, substituting ",(0,r.kt)("inlineCode",{parentName:"p"},"FORUM_ID")," for the id of the forum that we're interested in\n(whether this is an int or a UUID it shouldn't go over the 63 character limit)."),(0,r.kt)("h3",{id:"example"},"Example"),(0,r.kt)("p",null,"The following is an example pulling it all together. In this example when a new\nmessage is created an event will be sent to ",(0,r.kt)("inlineCode",{parentName:"p"},"forum:FORUM_ID:message")," containing\nthe payload ",(0,r.kt)("inlineCode",{parentName:"p"},'{"event": "create", "sub": FORUM_ID, "id": MESSAGE_ID}'),". This event will be picked up\nby the ",(0,r.kt)("inlineCode",{parentName:"p"},"pgSubscriber"),", which ",(0,r.kt)("inlineCode",{parentName:"p"},"listen()")," subscribes to. This event will then be\nparsed by ",(0,r.kt)("inlineCode",{parentName:"p"},"listen()")," using the ",(0,r.kt)("inlineCode",{parentName:"p"},"jsonParse")," method, and the resulting object\nwill be passed to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Subscription.forumMessage.plan()")," plan resolver, which\ndoes no further processing. The data then flows down to the\n",(0,r.kt)("inlineCode",{parentName:"p"},"ForumMessageSubscriptionPayload")," field steps, which will extract the details\nthat they care about and use them to provide the relevant data to the user."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { makeExtendSchemaPlugin } from "postgraphile/utils";\nimport { context, lambda, listen } from "postgraphile/grafast";\nimport { jsonParse } from "postgraphile/@dataplan/json";\n\nconst MySubscriptionPlugin = makeExtendSchemaPlugin((build) => {\n  const { messages } = build.input.pgRegistry.pgResources;\n  return {\n    typeDefs: /* GraphQL */ `\n      extend type Subscription {\n        forumMessage(forumId: Int!): ForumMessageSubscriptionPayload\n      }\n\n      type ForumMessageSubscriptionPayload {\n        event: String\n        message: Message\n      }\n    `,\n    plans: {\n      Subscription: {\n        forumMessage: {\n          subscribePlan(_$root, args) {\n            const $pgSubscriber = context().get("pgSubscriber");\n            const $forumId = args.get("forumId");\n            const $topic = lambda($forumId, (id) => `forum:${id}:message`);\n            return listen($pgSubscriber, $topic, jsonParse);\n          },\n          plan($event) {\n            return $event;\n          },\n        },\n      },\n      ForumMessageSubscriptionPayload: {\n        event($event) {\n          return $event.get("event");\n        },\n        message($event) {\n          const $id = $event.get("id");\n          return messages.get({ id: $id });\n        },\n      },\n    },\n  };\n});\n')),(0,r.kt)("h2",{id:"triggering-subscriptions-manually"},"Triggering subscriptions manually"),(0,r.kt)("p",null,"You can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"NOTIFY")," keyword or ",(0,r.kt)("inlineCode",{parentName:"p"},"pg_notify")," function in PostgreSQL to\ntrigger an event. For example, you might simulate an event for creating message\n",(0,r.kt)("inlineCode",{parentName:"p"},"27")," within forum ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'NOTIFY "forum:1:message", \'{"event": "create", "sub": 1, "id": 27}\';\n')),(0,r.kt)("h2",{id:"triggering-subscriptions-automatically"},"Triggering subscriptions automatically"),(0,r.kt)("details",null,(0,r.kt)("summary",null,"I'm using a fairly complex PostgreSQL function so that I can just use `CREATE TRIGGER` to trigger events in future without having to define a function for each trigger. Click this paragraph to expand and see the function."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"IMPORTANT"),": this trigger assumes that the primary key for your tables is\nalways ",(0,r.kt)("inlineCode",{parentName:"p"},"id"),". If this is not the case, you should delete the line containing\n",(0,r.kt)("inlineCode",{parentName:"p"},"'id', v_record.id"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE FUNCTION tg__graphql_subscription() RETURNS trigger\n    LANGUAGE plpgsql\n    AS $_$\ndeclare\n  v_process_new bool = (TG_OP = 'INSERT' OR TG_OP = 'UPDATE');\n  v_process_old bool = (TG_OP = 'UPDATE' OR TG_OP = 'DELETE');\n  v_event text = TG_ARGV[0];\n  v_topic_template text = TG_ARGV[1];\n  v_attribute text = TG_ARGV[2];\n  v_record record;\n  v_sub text;\n  v_topic text;\n  v_i int = 0;\n  v_last_topic text;\nbegin\n  for v_i in 0..1 loop\n    if (v_i = 0) and v_process_new is true then\n      v_record = new;\n    elsif (v_i = 1) and v_process_old is true then\n      v_record = old;\n    else\n      continue;\n    end if;\n     if v_attribute is not null then\n      execute 'select $1.' || quote_ident(v_attribute)\n        using v_record\n        into v_sub;\n    end if;\n    if v_sub is not null then\n      v_topic = replace(v_topic_template, '$1', v_sub);\n    else\n      v_topic = v_topic_template;\n    end if;\n    if v_topic is distinct from v_last_topic then\n      -- This if statement prevents us from triggering the same notification twice\n      v_last_topic = v_topic;\n      perform pg_notify(v_topic, json_build_object(\n        'event', v_event,\n        'subject', v_sub,\n        /* highlight-next-line */\n        'id', v_record.id\n      )::text);\n    end if;\n  end loop;\n  return v_record;\nend;\n$_$;\n"))),(0,r.kt)("p",null,"Hooking the database up to a GraphQL subscription can be achieved via ",(0,r.kt)("inlineCode",{parentName:"p"},"CREATE\nTRIGGER"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TRIGGER _500_gql_insert\n  AFTER INSERT ON messages\n  FOR EACH ROW\n  EXECUTE FUNCTION tg__graphql_subscription(\n    'create', -- the \"event\" string, useful for the client to know what happened\n    'forum:$1:message', -- the \"topic\" the event will be published to, as a template\n    'forum_id' -- If specified, `$1` above will be replaced with NEW.forum_id or OLD.forum_id from the trigger.\n  );\n")),(0,r.kt)("h2",{id:"testing-your-subscription-with-ruru"},"Testing your subscription with Ruru"),(0,r.kt)("p",null,"To test your subscription you will need to first subscribe and then trigger it."),(0,r.kt)("p",null,"To subscribe, in one Ruru tab execute"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"subscription MySubscription {\n  forumMessage(forumId: 1) {\n    user\n    event\n  }\n}\n")),(0,r.kt)("p",null,"You should get the answer: ",(0,r.kt)("inlineCode",{parentName:"p"},'"Waiting for subscription to yield data\u2026"')),(0,r.kt)("p",null,"To trigger the subscription, ",(0,r.kt)("em",{parentName:"p"},"in another Ruru tab")," run a mutation that adds a\nmessage to that forum. This will depend on your implementation, for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},'mutation MyMutation {\n  createMessage(input: { message: { forumId: 1, body: "Hello World!" } }) {\n    clientMutationId\n  }\n}\n')),(0,r.kt)("p",null,"In this tab you will get the regular mutation answer. Going back to the previous\ntab, you will see the subscription payload. You are good to go! This should\nserve as the basis to implement your own custom subscriptions."))}d.isMDXComponent=!0}}]);