"use strict";(self.webpackChunk_localrepo_postgraphile_website=self.webpackChunk_localrepo_postgraphile_website||[]).push([[2358],{30876:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(2784);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),d=p(n),c=i,m=d["".concat(s,".").concat(c)]||d[c]||h[c]||l;return n?a.createElement(m,o(o({ref:t},u),{},{components:n})):a.createElement(m,o({ref:t},u))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,o=new Array(l);o[0]=c;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r[d]="string"==typeof e?e:i,o[1]=r;for(var p=2;p<l;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},81854:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>p});var a=n(7896),i=(n(2784),n(30876));const l={title:"Custom plugins",toc_min_heading_level:2,toc_max_heading_level:4},o="Migrating custom plugins",r={unversionedId:"migrating-from-v4/migrating-custom-plugins",id:"migrating-from-v4/migrating-custom-plugins",title:"Custom plugins",description:"If you've written some PostGraphile V4 plugins by hand (not using one of the",source:"@site/postgraphile/migrating-from-v4/migrating-custom-plugins.md",sourceDirName:"migrating-from-v4",slug:"/migrating-from-v4/migrating-custom-plugins",permalink:"/postgraphile/next/migrating-from-v4/migrating-custom-plugins",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/postgraphile/website/postgraphile/migrating-from-v4/migrating-custom-plugins.md",tags:[],version:"current",frontMatter:{title:"Custom plugins",toc_min_heading_level:2,toc_max_heading_level:4},sidebar:"docs",previous:{title:"makeAddPgTableOrderByPlugin",permalink:"/postgraphile/next/migrating-from-v4/make-add-pg-table-order-by-plugin"},next:{title:"Deploying to Heroku",permalink:"/postgraphile/next/deploying-heroku"}},s={},p=[{value:"TypeScript",id:"typescript",level:2},{value:"No look-ahead",id:"no-look-ahead",level:2},{value:"Type registration",id:"type-registration",level:2},{value:"Example",id:"example",level:3},{value:"Introspection",id:"introspection",level:2},{value:"Presets",id:"presets",level:2},{value:"Plugins",id:"plugins",level:2},{value:"plugin.inflection",id:"plugininflection",level:3},{value:".add",id:"add",level:4},{value:"Example",id:"example-1",level:5},{value:".replace",id:"replace",level:4},{value:".ignoreReplaceIfNotExists",id:"ignorereplaceifnotexists",level:4},{value:"Example",id:"example-2",level:5},{value:"plugin.gather",id:"plugingather",level:3},{value:"plugin.schema",id:"pluginschema",level:3},{value:".globalBehavior and .entityBehavior",id:"globalbehavior-and-entitybehavior",level:4},{value:".hooks",id:"hooks",level:4},{value:"Extending build",id:"extending-build",level:3},{value:"Extending scopes",id:"extending-scopes",level:3},{value:"Adding configuration options",id:"adding-configuration-options",level:3},{value:"Plans",id:"plans",level:2},{value:"Examples",id:"examples",level:2}],u={toc:p},d="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"migrating-custom-plugins"},"Migrating custom plugins"),(0,i.kt)("p",null,"If you've written some PostGraphile V4 plugins by hand (not using one of the\n",(0,i.kt)("inlineCode",{parentName:"p"},"make...Plugin")," helpers) then this migration guide is for you. We'll step you\nthrough some of the key changes."),(0,i.kt)("h2",{id:"typescript"},"TypeScript"),(0,i.kt)("p",null,"It is ",(0,i.kt)("strong",{parentName:"p"},"very strongly recommended")," that you write plugins in TypeScript. There\nare two main reasons for this:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"A lot of work has gone into making the plugin and configuration system\nstrongly typed so that you gain auto-complete and documentation on every\noption, this should make your plugin authoring experience much easier than\nin V4."),(0,i.kt)("li",{parentName:"ol"},"Since the plugin and configuration system is strongly typed, if you do not\nextend these types when you're writing your plugin, users that use\nTypeScript will not be able to supply your configuration options easily.")),(0,i.kt)("p",null,"Since your plugin will likely add attributes to various shared object types, we\nuse declaration merging heavily. Declaration merging allows you to add\nadditional attributes to existing TypeScript interfaces. You should familiarize yourself\nwith ",(0,i.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/declaration-merging.html"},"declaration merging in the TypeScript\ndocumentation"),"\nif you are not already familiar."),(0,i.kt)("p",null,"To avoid problems that come from having multiple versions of the same module\nthanks to the many and varied package managers (and versions thereof) all\nhaving their own ideas about which modules should be installed where, we merge\ninto globally scoped namespaces. The main roots for these namespaces that\nyou'll work with are ",(0,i.kt)("inlineCode",{parentName:"p"},"GraphileConfig")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"GraphileBuild"),"."),(0,i.kt)("p",null,"Many of the types need to be converted, here's a few:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'import("graphile-build").Build')," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"GraphileBuild.Build")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'import("graphile-build").Plugin')," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"GraphileConfig.Plugin")," (the ",(0,i.kt)("inlineCode",{parentName:"li"},"inflection"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"gather")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"schema")," scopes therein)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'import("postgraphile").PostGraphilePlugin')," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"GraphileConfig.Plugin")," (the ",(0,i.kt)("inlineCode",{parentName:"li"},"grafast")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"grafserv")," scopes therein)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'import("postgraphile").PostGraphileOptions')," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"GraphileConfig.Preset")," (split across the various scopes therein)")),(0,i.kt)("h2",{id:"no-look-ahead"},"No look-ahead"),(0,i.kt)("p",null,"Graphile Build no longer has a look-ahead engine, instead it uses Gra",(0,i.kt)("em",{parentName:"p"},"fast"),"\nplans. (You should familiarize yourself with ",(0,i.kt)("a",{parentName:"p",href:"https://grafast.org/grafast/"},"Gra",(0,i.kt)("em",{parentName:"a"},"fast"),"'s documentation"),".)"),(0,i.kt)("p",null,'That means all of the APIs that related to "data generators" and the\n',(0,i.kt)("inlineCode",{parentName:"p"},"QueryBuilder")," and similar no longer exist:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\ud83d\udeae ",(0,i.kt)("inlineCode",{parentName:"li"},"QueryBuilder")),(0,i.kt)("li",{parentName:"ul"},"\ud83d\udeae ",(0,i.kt)("inlineCode",{parentName:"li"},"getDataFromParsedResolveInfoFragment")),(0,i.kt)("li",{parentName:"ul"},"\ud83d\udeae ",(0,i.kt)("inlineCode",{parentName:"li"},"addDataGenerator")),(0,i.kt)("li",{parentName:"ul"},"\ud83d\udeae ",(0,i.kt)("inlineCode",{parentName:"li"},"addArgDataGenerator")),(0,i.kt)("li",{parentName:"ul"},"\ud83d\udeae ",(0,i.kt)("inlineCode",{parentName:"li"},"queryFromResolveData")),(0,i.kt)("li",{parentName:"ul"},"\ud83d\udeae ",(0,i.kt)("inlineCode",{parentName:"li"},"selectGraphQLResultFromTable"))),(0,i.kt)("p",null,"Similarly you should no longer use resolvers since Gra",(0,i.kt)("em",{parentName:"p"},"fast")," plan resolvers\nreplace both of these needs. (You ",(0,i.kt)("em",{parentName:"p"},"can")," use traditional resolvers with\nGra",(0,i.kt)("em",{parentName:"p"},"fast"),", but they lose many of the benefits of plan resolvers. Further, a\nGra",(0,i.kt)("em",{parentName:"p"},"fast"),' plan that does not use any traditional resolvers is considered\n"pure", so your plugin should aim to not "taint" your users\' schemas.)'),(0,i.kt)("p",null,"The good news is that Gra",(0,i.kt)("em",{parentName:"p"},"fast")," plan resolvers are typically much (much)\nshorter and easier to read, write and understand compared to the chaotic mess\nthat was V4's look-ahead system. We'll look at this a bit more in\n",(0,i.kt)("a",{parentName:"p",href:"#plans"},"Plans")," below."),(0,i.kt)("h2",{id:"type-registration"},"Type registration"),(0,i.kt)("p",null,"In V4 you could define types in an ad-hoc manner as and when you needed them\nusing the ",(0,i.kt)("inlineCode",{parentName:"p"},"newWithHooks()")," function, but this caused havoc at runtime because\nit meant that sometimes a type didn't already exist when you needed it ","\u2014"," they\nwere very dependent on ordering. This was particularly obvious when using\n",(0,i.kt)("inlineCode",{parentName:"p"},"makeExtendSchemaPlugin")," and trying to use auto-generated types that may or may\nnot exist yet. Worse still, plugins that built types only if a type with that\nname didn't already exist could get tricked into using an incompatible type!"),(0,i.kt)("p",null,"In V5, all types must be registered by name during the ",(0,i.kt)("inlineCode",{parentName:"p"},"init")," hook. The types\nstill are not created until they are needed (and may not be created at all),\nbut their names and spec generation functions must be registered ahead of time.\nThis means that when building fields and arguments you can always reference a\ntype by its name (using ",(0,i.kt)("inlineCode",{parentName:"p"},"build.getTypeByName('TypeNameHere')"),")."),(0,i.kt)("p",null,"Instead of ",(0,i.kt)("inlineCode",{parentName:"p"},"build.newWithHooks")," you should use the registration methods (note\nthat instead of passing the constructor as you did in ",(0,i.kt)("inlineCode",{parentName:"p"},"build.newWithHooks"),", you\nchoose the correctly named function):"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"build.registerObjectType(typeName, scope, specCallback, origin)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"build.registerInterfaceType(typeName, scope, specCallback, origin)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"build.registerUnionType(typeName, scope, specCallback, origin)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"build.registerScalarType(typeName, scope, specCallback, origin)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"build.registerEnumType(typeName, scope, specCallback, origin)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"build.registerInputObjectType(typeName, scope, specCallback, origin)"))),(0,i.kt)("p",null,"They each take 4 arguments:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"typeName")," is the (unique) name of the type (this would typically come from\nan inflector)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"scope")," is an object with any ",(0,i.kt)("inlineCode",{parentName:"li"},"GraphileBuild.Scope")," data relevant to this\nhook, useful for other plugins to register hooks against the type"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"specCallback")," is a callback function that takes no arguments and returns the\nspec object. Spec objects are similar to the ones that would be used with\nGraphQL.js constructors, except they have an extra couple of optional\nconvenience properties specific to Gra",(0,i.kt)("em",{parentName:"li"},"fast"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"origin")," is a string describing where this type came from / why it exists -\nit's particularly handy when two types try and register the same name")),(0,i.kt)("h3",{id:"example"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const MyPlugin: GraphileConfig.Plugin = {\n  name: "MyPlugin",\n  version: "0.0.0",\n\n  schema: {\n    hooks: {\n      init(_, build) {\n        const typeName = inflection.myInflector("MyInflectorInput");\n\n        build.registerObjectType(\n          typeName,\n          {\n            /* add scope data here */\n          },\n          () => ({\n            // Here\'s the spec for the type\n            description: "...",\n            fields: {\n              //...\n            },\n\n            // If this type requires a particular step class, optionally\n            // specify it here:\n            //\n            //     assertStep: ObjectStep,\n            //\n            // Or if you prefer, you can make `assertStep` a callback that\n            // throws an error if the step passed is incompatible:\n            //\n            //     assertStep($step: ExecutableStep): asserts $step is ObjectStep {\n            //       if (!($step instanceof ObjectStep)) {\n            //         throw new Error(`Expected ObjectStep, instead received \'${$step}\'`);\n            //       }\n            //     },\n          }),\n          `Here you\'d put a helpful phrase detailing why this type is being registered; useful when two types try and register with the same name`,\n        );\n\n        return _;\n      },\n    },\n  },\n};\n')),(0,i.kt)("h2",{id:"introspection"},"Introspection"),(0,i.kt)("p",null,"In V5 we've split the schema build process into two parts:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"gather"),' is where data is gathered from external sources (databases, APIs,\nthe file system, etc) and converted into an "input" to feed into the schema\nphase. Critically, ',(0,i.kt)("inlineCode",{parentName:"li"},"gather")," is asynchronous."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"schema"),' is where the GraphQL schema is produced from the gathered "input".\nCritically, ',(0,i.kt)("inlineCode",{parentName:"li"},"schema")," is synchronous.")),(0,i.kt)("p",null,"Introspection data is only available in the ",(0,i.kt)("inlineCode",{parentName:"p"},"gather")," phase, from there it's\nconverted into abstractions (resources, codecs, relations and behaviors) which\nare used during the ",(0,i.kt)("inlineCode",{parentName:"p"},"schema")," phase. Further the introspection system has been\nreplaced by a standalone module ",(0,i.kt)("inlineCode",{parentName:"p"},"pg-introspection")," which is strongly typed - it\nactually embeds parts of the TypeScript documentation so that when you hover\nover its various properties in your editor it will tell you how Postgres\ndescribes those fields!"),(0,i.kt)("p",null,"As such ",(0,i.kt)("inlineCode",{parentName:"p"},"pgIntrospectionResultsByKind")," is no more, and anything that you had\nthat relied on introspection results will need to be mapped to using the\nabstractions. Typically this results in your code being a bit simpler, but there\nare somethings you should pay particular attention to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'In V4 you\'d often look at the foreign key constraints on a table and go\n"forwards" and "backwards" from them. In V5 the abstraction for these is a\nrelation, which only represents one direction. A "backwards" relation is one\nthat has the "isReferencee" property set. The backward and forward relations\ncan have different smart tags.'),(0,i.kt)("li",{parentName:"ul"},'Whereas in V4 you\'d think in terms of "classes" (tables, views, etc) and\n"procs" (functions), in V5 these are all abstracted as "resources" (functions\nare resources that accept ',(0,i.kt)("inlineCode",{parentName:"li"},"parameters"),", table-likes are resources that\ndon't); and importantly every resource has a ",(0,i.kt)("inlineCode",{parentName:"li"},"codec")," that describes what it\nreturns. Sometimes you should focus on ",(0,i.kt)("inlineCode",{parentName:"li"},"codec")," (e.g. when it doesn't matter\nif the row has come from a table or function) whereas others you should focus\non the resource (when you need to actually ",(0,i.kt)("em",{parentName:"li"},"get")," the row)."),(0,i.kt)("li",{parentName:"ul"},"Changes to behaviors (@omit/etc) should be done during the ",(0,i.kt)("inlineCode",{parentName:"li"},"gather")," phase if\nthey require fetching additional data (e.g. from files, databases, APIs,\netc), or using the behavior system otherwise.")),(0,i.kt)("h2",{id:"presets"},"Presets"),(0,i.kt)("p",null,"Presets are a collection of plugins, configuration options, and other presets\nthat get merged together recursively to build the users ultimate configuration.\nA preset is an object with the following base properties (all optional):"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"extends")," - a list of presets that this preset extends"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"plugins")," - a list of plugin objects that this preset makes use of"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"disablePlugins")," - a list of plugin ",(0,i.kt)("em",{parentName:"li"},"names")," (strings) that should be disabled (skipped)")),(0,i.kt)("p",null,'In addition to these common properties, Graphile Config presets have additional\noptional fields to influence various different "scopes". For more details, see\n',(0,i.kt)("a",{parentName:"p",href:"../config"},"configuration"),"."),(0,i.kt)("p",null,"In V4 we had a plugin helper called ",(0,i.kt)("inlineCode",{parentName:"p"},"makePluginByCombiningPlugins"),"; in V5\nthat's better served by using a preset that simply lists the underlying plugins\nto be combined."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Critically, a preset must not have a ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," property; this property helps to\ndistinguish between presets and plugins.")),(0,i.kt)("h2",{id:"plugins"},"Plugins"),(0,i.kt)("p",null,"In PostGraphile V4 there were two types of plugins:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"schema plugins (functions) interacted with Graphile Engine (graphile-build\nand graphile-build-pg) and were responsible to changes to your GraphQL schema"),(0,i.kt)("li",{parentName:"ul"},'server plugins (objects) interacted with PostGraphile and it\'s server/CLI and\nwere responsible to changes to how the HTTP requests were handled and other\n"high level" concerns (including such concerns as which additional schema\nplugins to load!)')),(0,i.kt)("p",null,"In V5 there is only one type of plugin, a Graphile Config plugin. Graphile\nConfig plugins are objects with the following properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"name")," (required) - a unique name for this plugin"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"version")," (required) a semver-formatted version string"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"description")," - a short description of the plugin for use in documentation"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"experimental")," - set this true if the plugin is experimental (no current effect)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"provides"),' - a list of "features" (arbitrary strings) that the plugin provides; the plugin name is automatically included in this list'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"after"),' - a list of "features" that need to be established before this plugin runs'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"before"),' - a list of "features" that must not be processed until after this plugin runs')),(0,i.kt)("p",null,'In addition to these common properties, Graphile Config plugins have additional\noptional fields to influence various different "scopes".'),(0,i.kt)("p",null,'V4 "schema" plugins are now primarily concerned with these scopes:'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"inflection")," - naming things"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"gather")," - gathering the data necessary to build the schema, and outputting a registry"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"schema")," - assigning behaviors to entries in the registry and then building a GraphQL schema based on these")),(0,i.kt)("p",null,"Server plugins are likely more concerned with these scopes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"grafserv")," - handing HTTP requessts"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"grafast")," - handling the GraphQL request (e.g. manipulating the context, etc)")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Currently the ",(0,i.kt)("inlineCode",{parentName:"p"},"postgraphile")," CLI does not accept many options - it is intended\nthat users will provide options via the ",(0,i.kt)("inlineCode",{parentName:"p"},"graphile.config.ts")," (or similar)\nfile - so there is no plugin interface for adding CLI flags.")),(0,i.kt)("h3",{id:"plugininflection"},"plugin.inflection"),(0,i.kt)("p",null,'In V4, "inflection" was one of the hooks that were called whilst building a\nschema. In V5, inflection has been promoted to its own phase, primarily because\n"naming things" is a global concern that applies to both the ',(0,i.kt)("inlineCode",{parentName:"p"},"gather")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"schema")," phases (see below). Inflectors are also now defined in a declarative\n(i.e. object properties) way, rather than an imperative (i.e. function calls)\nway - this allows the system to inspect plugins without executing them."),(0,i.kt)("h4",{id:"add"},".add"),(0,i.kt)("p",null,"Used to add inflectors; when doing so you should also add their type\ndefinitions. Note that the type definitions only include the arguments that you\ncall the inflector with, the inflector implementation has an extra initial\nargument (",(0,i.kt)("inlineCode",{parentName:"p"},"options"),") that the system automatically passes."),(0,i.kt)("p",null,"Defining connection and list fields should now use the ",(0,i.kt)("inlineCode",{parentName:"p"},"this.listField(...)"),"\nand ",(0,i.kt)("inlineCode",{parentName:"p"},"this.connectionField(...)")," inflectors respectively as part of their\nimplementation, this will ensure that the fields are consistently named across\nthe schema."),(0,i.kt)("p",null,"The inflectors available have changed a little, use the TypeScript\nauto-completion to see what inflectors are available."),(0,i.kt)("h5",{id:"example-1"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'// Declare the type\ndeclare global {\n  namespace GraphileBuild {\n    interface Inflection {\n      /** Field name for a Connection field returning all rows from the resource. */\n      allRowsConnection(this: Inflection, resource: PgResource): string;\n    }\n  }\n}\n\n// Implement the inflector\nexport const PgAllRowsPlugin: GraphileConfig.Plugin = {\n  name: "PgAllRowsPlugin",\n  version: "0.0.0",\n\n  inflection: {\n    add: {\n      allRowsConnection(\n        options, // Additional argument, automatically passed by the system\n        resource, // This is the argument you defined in the types above\n      ) {\n        return this.connectionField(\n          this.camelCase(\n            `all-${this.pluralize(this._singularizedResourceName(resource))}`,\n          ),\n        );\n      },\n      // ...\n    },\n  },\n  // ...\n};\n')),(0,i.kt)("h4",{id:"replace"},".replace"),(0,i.kt)("p",null,"Should you wish to replace an inflector, you may use this hook instead. It\nworks similarly to ",(0,i.kt)("inlineCode",{parentName:"p"},"add")," above, with the following two differences:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The type declaration is not required (since it already exists, right?)"),(0,i.kt)("li",{parentName:"ol"},"an additional first argument is prepended onto the arguments list: ",(0,i.kt)("inlineCode",{parentName:"li"},"prev"),";\nthis is the previous implementation of the inflector, for your inflector to\ncall should it need to.")),(0,i.kt)("h4",{id:"ignorereplaceifnotexists"},".ignoreReplaceIfNotExists"),(0,i.kt)("p",null,"You can \"replace\" an inflector that doesn't exist, but a) you'll get a warning,\nand b) the ",(0,i.kt)("inlineCode",{parentName:"p"},"prev")," function will be null or undefined."),(0,i.kt)("p",null,"Alternatively, include the name of the inflector in ",(0,i.kt)("inlineCode",{parentName:"p"},"ignoreReplaceIfNotExists"),"\n(array of strings), and if the inflector didn't previously exist then it will\ncontinue to not exist (and we won't warn you about it). This also means that\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"prev")," argument is guaranteed to exist at runtime."),(0,i.kt)("h5",{id:"example-2"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'export const PgAllThePeoplePlugin: GraphileConfig.Plugin = {\n  name: "PgAllThePeoplePlugin",\n  version: "0.0.0",\n\n  inflection: {\n    replace: {\n      allRowsConnection(prev, options, resource) {\n        return resource.name === "people" ? `allThePeople` : prev!(resource);\n      },\n      ignoreReplaceIfNotExists: ["allRowsConnection"],\n    },\n  },\n};\n')),(0,i.kt)("h3",{id:"plugingather"},"plugin.gather"),(0,i.kt)("p",null,"If your plugin did anything asynchronous (extremely unlikely) then that work\nwould now be done during the ",(0,i.kt)("inlineCode",{parentName:"p"},"gather")," phase. If this is the case, please reach\nout to Benjie for additional documentation!"),(0,i.kt)("h3",{id:"pluginschema"},"plugin.schema"),(0,i.kt)("p",null,"Configures the behavior system and implements the schema hooks"),(0,i.kt)("h4",{id:"globalbehavior-and-entitybehavior"},".globalBehavior and .entityBehavior"),(0,i.kt)("p",null,"The '@omit' and '@simpleCollections' smart tags have been replaced with the\nbehavior system in V5. Though the V4 preset adds compatibility with the V4\n@omit system (by converting the @omit tags to behaviors), your plugins ",(0,i.kt)("em",{parentName:"p"},"should\nnot")," use the data from @omit - they should use the behavior data exclusively."),(0,i.kt)("p",null,"For more information on behavior, see ",(0,i.kt)("a",{parentName:"p",href:"../behavior"},"Behavior"),"."),(0,i.kt)("h4",{id:"hooks"},".hooks"),(0,i.kt)("p",null,"If you were writing a schema plugin, this is where the bulk of your replacement\nwill go."),(0,i.kt)("p",null,"This is where your schema hooks get registered now. A simple first change is\nthat we've moved from a procedural style to a declarative style. Further, we've\nreplaced all the ",(0,i.kt)("inlineCode",{parentName:"p"},":")," in the hook names with ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," to avoid needing quote marks\nand to make them easier to copy/paste (since it's more likely that word\nselection in an editor will select the whole string). The three arguments are\nstill essentially the same as they were."),(0,i.kt)("p",null,"For example, a V4 plugin that looks like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const ExamplePlugin: Plugin = (builder) => {\n  builder.hook("GraphQLObjectType:fields", (fields, build, context) => {\n    // ...\n    return fields;\n  });\n};\n')),(0,i.kt)("p",null,"would look like this in V5:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const ExamplePlugin: GraphileConfig.Plugin = {\n  name: "ExamplePlugin",\n  version: "0.0.0",\n\n  schema: {\n    hooks: {\n      GraphQLObjectType_fields(fields, build, context) {\n        //...\n        return fields;\n      },\n    },\n  },\n};\n')),(0,i.kt)("h3",{id:"extending-build"},"Extending build"),(0,i.kt)("p",null,"If your plugin adds capabilities to ",(0,i.kt)("inlineCode",{parentName:"p"},"GraphileBuild.Build")," then it must register\nthem with TypeScript via declaration merging. For example to add a ",(0,i.kt)("inlineCode",{parentName:"p"},"flibble"),"\nproperty to ",(0,i.kt)("inlineCode",{parentName:"p"},"GraphileBuild.Build"),", you might do:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'// Ensure that the types are imported for TypeScript\nimport "graphile-build";\nimport "graphile-config";\n\n// Extend the global GraphileBuild.Build type to add our \'flibble\' attribute:\ndeclare global {\n  namespace GraphileBuild {\n    interface Build {\n      flibble: bool;\n    }\n  }\n}\n\n// And here\'s the plugin that actually adds the attribute at runtime:\nexport const FlibblePlugin: GraphileConfig.Plugin = {\n  name: "FlibblePlugin",\n  version: "0.0.0",\n  schema: {\n    hooks: {\n      build(build) {\n        build.flibble = true;\n        return build;\n      },\n    },\n  },\n};\n')),(0,i.kt)("h3",{id:"extending-scopes"},"Extending scopes"),(0,i.kt)("p",null,"Similarly all of the scopes and contexts are typed within each hook by\ncamelcasing the hook name and prepending ",(0,i.kt)("inlineCode",{parentName:"p"},"Scope")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Context"),". For example, the\nscope in the ",(0,i.kt)("inlineCode",{parentName:"p"},"GraphQLObjectType_fields_field")," hook is now\n",(0,i.kt)("inlineCode",{parentName:"p"},"ScopeObjectFieldsField"),". If you need to add additional entries to any of these\nyou should do so via declaration merging, and you should ensure that the\nproperty is optional:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"declare global {\n  namespace GraphileBuild {\n    interface ScopeObjectFieldsField {\n      isRootNodeField?: boolean;\n    }\n  }\n}\n")),(0,i.kt)("h3",{id:"adding-configuration-options"},"Adding configuration options"),(0,i.kt)("p",null,"If your plugin requires the user to pass configuration options, most likely\nthey should be in the ",(0,i.kt)("inlineCode",{parentName:"p"},"preset.schema")," scope which should be retrieved via\n",(0,i.kt)("inlineCode",{parentName:"p"},"build.options"),". When doing so, we also need to add to the declaration-merged\ntypes so that TypeScript understands the presence of the new option:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'declare global {\n  namespace GraphileBuild {\n    interface SchemaOptions {\n      /**\n       * The default option to use for the \'includeArchived\' argument. Defaults to\n       * \'INHERIT\' where feasible and \'NO\' otherwise.\n       */\n      pgArchivedDefault?: "INHERIT" | "NO" | "YES" | "EXCLUSIVELY";\n    }\n  }\n}\n')),(0,i.kt)("p",null,"Note also that tools like ",(0,i.kt)("inlineCode",{parentName:"p"},"graphile config options")," will look at these\nTypeScript definitions and use them to provide documentation to the user - as\nsuch you should be sure to add a ",(0,i.kt)("inlineCode",{parentName:"p"},"/** ... */")," comment describing the feature,\nas we have above."),(0,i.kt)("h2",{id:"plans"},"Plans"),(0,i.kt)("p",null,"As we read earlier, there's no look-ahead system in PostGraphile V5; instead we\nuse Gra",(0,i.kt)("em",{parentName:"p"},"fast"),"'s planning system."),(0,i.kt)("p",null,"Where you used to use ",(0,i.kt)("inlineCode",{parentName:"p"},"addArgDataGenerator")," you should now give your argument\nan ",(0,i.kt)("inlineCode",{parentName:"p"},"applyPlan")," and set ",(0,i.kt)("inlineCode",{parentName:"p"},"autoApplyAfterParentPlan: true")," so that the plan is\nautomatically applied (without the parent field having to call\n",(0,i.kt)("inlineCode",{parentName:"p"},"fieldArgs.apply($target, 'argName')"),")."),(0,i.kt)("p",null,"Typically where you'd use a ",(0,i.kt)("inlineCode",{parentName:"p"},"QueryBuilder")," (",(0,i.kt)("inlineCode",{parentName:"p"},"queryBuilder"),") in V4, you'll be\ndealing with a ",(0,i.kt)("inlineCode",{parentName:"p"},"PgSelectStep")," (",(0,i.kt)("inlineCode",{parentName:"p"},"$pgSelect"),") in V5. Note that these are\nsignificantly different things, but they do have some parallels:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"QueryBuilder.getTableAlias()")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"$pgSelect.alias")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"QueryBuilder.where(fragment)")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"$pgSelect.where(fragment)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"QueryBuilder.orderBy(...)")," -> ",(0,i.kt)("inlineCode",{parentName:"li"},"$pgSelect.orderBy(...)")," (arguments differ, see TypeScript for details)")),(0,i.kt)("p",null,"Note that it's common to be dealing with a ",(0,i.kt)("inlineCode",{parentName:"p"},"PgSelectSingleStep"),"\n(",(0,i.kt)("inlineCode",{parentName:"p"},"$pgSelectSingle"),") when you're looking at a single record rather than the\ncollection. In this case should you need to get back to the collection (e.g. to\nget the alias) you can do ",(0,i.kt)("inlineCode",{parentName:"p"},"$pgSelectSingle.getClassStep()"),"."),(0,i.kt)("p",null,"Should you have code that uses ",(0,i.kt)("inlineCode",{parentName:"p"},"queryBuilder.parentQueryBuilder")," there's no\ndirect parallel. Instead, you should use the parent step and get what you need\nfrom there, and then embed that value into your query using a placeholder:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'// V4\nconst parentAlias = queryBuilder.parentQueryBuilder.getTableAlias();\nqueryBuilder.where(sql.fragment`${parentAlias}.archived_at is not true`);\n\n// V5\nconst $archivedAt = $parent.get("archived_at");\nconst archivedAtFrag = $pgSelect.placeholder($archivedAt);\n$pgSelect.where(sql`${archivedAtFrag} is not true`);\n')),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"applyPlan")," on an argument accepts 4 arguments, the first is the parent step\n(",(0,i.kt)("inlineCode",{parentName:"p"},"$parent"),"), which is the step that the field itself was called on. The second\nis the target step (",(0,i.kt)("inlineCode",{parentName:"p"},"$pgSelect"),"), which is typically the result of the fields'\nplan resolver. Note that input objects' ",(0,i.kt)("inlineCode",{parentName:"p"},"applyPlan"),"s only have the latter 3\narguments - they do not have access to the parent step unless their parent\ninput object or argument ",(0,i.kt)("inlineCode",{parentName:"p"},"applyPlan")," explicitly pass them down.")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"In general, unlike in V4, you should not assume too much about how the SQL will\nbe generated. It's better to use simple methods like\n",(0,i.kt)("inlineCode",{parentName:"p"},"$record.get('column_name')")," to retrieve attributes and then embed these values\nusing ",(0,i.kt)("inlineCode",{parentName:"p"},"$pgSelect.placeholder(...)")," than it is to make assumptions about the\nshape of the request and try and be clever and use aliases/etc. Normally\n",(0,i.kt)("inlineCode",{parentName:"p"},"@dataplan/pg")," will be able to figure out the best way to address your needs,\nand will inline things as necessary/optimal.")),(0,i.kt)("h2",{id:"examples"},"Examples"),(0,i.kt)("p",null,"Here are some conversions that have taken place on some of the community plugins:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/graphile-contrib/pg-many-to-many/compare/1eaa63adc0eaf54a1e862b6d76540a6315787479...9989331f1a082a7f140ae28e946780fd4ba7b808"},"pg-many-to-many")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/graphile-contrib/postgraphile-plugin-connection-filter/compare/fcd5e920c50604063c5db9bc28c557bd69bcfdcc...c222f763645446af8111825d9af8128816e30510"},"postgraphile-plugin-connection-filter")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/graphile-contrib/pg-omit-archived/compare/c3a3ac458e8cf328d67cc393dfefcc9784d1875e...a445527c18cac2497ccb53e0a1b119aee0514ca7?w=1"},"@graphile-contrib/pg-omit-archived"))))}h.isMDXComponent=!0}}]);