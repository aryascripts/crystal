"use strict";(self.webpackChunk_localrepo_grafast_website=self.webpackChunk_localrepo_grafast_website||[]).push([[8873],{30876:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>y});var a=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),s=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=s(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,m=p(e,["components","mdxType","originalType","parentName"]),c=s(n),u=r,y=c["".concat(l,".").concat(u)]||c[u]||h[u]||o;return n?a.createElement(y,i(i({ref:t},m),{},{components:n})):a.createElement(y,i({ref:t},m))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p[c]="string"==typeof e?e:r,i[1]=p;for(var s=2;s<o;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},60285:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>p,toc:()=>s});var a=n(7896),r=(n(2784),n(30876));const o={},i="Polymorphism",p={unversionedId:"polymorphism",id:"polymorphism",title:"Polymorphism",description:"GraphQL has two types of output polymorphism currently: interfaces and unions.",source:"@site/grafast/polymorphism.mdx",sourceDirName:".",slug:"/polymorphism",permalink:"/grafast/polymorphism",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/grafast/website/grafast/polymorphism.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Plan diagrams",permalink:"/grafast/plan-diagrams"},next:{title:"Production Considerations",permalink:"/grafast/production-considerations"}},l={},s=[{value:"Polymorphic positions",id:"polymorphic-positions",level:2},{value:"Polymorphic-capable steps",id:"polymorphic-capable-steps",level:2},{value:"Caveats",id:"caveats",level:2}],m={toc:s},c="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"polymorphism"},"Polymorphism"),(0,r.kt)("p",null,"GraphQL has two types of output polymorphism currently: interfaces and unions.\nAn interface defines a list of fields; all objects that implement the interface\nmust implement fields compatible with these. A union is a simple list of\npossible object types."),(0,r.kt)("p",null,"Gra",(0,r.kt)("em",{parentName:"p"},"fast")," supports both of these forms of GraphQL polymorphism, both through\nresolvers and through plans. Resolvers work the same (basically) as they do in\nGraphQL.js so we won't dig into them here, but let's look into how Gra",(0,r.kt)("em",{parentName:"p"},"fast"),"\nsupports polymorphism via plans."),(0,r.kt)("h2",{id:"polymorphic-positions"},"Polymorphic positions"),(0,r.kt)("p",null,'Let\'s define the term "polymorphic position" to make it easier to talk about\nplanning our polymorphic GraphQL query. Imagine you have a GraphQL schema such\nas:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"interface Animal {\n  name: String!\n}\ntype Cat extends Animal {\n  name: String!\n  numberOfLives: Int!\n}\ntype Dog extends Animal {\n  name: String!\n  wagsTail: Boolean!\n}\ntype Query {\n  bestAnimal: Animal\n  randomAnimals: [Animal]\n}\n")),(0,r.kt)("p",null,"One query to this schema could be:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"{\n  bestAnimal {\n    name\n    ... on Cat {\n      numberOfLives\n    }\n    ... on Dog {\n      wagsTail\n    }\n  }\n}\n")),(0,r.kt)("p",null,"Here the return type of the ",(0,r.kt)("inlineCode",{parentName:"p"},"bestAnimal")," field is a polymorphic type (",(0,r.kt)("inlineCode",{parentName:"p"},"Animal"),",\nwhich is an interface), so the return type of ",(0,r.kt)("inlineCode",{parentName:"p"},"bestAnimal")," is a polymorphic\nposition in this query."),(0,r.kt)("p",null,"Another query could be:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"{\n  randomAnimals {\n    name\n    ... on Cat {\n      numberOfLives\n    }\n    ... on Dog {\n      wagsTail\n    }\n  }\n}\n")),(0,r.kt)("p",null,"Here the return type of ",(0,r.kt)("inlineCode",{parentName:"p"},"randomAnimals")," is a list (",(0,r.kt)("inlineCode",{parentName:"p"},"[Animal]"),"). A list is not\nitself polymorphic, however the type inside the list is a polymorphic type\n(",(0,r.kt)("inlineCode",{parentName:"p"},"Animal")," again), so a polymorphic position in this query is inside the list\nreturned by ",(0,r.kt)("inlineCode",{parentName:"p"},"randomAnimals"),"."),(0,r.kt)("p",null,"Operations may have any number (0 or higher) of polymorphic positions."),(0,r.kt)("h2",{id:"polymorphic-capable-steps"},"Polymorphic-capable steps"),(0,r.kt)("p",null,"When a polymorphic position in an operation is being planned, Gra",(0,r.kt)("em",{parentName:"p"},"fast")," will\ncall the field's plan resolver function as usual (or the resulting step's\n",(0,r.kt)("inlineCode",{parentName:"p"},"itemPlan")," method for polymorphic positions occurring inside of lists) to get\nthe step representing this polymorphic position. Gra",(0,r.kt)("em",{parentName:"p"},"fast")," requires that this\nstep must be a polymorphic-capable step, that is a step whose class implements\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"planForType")," method, otherwise a planning error will be raised."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"  planForType(objectType: GraphQLObjectType): ExecutableStep;\n")),(0,r.kt)("p",null,"Having determined the polymorphic-capable step that represents this polymorphic\nposition, Gra",(0,r.kt)("em",{parentName:"p"},"fast")," will create a polymorphic LayerPlan and loop through all of\nthe possible concrete object types valid at that location. For each concrete\nobject type, Gra",(0,r.kt)("em",{parentName:"p"},"fast")," will pass the type to the polymorphic-capable step's\n",(0,r.kt)("inlineCode",{parentName:"p"},"planForType")," method and the resulting step will represent that concrete object\ntype. Multiple concrete object types may be represented by the same step."),(0,r.kt)("p",null,"Planning then continues with the child selection sets being traversed for each\npossible concrete object type and corresponding step."),(0,r.kt)("p",null,"At run-time, when a polymorphic-capable step executes, each of the entries in\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"execute()")," result list must be either ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", an error, or the result of\ncalling Gra",(0,r.kt)("em",{parentName:"p"},"fast"),"'s ",(0,r.kt)("inlineCode",{parentName:"p"},"polymorphicWrap")," function, passing the concrete object\ntype's name as the first argument, and optionally any associated data as the\nsecond argument. This allows Gra",(0,r.kt)("em",{parentName:"p"},"fast"),' to determine which "polymorphic branch"\nhas been taken, which will control which future steps will be executed against\nthis data.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export function polymorphicWrap<TType extends string>(\n  type: TType,\n  data?: unknown,\n): PolymorphicData<TType>;\n")),(0,r.kt)("h2",{id:"caveats"},"Caveats"),(0,r.kt)("p",null,"Highly polymorphic operations may result in very significant planning time,\nthis is something we're working to optimize but for now we recommend that you\nuse persisted operations (aka persisted queries) to ensure that only your\ndevelopers operations are allowed. Alternatively, use our plugin that validates\nthat operations don't contain too much polymorphism (TODO: plugin not yet\navailable)."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Currently Gra",(0,r.kt)("em",{parentName:"p"},"fast")," uses a rudimentary strategy where all possible polymorphic\ntypes at each point in the GraphQL operation are planned at planning time. This\nis a simple approach, but it can inflate the time spent planning an operation,\nespecially for highly polymorphic operations where combinatorics is a\nsignificant concern."),(0,r.kt)("p",{parentName:"admonition"},"At some point, Gra",(0,r.kt)("em",{parentName:"p"},"fast"),' will add support for on-demand polymorphic planning.\nWith this strategy, each "polymorphic branch" of the plan will only be planned\nthe first time that an object of that type is met at runtime. This on-demand\npolymorphic planning strategy should significantly decrease initial planning\ntime for highly polymorphic operations, and may result in many of the paths\nnever needing to be planned at all!')))}h.isMDXComponent=!0}}]);