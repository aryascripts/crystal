"use strict";(self.webpackChunk_localrepo_postgraphile_website=self.webpackChunk_localrepo_postgraphile_website||[]).push([[8218],{30876:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>c});var a=t(2784);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=p(t),m=r,c=d["".concat(s,".").concat(m)]||d[m]||h[m]||i;return t?a.createElement(c,l(l({ref:n},u),{},{components:t})):a.createElement(c,l({ref:n},u))}));function c(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,l=new Array(i);l[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[d]="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},81798:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=t(7896),r=(t(2784),t(30876));const i={layout:"page",path:"/postgraphile/make-extend-schema-plugin/",title:"makeExtendSchemaPlugin (graphile-utils)"},l=void 0,o={unversionedId:"make-extend-schema-plugin",id:"version-4.x/make-extend-schema-plugin",title:"makeExtendSchemaPlugin (graphile-utils)",description:"NOTE: this documentation applies to PostGraphile v4.1.0+",source:"@site/versioned_docs/version-4.x/make-extend-schema-plugin.md",sourceDirName:".",slug:"/make-extend-schema-plugin",permalink:"/postgraphile/current/make-extend-schema-plugin",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/postgraphile/website/versioned_docs/version-4.x/make-extend-schema-plugin.md",tags:[],version:"4.x",frontMatter:{layout:"page",path:"/postgraphile/make-extend-schema-plugin/",title:"makeExtendSchemaPlugin (graphile-utils)"},sidebar:"docs",previous:{title:"makeChangeNullabilityPlugin (graphile-utils)",permalink:"/postgraphile/current/make-change-nullability-plugin"},next:{title:"makeProcessSchemaPlugin (graphile-utils)",permalink:"/postgraphile/current/make-process-schema-plugin"}},s={},p=[{value:"The <code>gql</code> and <code>embed</code> helpers",id:"the-gql-and-embed-helpers",level:3},{value:"Querying the database inside a resolver",id:"querying-the-database-inside-a-resolver",level:3},{value:"Reading database column values",id:"reading-database-column-values",level:3},{value:"The <code>selectGraphQLResultFromTable</code> helper",id:"the-selectgraphqlresultfromtable-helper",level:3},{value:"Usage for non-tables",id:"usage-for-non-tables",level:4},{value:"QueryBuilder",id:"querybuilder",level:4},{value:"QueryBuilder named children",id:"querybuilder-named-children",level:5},{value:"Query Example",id:"query-example",level:4},{value:"Mutation Example",id:"mutation-example",level:4},{value:"Working with arrays via <code>json_array_elements</code>",id:"working-with-arrays-via-json_array_elements",level:4},{value:"Mutation Example with Node ID",id:"mutation-example-with-node-id",level:3},{value:"Using the <code>@pgQuery</code> directive for non-root queries and better performance",id:"using-the-pgquery-directive-for-non-root-queries-and-better-performance",level:3},{value:"@pgQuery with an object type",id:"pgquery-with-an-object-type",level:4},{value:"@pgQuery with a leaf type",id:"pgquery-with-a-leaf-type",level:4},{value:"Plugin SQL Privileges",id:"plugin-sql-privileges",level:3}],u={toc:p},d="wrapper";function h(e){let{components:n,...t}=e;return(0,r.kt)(d,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"NOTE: this documentation applies to PostGraphile v4.1.0+")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"graphile-utils")," module contains some helpers for extending your\nPostGraphile (or Graphile Engine) GraphQL schema without having to understand\nthe complex plugin system."),(0,r.kt)("p",null,"The main one you'll care about to start with is ",(0,r.kt)("inlineCode",{parentName:"p"},"makeExtendSchemaPlugin"),"."),(0,r.kt)("p",null,"Using ",(0,r.kt)("inlineCode",{parentName:"p"},"makeExtendSchemaPlugin")," you can write a plugin that will merge additional\nGraphQL types and resolvers into your schema using a similar syntax to\n",(0,r.kt)("inlineCode",{parentName:"p"},"graphql-tools"),". You need to provide the ",(0,r.kt)("inlineCode",{parentName:"p"},"typeDefs")," schema definition and\n",(0,r.kt)("inlineCode",{parentName:"p"},"resolvers")," function to use. Your plugin will likely take a shape like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const { makeExtendSchemaPlugin, gql } = require("graphile-utils");\n\nconst MyPlugin = makeExtendSchemaPlugin((build) => {\n  // Get any helpers we need from `build`\n  const { pgSql: sql, inflection } = build;\n\n  return {\n    typeDefs: gql`...`,\n    resolvers: {\n      /*...*/\n    },\n  };\n});\n\nmodule.exports = MyPlugin;\n')),(0,r.kt)("p",null,"And would be added to your PostGraphile instance via"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"CLI: ",(0,r.kt)("inlineCode",{parentName:"li"},"--append-plugins `pwd`/MySchemaExtensionPlugin.js")),(0,r.kt)("li",{parentName:"ul"},"Library: ",(0,r.kt)("inlineCode",{parentName:"li"},"appendPlugins: [require('./MySchemaExtensionPlugin')]"))),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"build")," argument to the makeExtendSchemaPlugin callback contains lots of\ninformation and helpers defined by various plugins, most importantly it includes\nthe introspection results (",(0,r.kt)("inlineCode",{parentName:"p"},"build.pgIntrospectionResultsByKind"),"), inflection\nfunctions (",(0,r.kt)("inlineCode",{parentName:"p"},"build.inflection"),"), and SQL helper (",(0,r.kt)("inlineCode",{parentName:"p"},"build.pgSql"),", which is an\ninstance of ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/pg-sql2"},"pg-sql2"),")."),(0,r.kt)("p",null,"The callback should return an object with two keys:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"typeDefs"),": a GraphQL AST generated with the ",(0,r.kt)("inlineCode",{parentName:"li"},"gql")," helper from\n",(0,r.kt)("inlineCode",{parentName:"li"},"graphile-utils")," (note this is NOT from the ",(0,r.kt)("inlineCode",{parentName:"li"},"graphql-tag")," library, ours works\nin a slightly different way)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"resolvers"),": an object that's keyed by the GraphQL type names of types defined\n(or extended) in ",(0,r.kt)("inlineCode",{parentName:"li"},"typeDefs"),", the values of which are objects keyed by the\nfield names with values that are resolver functions.")),(0,r.kt)("p",null,"For a larger example of how typeDefs and resolvers work, have a look at the\n",(0,r.kt)("a",{parentName:"p",href:"https://www.graphql-tools.com/docs/generate-schema"},"graphql-tools docs")," - ours\nwork in a similar way."),(0,r.kt)("p",null,"Note that the resolve functions defined in ",(0,r.kt)("inlineCode",{parentName:"p"},"resolvers")," will be sent the standard\n4 GraphQL resolve arguments (",(0,r.kt)("inlineCode",{parentName:"p"},"parent"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"args"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"context"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"resolveInfo"),"); but\nthe 4th argument (",(0,r.kt)("inlineCode",{parentName:"p"},"resolveInfo"),") will also contain graphile-specific helpers."),(0,r.kt)("h3",{id:"the-gql-and-embed-helpers"},"The ",(0,r.kt)("inlineCode",{parentName:"h3"},"gql")," and ",(0,r.kt)("inlineCode",{parentName:"h3"},"embed")," helpers"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"gql")," helper is responsible for turning the human-readable GraphQL schema\nlanguage you write into an abstract syntax tree (AST) that the application can\nunderstand. Our ",(0,r.kt)("inlineCode",{parentName:"p"},"gql")," help differs slightly from the one you may be familiar\nwith in the ",(0,r.kt)("inlineCode",{parentName:"p"},"graphql-tag")," npm module, namely in how the placeholders work. Ours\nis designed to work with PostGraphile's ",(0,r.kt)("a",{parentName:"p",href:"./inflection/"},"inflection system"),", so\nyou can embed strings directly. You may also embed other gql tags directly. For\nexample:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const nameOfType = "MyType"; // Or use the inflection system to generate a type\n\n// This tag interpolates the string `nameOfType` to allow dynamic naming of the\n// type.\nconst Type = gql`\n  type ${nameOfType} {\n    str: String\n    int: Int\n  }\n`;\n\n// This tag interpolates the entire definition in `Type` above.\nconst typeDefs = gql`\n  ${Type}\n\n  extend type Query {\n    fieldName: Type\n  }\n`;\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"embed")," helper is for use with ",(0,r.kt)("inlineCode",{parentName:"p"},"gql")," when you want to embed a raw JavaScript\nvalue (anything: regexp, function, string, object, etc) into the document; for\nexample to pass it to a directive. We use this with the ",(0,r.kt)("inlineCode",{parentName:"p"},"@pgQuery")," directive\nfurther down this page. Here's a simple example of embedding an object."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const meta = {\n  /* arbitrary data */\n  name: "fieldName",\n  added: "2019-04-29T16:15:00Z",\n};\nconst typeDefs = gql`\n  extend type Query {\n    fieldName: Int @scope(meta: ${embed(fieldNameMeta)})\n  }\n`;\n')),(0,r.kt)("h3",{id:"querying-the-database-inside-a-resolver"},"Querying the database inside a resolver"),(0,r.kt)("p",null,"PostGraphile provisions, sets up and tears down a PostgreSQL client\nautomatically for each GraphQL query. Setup involves beginning a transaction and\nsetting the relevant session variables, e.g. using your JWT or the ",(0,r.kt)("inlineCode",{parentName:"p"},"pgSettings"),"\nfunction. You can access this client on ",(0,r.kt)("inlineCode",{parentName:"p"},"context.pgClient"),"; it's currently an\ninstance of\n",(0,r.kt)("a",{parentName:"p",href:"https://node-postgres.com/api/client"},(0,r.kt)("inlineCode",{parentName:"a"},"pg.Client")," from the ",(0,r.kt)("inlineCode",{parentName:"a"},"pg")," module"),";\nhowever you should only use it like this to maintain future compatibility:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const { rows } = await context.pgClient.query(\n  sqlText, // e.g. "select * from users where id = $1"\n  optionalVariables, // e.g. [27]\n);\n')),(0,r.kt)("p",null,"NOTE: ",(0,r.kt)("inlineCode",{parentName:"p"},"context")," is the third argument passed to a GraphQL resolver\n(",(0,r.kt)("inlineCode",{parentName:"p"},"function myResolver(parentObject, args, context, info) { /* ... */ }"),")."),(0,r.kt)("p",null,"Since you're already in a transaction, issuing ",(0,r.kt)("inlineCode",{parentName:"p"},"BEGIN;")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"COMMIT;")," inside your\nresolver is a Really Bad Idea\u2122. Should you need a sub-transaction,\n",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/current/sql-savepoint.html"},"use a SAVEPOINT"),".\nHowever, please be aware that PostGraphile only sets up a transaction when it\nneeds to (e.g. when it's a mutation, or when there are config variables or a\nrole to set); so you cannot rely on SAVEPOINT working inside of queries unless\nyou know these conditions are met."),(0,r.kt)("p",null,"Because the entire GraphQL operation is executed within a single transaction, be\nvery wary that you don't cause an SQL error which causes the entire transaction\nto fail. This could leave things in a very odd state - particularly for\nmutations - e.g. where you return a partial success to the user, but actually\nroll back the results. It's recommended that all mutations are wrapped in\n",(0,r.kt)("inlineCode",{parentName:"p"},"SAVEPOINT")," / ",(0,r.kt)("inlineCode",{parentName:"p"},"RELEASE SAVEPOINT")," / ",(0,r.kt)("inlineCode",{parentName:"p"},"ROLLBACK TO SAVEPOINT")," calls."),(0,r.kt)("p",null,"When your resolver returns results that will be used by autogenerated types and\nfields, you must not return query results such as these directly. Instead use\n",(0,r.kt)("a",{parentName:"p",href:"#the-selectgraphqlresultfromtable-helper"},"the ",(0,r.kt)("inlineCode",{parentName:"a"},"selectGraphQLResultFromTable")," helper"),"\ndocumented below. The results of your ",(0,r.kt)("inlineCode",{parentName:"p"},"pgClient.query"),' should be used within the\nresolver only, and should not "leak" (in general).'),(0,r.kt)("h3",{id:"reading-database-column-values"},"Reading database column values"),(0,r.kt)("p",null,"When extending a schema, it's often because you want to expose data from Node.js\nthat would be too difficult (or impossible) to access from PostgreSQL. When\ndefining a field on an existing table-backed type defined by PostGraphile, it's\nuseful to access data from the underlying table in the resolver."),(0,r.kt)("p",null,"To do this you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"@requires(columns: [\u2026])")," field directive to declare\nthe data dependencies of your resolver. This guarantees that when the resolver\nis executed, the data is immediately available."),(0,r.kt)("p",null,"Here's an example to illustrate."),(0,r.kt)("p",null,"In the database you have a ",(0,r.kt)("inlineCode",{parentName:"p"},"product")," table (imagine an online store), that\nPostGraphile will include in the GraphQL schema by creating a type ",(0,r.kt)("inlineCode",{parentName:"p"},"Product"),"\nwith fields ",(0,r.kt)("inlineCode",{parentName:"p"},"id"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"name"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"price_in_us_cents"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"create table product (\n  id uuid primary key,\n  name text not null,\n  price_in_us_cents integer not null\n);\n")),(0,r.kt)("p",null,"This may result in the following GraphQL type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"type Product {\n  id: UUID!\n  name: String!\n  priceInUsCents: Int!\n}\n")),(0,r.kt)("p",null,"However imagine you're selling internationally, and you want to expose the price\nin other currencies directly from the ",(0,r.kt)("inlineCode",{parentName:"p"},"Product")," type itself. This kind of\nfunctionality is well suited to being performed in Node.js (e.g. by making a\nREST call to a foreign exchange service over the internet) but might be a\nstruggle from with PostgreSQL."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:"{2,4,6-25,30}","{2,4,6-25,30}":!0},'const { postgraphile } = require("postgraphile");\nconst { makeExtendSchemaPlugin, gql } = require("graphile-utils");\nconst express = require("express");\nconst { convertUsdToAud } = require("ficticious-npm-library");\n\nconst MyForeignExchangePlugin = makeExtendSchemaPlugin((build) => {\n  return {\n    typeDefs: gql`\n      extend type Product {\n        priceInAuCents: Int! @requires(columns: ["price_in_us_cents"])\n      }\n    `,\n    resolvers: {\n      Product: {\n        priceInAuCents: async (product) => {\n          // Note that the columns are converted to fields, so the case changes\n          // from `price_in_us_cents` to `priceInUsCents`\n          const { priceInUsCents } = product;\n          return await convertUsdToAud(priceInUsCents);\n        },\n      },\n    },\n  };\n});\n\nconst app = express();\napp.use(\n  postgraphile(process.env.DATABASE_URL, ["app_public"], {\n    graphiql: true,\n    appendPlugins: [MyForeignExchangePlugin],\n  }),\n);\napp.listen(3030);\n')),(0,r.kt)("h3",{id:"the-selectgraphqlresultfromtable-helper"},"The ",(0,r.kt)("inlineCode",{parentName:"h3"},"selectGraphQLResultFromTable")," helper"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"IMPORTANT"),": this helper is for populating data you return from your\n","*","resolver; you ",(0,r.kt)("em",{parentName:"p"},"should not")," use ",(0,r.kt)("inlineCode",{parentName:"p"},"selectGraphQLResultFromTable")," to retrieve data\nfor your resolver to process. Instead use ",(0,r.kt)("inlineCode",{parentName:"p"},"context.pgClient")," directly."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"IMPORTANT"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"selectGraphQLResultFromTable")," should only be called once per\nresolver; it doesn't make sense to call it multiple times, and attempting to\ncombine the results is liable to cause issues. If you feel the need to call it\nmultiple times, please read the IMPORTANT note above, and/or consider\nimplementing your requirement via multiple fields/resolvers rather than trying\nto do it all in one."),(0,r.kt)("p",null,"Resolvers are passed 4 arguments: ",(0,r.kt)("inlineCode",{parentName:"p"},"parent, args, context, resolveInfo"),". In the\n",(0,r.kt)("inlineCode",{parentName:"p"},"context.pgClient")," is an instance of a database client from the ",(0,r.kt)("inlineCode",{parentName:"p"},"pg")," module\nthat's already in a transaction configured with the settings for this particular\nGraphQL request. You can use this client to make requests to the database within\nthis transaction."),(0,r.kt)("p",null,"However, because PostGraphile uses Graphile Engine's look-ahead features, you\nwill not be able to easily build a query that will return the data PostGraphile\nrequires to represent nested relations/etc using ",(0,r.kt)("inlineCode",{parentName:"p"},"pgClient")," directly. That is\nwhy ",(0,r.kt)("inlineCode",{parentName:"p"},"resolveInfo.graphile.selectGraphQLResultFromTable")," exists."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"resolveInfo.graphile.selectGraphQLResultFromTable")," function is vital if you\nwant to return PostGraphile database table/view/function/etc-related types from\nyour GraphQL field. It is responsible for hooking into the query look-ahead\nfeatures of Graphile Engine to inspect the incoming GraphQL query and pull down\nthe relevant data from the database (including nested relations). You are then\nexpected to return the result of this fetch via your resolver. You can use the\n",(0,r.kt)("inlineCode",{parentName:"p"},"queryBuilder")," object to customize the generated query, changing the order,\nadding ",(0,r.kt)("inlineCode",{parentName:"p"},"where")," clauses, ",(0,r.kt)("inlineCode",{parentName:"p"},"limit"),"s, etc (see below). Note that if you are not\nreturning a record type directly (for example you're returning a mutation\npayload, or a connection interface), you should use the ",(0,r.kt)("inlineCode",{parentName:"p"},"@pgField")," directive as\nshown below so that the Look Ahead feature continues to work."),(0,r.kt)("h4",{id:"usage-for-non-tables"},"Usage for non-tables"),(0,r.kt)("p",null,"Despite the (unfortunate) name; ",(0,r.kt)("inlineCode",{parentName:"p"},"selectGraphQLResultFromTable")," can be used with\nany table-like source, including a table-defining sub-query, however it should\nonly be used where the type perfectly matches the expected return type of the\nGraphQL field."),(0,r.kt)("p",null,"This non-table support is particularly useful when it comes to calling\nfunctions; for example if you had a function ",(0,r.kt)("inlineCode",{parentName:"p"},"match_user()")," that returns a\n",(0,r.kt)("inlineCode",{parentName:"p"},"users")," record, you could define a ",(0,r.kt)("inlineCode",{parentName:"p"},"makeExtendSchemaPlugin")," resolver that\nqueries it like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"// type Query { matchingUser(searchText: String!): User }\nconst matchingUserResolver = async (parent, args, context, resolveInfo) => {\n  const [row] = await resolveInfo.graphile.selectGraphQLResultFromTable(\n    sql.fragment`(select * from match_user(${sql.value(args.searchText)}))`,\n    () => {}, // no-op\n  );\n  return row;\n};\n")),(0,r.kt)("h4",{id:"querybuilder"},"QueryBuilder"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"queryBuilder")," is an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryBuilder"),", a helper that uses an SQL AST\nconstructed via ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/pg-sql2#api"},(0,r.kt)("inlineCode",{parentName:"a"},"pg-sql2")," methods"),"\nto dynamically create powerful SQL queries without risking SQL injection\nattacks. The ",(0,r.kt)("inlineCode",{parentName:"p"},"queryBuilder")," has a number of methods which affect the query which\nwill be generated. The main ones you're likely to want are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"where(sqlFragment)"),"; e.g.\n",(0,r.kt)("inlineCode",{parentName:"li"},"queryBuilder.where(build.pgSql.fragment`is_admin is true`)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"orderBy(() => sqlFragment, ascending)"),"; e.g.\n",(0,r.kt)("inlineCode",{parentName:"li"},"queryBuilder.orderBy(() => build.pgSql.fragment`created_at`, false)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"limit(number)"),"; e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"queryBuilder.limit(1)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"offset(number)"),"; e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"queryBuilder.offset(1)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"select(() => sqlFragment, alias)"),"; e.g.\n",(0,r.kt)("inlineCode",{parentName:"li"},"queryBuilder.select(() => build.pgSql.fragment`gen_random_uuid()`, '__my_random_uuid')")," -\nit's advised to start your alias with two underscores to prevent it clashing\nwith any potential columns exposed as GraphQL fields.")),(0,r.kt)("p",null,"On top of these methods, ",(0,r.kt)("inlineCode",{parentName:"p"},"QueryBuilder")," has the following useful properties:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"parentQueryBuilder"),": gives access to the parent QueryBuilder instance;\nprimarily (and possibly only) useful for executing\n",(0,r.kt)("inlineCode",{parentName:"li"},"queryBuilder.parentQueryBuilder.getTableAlias()")," so you can reference a field\non the parent record (e.g. to perform filtering based on a relation).")),(0,r.kt)("p",null,"There are many other internal properties and methods, but you probably shouldn't\ncall them. Only rely on the methods and properties documented above."),(0,r.kt)("h5",{id:"querybuilder-named-children"},"QueryBuilder named children"),(0,r.kt)("p",null,"In very rare circumstances you might also need to use the following methods:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"buildChild()"),"; builds a child query builder, automatically passing through\nthe relevant options and setting ",(0,r.kt)("inlineCode",{parentName:"li"},"parentQueryBuilder")," for you - useful for\nconstructing subqueries (normally you'd use ",(0,r.kt)("inlineCode",{parentName:"li"},"build.pgQueryFromResolveData"),"\nrather than using the ",(0,r.kt)("inlineCode",{parentName:"li"},"buildChild")," method directly)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"buildNamedChildSelecting(name, from, selectExpression)"),"; creates a child\nquery builder that's named ",(0,r.kt)("inlineCode",{parentName:"li"},"name"),", selecting only ",(0,r.kt)("inlineCode",{parentName:"li"},"selectExpression")," using the\ntable (or subquery) described in ",(0,r.kt)("inlineCode",{parentName:"li"},"from"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getNamedChild(name)"),"; gets the named child created by\n",(0,r.kt)("inlineCode",{parentName:"li"},"buildNamedChildSelecting"))),(0,r.kt)("p",null,"An example of these methods being used can be found here:\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/singingwolfboy/graphile-engine/blob/44a2496102267ce664c1286860b6368283463063/packages/postgraphile-core/__tests__/integration/ToyCategoriesPlugin.js"},"https://github.com/singingwolfboy/graphile-engine/blob/44a2496102267ce664c1286860b6368283463063/packages/postgraphile-core/__tests__/integration/ToyCategoriesPlugin.js")),(0,r.kt)("p",null,"In this example we have a many-to-many relationship with three tables: ",(0,r.kt)("inlineCode",{parentName:"p"},"toys"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"categories")," and the join table between them: ",(0,r.kt)("inlineCode",{parentName:"p"},"toy_categories"),". We add a\n",(0,r.kt)("inlineCode",{parentName:"p"},"categories")," field onto the ",(0,r.kt)("inlineCode",{parentName:"p"},"Toy")," type, which constructs a subquery called\n",(0,r.kt)("inlineCode",{parentName:"p"},"toyCategoriesSubquery")," to determine the categories the current toy is in from\nthe join table ",(0,r.kt)("inlineCode",{parentName:"p"},"toy_categories"),". Later, in a different plugin (just a different\nhook in this example), we want to be able to filter this list of ",(0,r.kt)("inlineCode",{parentName:"p"},"categories")," to\nonly the list of categories where the join table's ",(0,r.kt)("inlineCode",{parentName:"p"},"toy_categories.approved"),'\nfield is true; to do so we need to be able to get access to this "named"\nsubquery so that we can add conditions to it\'s ',(0,r.kt)("inlineCode",{parentName:"p"},"WHERE")," clause."),(0,r.kt)("p",null,"In most cases you're only dealing with one or two tables so you won't need this\nlevel of complexity."),(0,r.kt)("h4",{id:"query-example"},"Query Example"),(0,r.kt)("p",null,"The below is a simple example which would have been better served by\n",(0,r.kt)("a",{parentName:"p",href:"./custom-queries/#custom-query-sql-procedures"},"Custom Query SQL Procedures"),";\nhowever it demonstrates using ",(0,r.kt)("inlineCode",{parentName:"p"},"makeExtendSchemaPlugin")," with a database record,\ntable connection, and list of database records."),(0,r.kt)("p",null,"You can also use this system to define mutations or to call out to external\nservices \u2014 see below."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const { postgraphile } = require("postgraphile");\nconst { makeExtendSchemaPlugin, gql } = require("graphile-utils");\nconst express = require("express");\n\nconst app = express();\n\nconst MyRandomUserPlugin = makeExtendSchemaPlugin((build) => {\n  const { pgSql: sql } = build;\n  return {\n    typeDefs: gql`\n      extend type Query {\n        # Individual record\n        randomUser: User\n\n        # Connection record\n        randomUsersConnection: UsersConnection\n\n        # List record\n        randomUsersList: [User!]\n      }\n    `,\n    resolvers: {\n      Query: {\n        /*\n         * Individual record needs to return just one row but\n         * `selectGraphQLResultFromTable` always returns an array; so the\n         * resolver is responsible for turning the array into a single record.\n         */\n        randomUser: async (_query, args, context, resolveInfo) => {\n          // Remember: resolveInfo.graphile.selectGraphQLResultFromTable is where the PostGraphile\n          // look-ahead magic happens!\n          const rows = await resolveInfo.graphile.selectGraphQLResultFromTable(\n            sql.fragment`app_public.users`,\n            (tableAlias, queryBuilder) => {\n              queryBuilder.orderBy(sql.fragment`random()`);\n              queryBuilder.limit(1);\n            },\n          );\n          return rows[0];\n        },\n\n        /*\n         * Connection and list resolvers are identical; PostGraphile handles\n         * the complexities for you. We\'ve simplified these down to a direct\n         * call to `selectGraphQLResultFromTable` but you may wish to wrap this\n         * with additional logic.\n         */\n        randomUsersConnection: (_query, args, context, resolveInfo) =>\n          resolveInfo.graphile.selectGraphQLResultFromTable(\n            sql.fragment`app_public.users`,\n            (tableAlias, queryBuilder) => {\n              queryBuilder.orderBy(sql.fragment`random()`);\n            },\n          ),\n        randomUsersList: (_query, args, context, resolveInfo) =>\n          resolveInfo.graphile.selectGraphQLResultFromTable(\n            sql.fragment`app_public.users`,\n            (tableAlias, queryBuilder) => {\n              queryBuilder.orderBy(sql.fragment`random()`);\n            },\n          ),\n      },\n    },\n  };\n});\n\napp.use(\n  postgraphile(process.env.DATABASE_URL, ["app_public"], {\n    graphiql: true,\n    appendPlugins: [MyRandomUserPlugin],\n  }),\n);\napp.listen(3030);\n')),(0,r.kt)("h4",{id:"mutation-example"},"Mutation Example"),(0,r.kt)("p",null,"For example, you might want to add a custom ",(0,r.kt)("inlineCode",{parentName:"p"},"registerUser")," mutation which\ninserts the new user into the database and also sends them an email:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:"{17,23-91}","{17,23-91}":!0},'const MyRegisterUserMutationPlugin = makeExtendSchemaPlugin((build) => {\n  const { pgSql: sql } = build;\n  return {\n    typeDefs: gql`\n      input RegisterUserInput {\n        name: String!\n        email: String!\n        bio: String\n      }\n\n      type RegisterUserPayload {\n        user: User @pgField\n        query: Query\n      }\n\n      extend type Mutation {\n        registerUser(input: RegisterUserInput!): RegisterUserPayload\n      }\n    `,\n    resolvers: {\n      Mutation: {\n        registerUser: async (_query, args, context, resolveInfo) => {\n          const { pgClient } = context;\n          // Start a sub-transaction\n          await pgClient.query("SAVEPOINT graphql_mutation");\n          try {\n            // Our custom logic to register the user:\n            const {\n              rows: [user],\n            } = await pgClient.query(\n              `INSERT INTO app_public.users(\n                name, email, bio\n              ) VALUES ($1, $2, $3)\n              RETURNING *`,\n              [args.input.name, args.input.email, args.input.bio],\n            );\n\n            // Now we fetch the result that the GraphQL\n            // client requested, using the new user\n            // account as the source of the data. You\n            // should always use\n            // `resolveInfo.graphile.selectGraphQLResultFromTable` if you return database\n            // data from your custom field.\n            const [row] =\n              await resolveInfo.graphile.selectGraphQLResultFromTable(\n                sql.fragment`app_public.users`,\n                (tableAlias, queryBuilder) => {\n                  queryBuilder.where(\n                    sql.fragment`${tableAlias}.id = ${sql.value(user.id)}`,\n                  );\n                },\n              );\n\n            // Finally we send the email. If this\n            // fails then we\'ll catch the error\n            // and roll back the transaction, and\n            // it will be as if the user never\n            // registered\n            await mockSendEmail(\n              args.input.email,\n              "Welcome to my site",\n              `You\'re user ${user.id} - thanks for being awesome`,\n            );\n\n            // If the return type is a database record type, like User, then\n            // you would return `row` directly. However if it\'s an indirect\n            // interface such as a connection or mutation payload then\n            // you return an object with a `data` property. You can add\n            // additional properties too, that can be used by other fields\n            // on the result type.\n            return {\n              data: row,\n              query: build.$$isQuery,\n            };\n          } catch (e) {\n            // Oh noes! If at first you don\'t succeed,\n            // destroy all evidence you ever tried.\n            await pgClient.query("ROLLBACK TO SAVEPOINT graphql_mutation");\n            throw e;\n          } finally {\n            // Release our savepoint so it doesn\'t conflict with other mutations\n            await pgClient.query("RELEASE SAVEPOINT graphql_mutation");\n          }\n        },\n      },\n    },\n  };\n});\n')),(0,r.kt)("p",null,"Note that the ",(0,r.kt)("inlineCode",{parentName:"p"},"@pgField"),' directive here is necessary for PostGraphile to "look\nahead" and determine what to request from the database.'),(0,r.kt)("h4",{id:"working-with-arrays-via-json_array_elements"},"Working with arrays via ",(0,r.kt)("inlineCode",{parentName:"h4"},"json_array_elements")),(0,r.kt)("p",null,"Here's an example of working with a join table, and bulk inserting multiple\nrecords from a GraphQL list."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'...\n\ntypeDefs: gql`\n  input UpdatePersonsThingsInput {\n    personId: UUID!,\n    thingIds: [UUID!]!\n  }\n  type UpdatePersonThingsPayload {\n    personThings: [PersonThing!]\n  }\n  extend type Mutation {\n    updatePersonsThings(input: UpdatePersonsThingsInput!): UpdatePersonsThingsPayload\n  }\n`,\nresolvers: {\n  Mutation: {\n    updatePersonsThings: async (_query, { input: { personId, thingIds } }, { pgClient }, _resolveInfo) => {\n      await pgClient.query("SAVEPOINT graphql_mutation");\n      try {\n        // Ensure proper formatting. This may not be necessary if not modifying the input\n        const elements = JSON.stringify(thingIds.map(thingId => ({ thingId, personId })));\n\n        // Bulk insert\n        const { rows } = await pgClient.query(`\n          INSERT INTO public.persons_things (person_id, thing_id)\n          SELECT\n            (el->>\'personId\')::uuid,\n            (el->>\'thingId\')::uuid\n          FROM json_array_elements($1::json) el\n          RETURNING id\n        `, [elements]);\n\n        // Return data for next layer to use\n        return { personThingIds: rows.map(({ id }) => id) };\n      } catch (e) {\n        await pgClient.query("ROLLBACK TO SAVEPOINT graphql_mutation");\n        console.error(e);\n        throw e;\n      } finally {\n        await pgClient.query("RELEASE SAVEPOINT graphql_mutation");\n      }\n    },\n  },\n  UpdatePersonThingsPayload: {\n    personThings: ({ personThingIds }, _args, _context, { graphile: { selectGraphQLResultFromTable } }) => {\n      return selectGraphQLResultFromTable(\n        sql.fragment`public.persons_things`,\n        (tableAlias, queryBuilder) => {\n          queryBuilder.where(\n            sql.fragment`${tableAlias}.id = ANY (${sql.value(personThingIds)}::int[])`\n          );\n        }\n      );\n    }\n  }\n}\n')),(0,r.kt)("h3",{id:"mutation-example-with-node-id"},"Mutation Example with Node ID"),(0,r.kt)("p",null,"In this example we'll use a GraphQL Global Object Identifier (aka Node ID) to\nsoft-delete an entry from our ",(0,r.kt)("inlineCode",{parentName:"p"},"app_public.items")," table. We're also going to\ncheck that the user performing the soft-delete is the owner of the record."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Aside"),": if you're interested in soft-deletes, check out\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/graphile-contrib/pg-omit-archived"},"@graphile-contrib/pg-omit-archived")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const DeleteItemByNodeIdPlugin = makeExtendSchemaPlugin((build) => {\n  const typeDefs = gql`\n    input DeleteItemInput {\n      nodeId: ID!\n    }\n    type DeleteItemPayload {\n      success: Boolean\n    }\n    extend type Mutation {\n      deleteItem(input: DeleteItemInput!): DeleteItemPayload\n    }\n  `;\n\n  const resolvers = {\n    Mutation: {\n      deleteItem: async (_query, args, context) => {\n        // jwtClaims is decrypted jwt token data\n        const { pgClient, jwtClaims } = context;\n\n        // Decode the node ID\n        const { Type, identifiers } = build.getTypeAndIdentifiersFromNodeId(\n          args.input.nodeId,\n        );\n\n        // Check it applies to our type\n        if (Type !== build.getTypeByName("Item")) {\n          throw new Error("Invalid nodeId for Item");\n        }\n\n        // Assuming there\'s a single primary-key column, the PK will\n        // be the first and only entry in identifiers.\n        const itemId = identifiers[0];\n\n        // All mutations that issue SQL must be wrapped in savepoints\n        await pgClient.query("SAVEPOINT graphql_mutation");\n\n        try {\n          const { rowCount } = await pgClient.query(\n            `UPDATE app_public.items SET is_archived = true\n              WHERE id = $1\n              AND user_id = $2;`,\n            [itemId, jwtClaims.user_id],\n          );\n\n          return {\n            success: rowCount === 1,\n          };\n        } catch (e) {\n          await pgClient.query("ROLLBACK TO SAVEPOINT graphql_mutation");\n          throw e;\n        } finally {\n          await pgClient.query("RELEASE SAVEPOINT graphql_mutation");\n        }\n      },\n    },\n  };\n\n  return {\n    typeDefs,\n    resolvers,\n  };\n});\n')),(0,r.kt)("h3",{id:"using-the-pgquery-directive-for-non-root-queries-and-better-performance"},"Using the ",(0,r.kt)("inlineCode",{parentName:"h3"},"@pgQuery")," directive for non-root queries and better performance"),(0,r.kt)("p",null,"If your field is not defined on the ",(0,r.kt)("inlineCode",{parentName:"p"},"Query"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"Mutation"),' type directly (i.e. it\'s\nnot defined at the root level) then for performance reasons you should hook into\nthe "look-ahead" system when adding a custom connection/list/record, rather than\nusing a resolver. You can achieve this with the ',(0,r.kt)("inlineCode",{parentName:"p"},"@pgQuery")," directive, as shown\nbelow. Alternative approaches you may wish to consider are\n",(0,r.kt)("a",{parentName:"p",href:"./smart-comments/"},"Smart Comments")," and ",(0,r.kt)("a",{parentName:"p",href:"./computed-columns/"},"Computed Columns"),"."),(0,r.kt)("h4",{id:"pgquery-with-an-object-type"},"@pgQuery with an object type"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"NOTE: this section applies to PostGraphile v4.4.0+")),(0,r.kt)("p",null,"When returning an object type (e.g. a table/composite type, connection, etc),\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"@pgQuery")," directive accepts the following inputs:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"source"),": the source of the row(s) used in the result; can be a table name,\nsubquery, or function call (but must always return the relevant table type and\nnothing more); currently this requires the boilerplate syntax below, but this\nmay be simplified in future"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"withQueryBuilder(queryBuilder, args)"),": this optional callback function is how\nyou customise which rows will be returned from the ",(0,r.kt)("inlineCode",{parentName:"li"},"source"),"; you may add\n",(0,r.kt)("inlineCode",{parentName:"li"},"where"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"orderBy"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"limit")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"offset")," constraints. The ",(0,r.kt)("inlineCode",{parentName:"li"},"args")," argument\ncontains the arguments that the field was passed, if any. This may be useful\nwhen constructing the query constraints.")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@pgQuery")," directive may be used with connections, lists of table records,\nor individual table records. (When used with individual records you must ensure\nthat at most one row is returned; you can do so with the ",(0,r.kt)("inlineCode",{parentName:"p"},"queryBuilder.limit"),"\nconstraint.) You can see examples of these three use cases\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/graphile/graphile-engine/blob/5211758b7a48191ffd7600f9f5ae572672ffd221/packages/graphile-utils/__tests__/ExtendSchemaPlugin-pg.test.js#L507-L720"},"in the tests"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const { makeExtendSchemaPlugin, gql, embed } = require("graphile-utils");\n\nmodule.exports = makeExtendSchemaPlugin((build) => {\n  const { pgSql: sql } = build;\n  return {\n    typeDefs: gql`\n      extend type User {\n        pets: PetsConnection @pgQuery(\n          source: ${embed(sql.fragment`app_public.pets`)}\n          withQueryBuilder: ${embed((queryBuilder, args) => {\n            queryBuilder.where(\n              sql.fragment`${queryBuilder.getTableAlias()}.user_id = ${queryBuilder.parentQueryBuilder.getTableAlias()}.id`,\n            );\n          })}\n        )\n      }\n    `,\n  };\n});\n')),(0,r.kt)("p",null,"Notes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"PetsConnection")," is just one type from the schema, as an example"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"queryBuilder.getTableAlias()")," refers to the ",(0,r.kt)("inlineCode",{parentName:"li"},"app_public.pets")," referenced in\nthe ",(0,r.kt)("inlineCode",{parentName:"li"},"source")," field"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"queryBuilder.parentQueryBuilder.getTableAlias()")," refers to the\ntable/function/view/etc from which the ",(0,r.kt)("inlineCode",{parentName:"li"},"User")," (the parent type) was retrieved"),(0,r.kt)("li",{parentName:"ul"},"Regular connection arguments are added automatically thanks to the plugin\nsystem")),(0,r.kt)("h4",{id:"pgquery-with-a-leaf-type"},"@pgQuery with a leaf type"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"NOTE: this section applies to PostGraphile v4.4.6+")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"BUG: it seems ",(0,r.kt)("inlineCode",{parentName:"strong"},"@pgQuery")," only supports ",(0,r.kt)("em",{parentName:"strong"},"scalars")," (not ",(0,r.kt)("em",{parentName:"strong"},"enums"),") right now:\n",(0,r.kt)("a",{parentName:"strong",href:"https://github.com/graphile/postgraphile/issues/1601"},"https://github.com/graphile/postgraphile/issues/1601"))),(0,r.kt)("p",null,"The @pgQuery directive can also be used with leaf fields (those returning a\nscalar or list thereof). To do so, we pass ",(0,r.kt)("inlineCode",{parentName:"p"},"@pgQuery")," a ",(0,r.kt)("inlineCode",{parentName:"p"},"fragment:")," argument.\nThis argument can take two forms:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"an ",(0,r.kt)("inlineCode",{parentName:"li"},"sql.fragment")),(0,r.kt)("li",{parentName:"ol"},"a function ",(0,r.kt)("inlineCode",{parentName:"li"},"f(queryBuilder, args)")," that returns a ",(0,r.kt)("inlineCode",{parentName:"li"},"sql.fragment"),".\n",(0,r.kt)("inlineCode",{parentName:"li"},"queryBuilder")," is a ",(0,r.kt)("inlineCode",{parentName:"li"},"QueryBuilder")," instance, and ",(0,r.kt)("inlineCode",{parentName:"li"},"args")," is the arguments that\nwere passed to the GraphQL field.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const { makeExtendSchemaPlugin, gql, embed } = require(\"graphile-utils\");\n\nmodule.exports = makeExtendSchemaPlugin((build) => {\n  const { pgSql: sql } = build;\n  return {\n    typeDefs: gql`\n      extend type User {\n        nameWithSuffix(suffix: String!): String! @pgQuery(\n          fragment: ${embed(\n            (queryBuilder, args) =>\n              sql.fragment`(${queryBuilder.getTableAlias()}.name || ' ' || ${sql.value(\n                args.suffix,\n              )}::text)`,\n          )}\n        )\n      }\n    `,\n  };\n});\n")),(0,r.kt)("p",null,"Notes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"queryBuilder.getTableAlias()")," refers to the table/function/view/etc from\nwhich the ",(0,r.kt)("inlineCode",{parentName:"li"},"User")," (the parent type) was retrieved"),(0,r.kt)("li",{parentName:"ul"},"there is no ",(0,r.kt)("inlineCode",{parentName:"li"},"queryBuilder.parentQueryBuilder"))),(0,r.kt)("p",null,"You can see more examples of these use cases\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/graphile/graphile-engine/blob/49259c291d651ab8b70d1f1785cf273bdd97fcf1/packages/graphile-utils/__tests__/ExtendSchemaPlugin-pg.test.js#L713-L832"},"in the tests"),"."),(0,r.kt)("h3",{id:"plugin-sql-privileges"},"Plugin SQL Privileges"),(0,r.kt)("p",null,"Plugins access the database with the same privileges as everything else - they\nare subject to RLS/RBAC/etc. If your user does not have privileges to perform\nthe action your plugin is attempting to achieve then you may need to create a\ncompanion database function that is marked as ",(0,r.kt)("inlineCode",{parentName:"p"},"SECURITY DEFINER")," in order to\nperform the action with elevated privileges; alternatively you could use this\ndatabase function directly - see ",(0,r.kt)("a",{parentName:"p",href:"./custom-mutations/"},"Custom Mutations")," for\nmore details."))}h.isMDXComponent=!0}}]);