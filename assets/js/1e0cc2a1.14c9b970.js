"use strict";(self.webpackChunk_localrepo_postgraphile_website=self.webpackChunk_localrepo_postgraphile_website||[]).push([[1465],{30876:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(n),h=r,d=p["".concat(l,".").concat(h)]||p[h]||m[h]||o;return n?a.createElement(d,i(i({ref:t},c),{},{components:n})):a.createElement(d,i({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,i[1]=s;for(var u=2;u<o;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},30647:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>u});var a=n(7896),r=(n(2784),n(30876));const o={layout:"page",path:"/postgraphile/custom-queries/",title:"Custom Queries"},i=void 0,s={unversionedId:"custom-queries",id:"custom-queries",title:"Custom Queries",description:'You can add root-level Query fields to your GraphQL schema using "Custom',source:"@site/postgraphile/custom-queries.md",sourceDirName:".",slug:"/custom-queries",permalink:"/postgraphile/next/custom-queries",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/postgraphile/website/postgraphile/custom-queries.md",tags:[],version:"current",frontMatter:{layout:"page",path:"/postgraphile/custom-queries/",title:"Custom Queries"},sidebar:"docs",previous:{title:"Computed Columns",permalink:"/postgraphile/next/computed-columns"},next:{title:"Custom Mutations",permalink:"/postgraphile/next/custom-mutations"}},l={},u=[{value:"Example",id:"example",level:3},{value:"Extending schema in JS",id:"extending-schema-in-js",level:3},{value:"Advice",id:"advice",level:3}],c={toc:u},p="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"You can add root-level ",(0,r.kt)("inlineCode",{parentName:"p"},"Query"),' fields to your GraphQL schema using "Custom\nQueries". These are PostgreSQL functions, similar to\n',(0,r.kt)("a",{parentName:"p",href:"./computed-columns/"},"computed columns"),", that can return scalars, records, lists\nor sets. Sets (denoted by ",(0,r.kt)("inlineCode",{parentName:"p"},"RETURNS SETOF ..."),") are exposed as\n",(0,r.kt)("a",{parentName:"p",href:"./connections/"},"connections")," or lists (depending on your behavior configuration). The arguments to these functions will be exposed\nvia GraphQL - named arguments are preferred, if your arguments are not named we\nwill assign them an auto-generated name such as ",(0,r.kt)("inlineCode",{parentName:"p"},"arg1"),"."),(0,r.kt)("p",null,"To create a function that PostGraphile will recognise as a custom query, it must\nobey the following rules:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"adhere to\n",(0,r.kt)("a",{parentName:"li",href:"./function-restrictions/"},"common PostGraphile function restrictions")),(0,r.kt)("li",{parentName:"ul"},"if the function accepts arguments, the first argument must NOT be a table type\n(see ",(0,r.kt)("a",{parentName:"li",href:"./computed-columns/"},"computed columns"),")"),(0,r.kt)("li",{parentName:"ul"},"must NOT return ",(0,r.kt)("inlineCode",{parentName:"li"},"VOID")),(0,r.kt)("li",{parentName:"ul"},"must be marked as ",(0,r.kt)("inlineCode",{parentName:"li"},"STABLE")," (or ",(0,r.kt)("inlineCode",{parentName:"li"},"IMMUTABLE"),", though that tends to be less\ncommon)"),(0,r.kt)("li",{parentName:"ul"},"must be defined in one of the introspected schemas")),(0,r.kt)("p",null,"For example the functions:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE FUNCTION my_function(a int, b int) RETURNS int AS $$ \u2026 $$ LANGUAGE sql IMMUTABLE;\nCREATE FUNCTION my_other_function(a int, b int) RETURNS my_table AS $$ \u2026 $$ LANGUAGE sql STABLE;\n")),(0,r.kt)("p",null,"could be queried in GraphQL like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"{\n  # For a function without arguments\n  myFunction\n\n  # For a function with arguments\n  myFunction(a: 1, b: 2)\n\n  # For a function that returns a row\n  myOtherFunction(a: 1, b: 2) {\n    id\n  }\n}\n")),(0,r.kt)("h3",{id:"example"},"Example"),(0,r.kt)("p",null,"Here we write a search query for our ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/graphile/postgraphile/tree/v4/examples/forum"},"forum example")," using the PostgreSQL\n",(0,r.kt)("a",{parentName:"p",href:"http://www.postgresql.org/docs/current/static/functions-matching.html"},(0,r.kt)("inlineCode",{parentName:"a"},"LIKE"))," operator variant, ",(0,r.kt)("inlineCode",{parentName:"p"},"ILIKE"),", which is case insensitive. The custom\nquery we create is included in the forum example\u2019s schema, so if you want to run\nthat example locally you can try it out."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql",metastring:"{10-27}","{10-27}":!0},"-- Columns unnecessary to this demo were omitted. You can find the full table in\n-- our forum example.\ncreate table post (\n  \u2026\n  headline         text not null,\n  body             text,\n  \u2026\n);\n\n-- Create the function named `search_posts` with a text argument named `search`.\n-- This will expose `Query.searchPosts(search: String!, ...)` to GraphQL.\ncreate function search_posts(search text)\n  -- This function will return a set of posts from the `post` table. The\n  -- `setof` part is important to PostGraphile, check out our Functions article\n  -- to learn why.\n  returns setof post as $$\n    -- Write our advanced query as a SQL query!\n    select *\n    from post\n    where\n      -- Use the `ILIKE` operator on both the `headline` and `body` columns. If\n      -- either return true, return the post.\n      headline ilike ('%' || search || '%') or\n      body ilike ('%' || search || '%')\n  -- End the function declaring the language we used as SQL and add the\n  -- `STABLE` marker so PostGraphile knows its a query and not a mutation.\n  $$ language sql stable;\n")),(0,r.kt)("p",null,"And that\u2019s it! You can now use this function in your GraphQL like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql",metastring:"{2}","{2}":!0},'{\n  searchPosts(search: "Hello world", first: 5) {\n    pageInfo {\n      hasNextPage\n    }\n    totalCount\n    nodes {\n      headline\n      body\n    }\n  }\n}\n')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"This function will have poor performance because ",(0,r.kt)("inlineCode",{parentName:"p"},"ILIKE"),"\nspecifications of this form (beginning and ending with ",(0,r.kt)("inlineCode",{parentName:"p"},"%"),") do not utilise\nindexes. If you're doing this in a real application then it's highly recommended\nthat you look into\n",(0,r.kt)("a",{parentName:"p",href:"http://rachbelaid.com/postgres-full-text-search-is-good-enough/"},"PostgreSQL's Full Text Search"),"\ncapabilities which can be exposed by a similar function. You may want to\n",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/11/static/functions-textsearch.html"},"check out ",(0,r.kt)("inlineCode",{parentName:"a"},"websearch_to_tsquery")," in PG11"),"\nas part of this.")),(0,r.kt)("h3",{id:"extending-schema-in-js"},"Extending schema in JS"),(0,r.kt)("p",null,"If you prefer adding to your schema on the JavaScript side, you can use\n",(0,r.kt)("a",{parentName:"p",href:"./make-extend-schema-plugin"},(0,r.kt)("inlineCode",{parentName:"a"},"makeExtendSchemaPlugin")),"."),(0,r.kt)("h3",{id:"advice"},"Advice"),(0,r.kt)("p",null,"Though it may be tempting to expose huge collections via a function, it's\nimportant to be aware that, when paginating across a function, only\n",(0,r.kt)("inlineCode",{parentName:"p"},"LIMIT/OFFSET")," pagination can be used. (For convenience and consistency we\nexpose cursor pagination over functions, but internally this is just mapped to\n",(0,r.kt)("inlineCode",{parentName:"p"},"LIMIT"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"OFFSET"),' pagination.) Because of this, and because functions are seen as\na "black box" by PostgreSQL, if you try and paginate to, say, the 100,000th\nrecord then PostgreSQL will literally have to execute the function until all\n100,000 records have been generated, and this is often expensive.'),(0,r.kt)("p",null,"One way to solve this is to have your function apply its own internal limits and\nfilters which can be exposed as GraphQL field arguments - if you reduce the\namount of data that the function can produce (e.g. to 100 rows) then it reduces\nthe potential cost of having this function in your schema."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Disclaimer"),': the information in this advice section is not 100% true, for\nexample PostgreSQL can "see through" some ',(0,r.kt)("inlineCode",{parentName:"p"},"SQL")," functions and has a highly\nintelligent query planner. If you're an expert on PostgreSQL then you should\nignore this advice and go with your own understanding, it's only intended to\nhelp beginners from shooting themselves in the foot performance-wise."))}m.isMDXComponent=!0}}]);