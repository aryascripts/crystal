"use strict";(self.webpackChunk_localrepo_postgraphile_website=self.webpackChunk_localrepo_postgraphile_website||[]).push([[6623],{30876:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>m});var a=t(2784);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(t),d=i,m=u["".concat(l,".").concat(d)]||u[d]||h[d]||r;return t?a.createElement(m,o(o({ref:n},c),{},{components:t})):a.createElement(m,o({ref:n},c))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[u]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},46637:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=t(7896),i=(t(2784),t(30876));const r={layout:"page",path:"/postgraphile/versioning-policy/",title:"Versioning Policy"},o=void 0,s={unversionedId:"versioning-policy",id:"versioning-policy",title:"Versioning Policy",description:"TL;DR: breaking changes to the GraphQL schema require a major version update.",source:"@site/postgraphile/versioning-policy.md",sourceDirName:".",slug:"/versioning-policy",permalink:"/postgraphile/next/versioning-policy",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/postgraphile/website/postgraphile/versioning-policy.md",tags:[],version:"current",frontMatter:{layout:"page",path:"/postgraphile/versioning-policy/",title:"Versioning Policy"},sidebar:"docs",previous:{title:"Why is it nullable?",permalink:"/postgraphile/next/why-nullable"}},l={},p=[{value:"Semver",id:"semver",level:2},{value:"Stable schema",id:"stable-schema",level:3},{value:"Exception: naming clashes",id:"exception-naming-clashes",level:3},{value:"Exception: schema ordering",id:"exception-schema-ordering",level:3},{value:"Exception: plugins",id:"exception-plugins",level:3},{value:"Exception: TypeScript types",id:"exception-typescript-types",level:3},{value:"Exception: unmaintained Node.js and PostgreSQL",id:"exception-unmaintained-nodejs-and-postgresql",level:3},{value:"Use a lockfile",id:"use-a-lockfile",level:2}],c={toc:p},u="wrapper";function h(e){let{components:n,...t}=e;return(0,i.kt)(u,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"TL;DR: breaking changes to the GraphQL schema require a major version update.\nBreaking changes to the plugin interface would typically require a major\nversion update, but in extremely rare cases may be included in a minor version\nupdate. TypeScript type changes may occur in patch updates, but we'll do our\nbest to keep breakage to an absolute minimum. We only support LTS versions of\nNode and Postgres, once they are no longer LTS we no longer support them."),(0,i.kt)("h2",{id:"semver"},"Semver"),(0,i.kt)("p",null,"PostGraphile (without third party plugins) follows semver: ",(0,i.kt)("inlineCode",{parentName:"p"},"major.minor.patch"),".\nSmall fixes go into a patch, nice new features go into a minor release, and\nbreaking changes would require a major release."),(0,i.kt)("h3",{id:"stable-schema"},"Stable schema"),(0,i.kt)("p",null,"PostGraphile wants to help you make maintainable GraphQL APIs, as such any\nchange that will break your existing GraphQL schema (e.g. by making something\nnullable that wasn't previously, or removing a field) would be a breaking change\nand require a major version update (e.g. 5.0.0 -> 6.0.0). To work around this,\nwe will often add configuration options (or updated presets) to opt into new\nfunctionality before it is enabled by default."),(0,i.kt)("h3",{id:"exception-naming-clashes"},"Exception: naming clashes"),(0,i.kt)("p",null,"It's possible that when we add new functionality, the name of it will clash\nwith something that you've added to your schema (since it shares the same\nnamespace). If this happens, an error will be raised and you should address it\nby either disabling the new functionality (via ",(0,i.kt)("inlineCode",{parentName:"p"},"disablePlugins")," or behaviors or\nsimilar) or by renaming one or both entities. This exception is required,\notherwise we could never add another field to the GraphQL schema without a\nmajor version bump."),(0,i.kt)("h3",{id:"exception-schema-ordering"},"Exception: schema ordering"),(0,i.kt)("p",null,"We do not see changes in the order of fields, types, enum values, directives,\netc in a GraphQL schema as a semantic difference, and thus may change them in a\npatch release. Generally we won't, because when we do we have to update our\ntests, but it might happen."),(0,i.kt)("p",null,"If you require schema entities to be in a particular order, you can enforce\nan order via a plugin, for example this plugin sorts object type fields alphabetically (which is probably not a good idea):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'// Make sure this is the last plugin to be added, and if necessary add\n// `after: [...]` to it containing a list of the names of all the plugins that\n// add fields.\nconst SortFieldsAlphabetically: GraphileConfig.Plugin = {\n  name: "SortFieldsAlphabetically",\n  version: "0.0.0",\n\n  schema: {\n    hooks: {\n      GraphQLObjectType_fields(fields) {\n        const entries = Object.entries(fields);\n        entries.sort(([a], [z]) => a.localeCompare(z, "en-US"));\n        return Object.fromEntries(entries);\n      },\n    },\n  },\n};\n')),(0,i.kt)("h3",{id:"exception-plugins"},"Exception: plugins"),(0,i.kt)("p",null,'Plugins are seen as more "experimental" than the GraphQL schema generated by\nthe built in presets. Sometimes we need to make tiny breaking changes to a\nplugin or the plugin interface in order to enable some new functionality or fix\nsome bug, if we deem that these are likely to affect less than 1% of users then\nwe might include them in a minor release (e.g. 5.0.0 -> 5.1.0). Despite this,\nbreaking changes to the plugin interface are seen as a major issue and will be\navoided as much as possible. Interfaces that are documented on the website(s)\nwill not be broken without a ',(0,i.kt)("strong",{parentName:"p"},"very good reason")," - so stick to the documented\nAPIs!"),(0,i.kt)("h3",{id:"exception-typescript-types"},"Exception: TypeScript types"),(0,i.kt)("p",null,"TypeScript is constantly changing, and our types can always be improved. Since\nPostGraphile is such a large project it wouldn't make sense to release a major\nversion every time we make a TypeScript type more accurate, and thus we exclude\nTypeScript from semver. We will do our best to avoid major issues, and in the\nunlikely event that you hit TypeScript issues when upgrading PostGraphile be\nsure to check the release notes for fixes or workarounds."),(0,i.kt)("h3",{id:"exception-unmaintained-nodejs-and-postgresql"},"Exception: unmaintained Node.js and PostgreSQL"),(0,i.kt)("p",null,"Once an LTS version of Node or PostgreSQL is no longer supported by its\nmaintainers, we may drop support for it in a patch release (although it's more\nlikely that we'd use a minor release). You may feel that this is a violation of\nsemver, but we do not (and also, even if it is, we're going to do it anyway).\nSupporting unsupported versions of Node or PostgreSQL does not make sense, no\nreasonable user should be using these unsupported versions because they may\ncontain unpatched security vulnerabilities, and since no-one should be using\nthem, dropping support for them should not be a breaking change."),(0,i.kt)("h2",{id:"use-a-lockfile"},"Use a lockfile"),(0,i.kt)("p",null,"TL;DR: use a lockfile."),(0,i.kt)("p",null,"PostGraphile will add support for wider versions of GraphQL (and other\ndependencies) over time without requiring a major or minor update. PostGraphile\ndoes not treat these as breaking changes as it's assumed that you follow Node.js\nbest practices and use a package lockfile, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"yarn.lock")," (yarn) or\n",(0,i.kt)("inlineCode",{parentName:"p"},"package-lock.json")," (npm). You can use features such as\n",(0,i.kt)("a",{parentName:"p",href:"https://yarnpkg.com/lang/en/docs/selective-version-resolutions/"},'yarn\'s "resolutions"'),"\nto pin a particular dependency (such as ",(0,i.kt)("inlineCode",{parentName:"p"},"graphql"),") to a particular version (such\nas ",(0,i.kt)("inlineCode",{parentName:"p"},"0.13.x"),")."))}h.isMDXComponent=!0}}]);