"use strict";(self.webpackChunk_localrepo_postgraphile_website=self.webpackChunk_localrepo_postgraphile_website||[]).push([[8680],{30876:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),d=r,m=u["".concat(l,".").concat(d)]||u[d]||h[d]||o;return n?a.createElement(m,i(i({ref:t},c),{},{components:n})):a.createElement(m,i({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},91968:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(7896),r=(n(2784),n(30876));const o={layout:"page",path:"/postgraphile/security/",title:"Security"},i=void 0,s={unversionedId:"security",id:"security",title:"Security",description:"Traditionally in web application architectures the security is implemented in",source:"@site/postgraphile/security.md",sourceDirName:".",slug:"/security",permalink:"/postgraphile/next/security",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/postgraphile/website/postgraphile/security.md",tags:[],version:"current",frontMatter:{layout:"page",path:"/postgraphile/security/",title:"Security"},sidebar:"docs",previous:{title:"PostgreSQL indexes",permalink:"/postgraphile/next/postgresql-indexes"},next:{title:"PostGraphile Realtime",permalink:"/postgraphile/next/realtime"}},l={},p=[{value:"Processing JWTs",id:"processing-jwts",level:3},{value:"Generating JWTs",id:"generating-jwts",level:3},{value:"Sending JWTs to the server",id:"sending-jwts-to-the-server",level:3},{value:"Sending over a websocket",id:"sending-over-a-websocket",level:4},{value:"How it works",id:"how-it-works",level:3}],c={toc:p},u="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Traditionally in web application architectures the security is implemented in\nthe server layer and the database is treated as a simple store of data. Partly\nthis was due to necessity (the security policies offered by databases such as\nPostgreSQL were simply not granular enough), and partly this was people figuring\nit would reduce the workload on the database thus increases scalability.\nHowever, as applications grow, they start needing more advanced features or\nadditional services to interact with the database. There's a couple options they\nhave here: duplicate the authentication/authorization logic in multiple places\n(which can lead to discrepancies and increases the surface area for potential\nissues), or make sure everything goes through the original application layer\n(which then becomes both the development and performance bottleneck)."),(0,r.kt)("p",null,"However, this is no longer necessary since PostgreSQL introduced much more\ngranular permissions in the form of\n",(0,r.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/current/static/ddl-rowsecurity.html"},"Row-Level Security (RLS) policies"),"\nin PostgreSQL 9.5 back at the beginning of 2016. Now you can combine this with\nPostgreSQL established permissions system (based on roles) allowing your\napplication to be considerably more specific about permissions: adding row-level\npermission constraints to the existing table- and column-based permissions."),(0,r.kt)("p",null,"Now that this functionality is stable and proven (and especially with the\nperformance improvements in the latest PostgreSQL releases), we advise that you\nprotect your lowest level - the data itself. By doing so you can be sure that no\nmatter how many services interact with your database they will all be protected\nby the same underlying permissions logic, which you only need to maintain in one\nplace. You can add as many microservices as you like, and they can talk to the\ndatabase directly!"),(0,r.kt)("p",null,"When Row Level Security (RLS) is enabled, all rows are by default not visible to\nany roles (except database administration roles and the role who created the\ndatabase/table); and permission is selectively granted with the use of policies."),(0,r.kt)("p",null,"If you already have a secure database schema that implements these technologies\nto protect your data at the lowest levels then you can leverage ",(0,r.kt)("inlineCode",{parentName:"p"},"postgraphile"),"\nto generate a powerful, secure and fast API very rapidly. You just need to\ngenerate JWT tokens for your users (and we even help you with that), or use\n",(0,r.kt)("a",{parentName:"p",href:"./usage-library/#pgsettings-function"},"pgSettings")," to indicate the current user."),(0,r.kt)("h3",{id:"processing-jwts"},"Processing JWTs"),(0,r.kt)("p",null,"To enable the JWT functionality you must provide a ",(0,r.kt)("inlineCode",{parentName:"p"},"preset.schema.pgJwtSecret"),".\nThis will allow PostGraphile to authenticate incoming JWTs and set the granted\nclaims on the database transaction."),(0,r.kt)("h3",{id:"generating-jwts"},"Generating JWTs"),(0,r.kt)("p",null,"PostGraphile also has support for generating JWTs easily from inside your\nPostgreSQL schema."),(0,r.kt)("p",null,"To do so we will take a composite type that you specify via ",(0,r.kt)("inlineCode",{parentName:"p"},"preset.gather.pgJwtTypes"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="graphile.config.mjs"',title:'"graphile.config.mjs"'},'export default {\n  gather: {\n    pgJwtTypes: "jwt_token",\n  },\n  //...\n};\n')),(0,r.kt)("p",null,"The value of this setting is a schema-name, type-name tuple. Whenever a value\nof the type identified by this tuple is returned from a PostgreSQL function we\nwill instead sign it with your JWT secret and return it as a string JWT token\nas part of your GraphQL response payload."),(0,r.kt)("p",null,"For example, you might define a composite type such as this in PostgreSQL:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"create type my_public_schema.jwt_token as (\n  role text,\n  exp integer,\n  person_id integer,\n  is_admin boolean,\n  username varchar\n);\n")),(0,r.kt)("p",null,"Then run PostGraphile with this configuration"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="graphile.config.mjs"',title:'"graphile.config.mjs"'},'import { PostGraphileAmberPreset } from "postgraphile/presets/amber";\n\nexport default {\n  extends: [PostGraphileAmberPreset],\n  gather: {\n    // highlight-next-line\n    pgJwtTypes: "my_public_schema.jwt_token",\n  },\n  schema: {\n    // highlight-next-line\n    pgJwtSecret: process.env.JWT_SECRET,\n  },\n};\n')),(0,r.kt)("p",null,"And finally you might add a PostgreSQL function such as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql",metastring:"{5}","{5}":!0},"create function my_public_schema.authenticate(\n  email text,\n  password text\n)\nreturns my_public_schema.jwt_token\nas $$\ndeclare\n  account my_private_schema.person_account;\nbegin\n  select a.* into account\n    from my_private_schema.person_account as a\n    where a.email = authenticate.email;\n\n  if account.password_hash = crypt(password, account.password_hash) then\n    return (\n      'person_role',\n      extract(epoch from now() + interval '7 days'),\n      account.person_id,\n      account.is_admin,\n      account.username\n    )::my_public_schema.jwt_token;\n  else\n    return null;\n  end if;\nend;\n$$ language plpgsql strict security definer;\n")),(0,r.kt)("p",null,"Which would give you an ",(0,r.kt)("inlineCode",{parentName:"p"},"authenticate")," mutation with which you can extract the\n",(0,r.kt)("inlineCode",{parentName:"p"},"jwtToken")," from the response payload."),(0,r.kt)("h3",{id:"sending-jwts-to-the-server"},"Sending JWTs to the server"),(0,r.kt)("p",null,"JWTs are sent via the best practice ",(0,r.kt)("inlineCode",{parentName:"p"},"Authorization")," header:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Authorization: Bearer JWT_TOKEN_HERE\n")),(0,r.kt)("p",null,"e.g.\n",(0,r.kt)("a",{parentName:"p",href:"https://www.apollographql.com/docs/react/networking/authentication/#header"},"with Apollo"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:"{7,13}","{7,13}":!0},'const httpLink = createHttpLink({\n  uri: "/graphql",\n});\n\nconst authLink = setContext((_, { headers }) => {\n  // get the authentication token from wherever you store it\n  const token = getJWTToken();\n  // return the headers to the context so httpLink can read them\n  return {\n    headers: {\n      ...headers,\n      // Only pass the authorization header if we have a JWT\n      ...(token ? { authorization: `Bearer ${token}` } : null),\n    },\n  };\n});\n\nconst client = new ApolloClient({\n  link: authLink.concat(httpLink),\n  cache: new InMemoryCache(),\n});\n')),(0,r.kt)("p",null,"or ",(0,r.kt)("a",{parentName:"p",href:"https://relay.dev/docs/guides/network-layer/"},"with Relay")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:"{3,8}","{3,8}":!0},"function fetchQuery( operation, variables, cacheConfig, uploadables) {\n  // get the authentication token from wherever you store it\n  const token = getJWTToken();\n  return fetch('/graphql', {\n    method: 'POST',\n    headers: {\n      'content-type': 'application/json'\n      authorization: token ? `Bearer ${token}` : \"\",\n    },\n    body: JSON.stringify({\n      query: operation.text, // GraphQL text from input\n      variables,\n    }),\n  }).then(response => {\n    return response.json();\n  });\n}\n\nconst environment = new Environment({\n  network: Network.create(fetchQuery),\n  store: new Store(new RecordSource()),\n});\n")),(0,r.kt)("h4",{id:"sending-over-a-websocket"},"Sending over a websocket"),(0,r.kt)("p",null,"If you are using Apollo:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js",metastring:"{5,10}","{5,10}":!0},'// get the authentication token from wherever you store it\nconst token = getJWTToken();\n\nconst wsLink = new WebSocketLink({\n  uri: "ws://localhost:3000/graphql",\n  options: {\n    reconnect: true,\n    connectionParams: token\n      ? {\n          authorization: `Bearer ${token}`,\n        }\n      : {},\n  },\n});\n')),(0,r.kt)("h3",{id:"how-it-works"},"How it works"),(0,r.kt)("p",null,"Your JWT token will include a number of claims, something like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "aud": "postgraphile",\n  "role": "app_user",\n  "user_id": 27\n}\n')),(0,r.kt)("p",null,"When we verify that the JWT token is for us (via ",(0,r.kt)("inlineCode",{parentName:"p"},'aud: "postgraphile"'),") we can\nauthenticate the PostgreSQL client that is used to perform the GraphQL query.\nThe PostgreSQL adaptor might use something like this to achieve this goal:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"begin;\nset local role app_user;\nset local jwt.claims.role to 'app_user';\nset local jwt.claims.user_id to '2';\n\n-- PERFORM GRAPHQL QUERIES HERE\n\ncommit;\n")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"To save roundtrips, many adaptors perform just one query to set all configs via:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select set_config('role', 'app_user', true), set_config('user_id', '2', true), ...\n")),(0,r.kt)("p",{parentName:"admonition"},"but showing ",(0,r.kt)("inlineCode",{parentName:"p"},"set local")," is simpler to understand.")),(0,r.kt)("p",null,"You can then access this information via ",(0,r.kt)("inlineCode",{parentName:"p"},"current_setting")," (the second argument\nsays it's okay for the property to be missing); for example here's a helper\nfunction:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"create function current_user_id() returns integer as $$\n  select nullif(current_setting('jwt.claims.user_id', true), '')::integer;\n$$ language sql stable;\n")),(0,r.kt)("p",null,"e.g. you might have a row level policy such as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'create policy update_if_author\n  on comments\n  for update\n  using ("userId" = current_user_id())\n  with check ("userId" = current_user_id());\n')))}h.isMDXComponent=!0}}]);