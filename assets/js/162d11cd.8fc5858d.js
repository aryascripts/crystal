"use strict";(self.webpackChunk_localrepo_grafast_website=self.webpackChunk_localrepo_grafast_website||[]).push([[3395],{30876:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(2784);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=p(n),c=i,h=u["".concat(l,".").concat(c)]||u[c]||m[c]||o;return n?a.createElement(h,r(r({ref:t},d),{},{components:n})):a.createElement(h,r({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:i,r[1]=s;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},96957:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(7896),i=(n(2784),n(30876));const o={sidebar_position:7},r="Step classes",s={unversionedId:"step-classes",id:"step-classes",title:"Step classes",description:"A step details a particular action or transform that needs to be performed when",source:"@site/grafast/step-classes.md",sourceDirName:".",slug:"/step-classes",permalink:"/grafast/step-classes",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/grafast/website/grafast/step-classes.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"withPgClient and withPgClientTransaction",permalink:"/grafast/step-library/dataplan-pg/withPgClient"},next:{title:"Request overview",permalink:"/grafast/request-overview"}},l={},p=[{value:"Built in methods",id:"built-in-methods",level:2},{value:"addDependency",id:"adddependency",level:3},{value:"addUnaryDependency",id:"addunarydependency",level:3},{value:"getDep",id:"getdep",level:3},{value:"getDepDeep",id:"getdepdeep",level:3},{value:"toString",id:"tostring",level:3},{value:"toStringMeta",id:"tostringmeta",level:3},{value:"Lifecycle methods",id:"lifecycle-methods",level:2},{value:"execute",id:"execute",level:3},{value:"Example",id:"example",level:4},{value:"stream",id:"stream",level:3},{value:"deduplicate",id:"deduplicate",level:3},{value:"deduplicatedWith",id:"deduplicatedwith",level:3},{value:"optimize",id:"optimize",level:3},{value:"Optimize: inlining",id:"optimize-inlining",level:4},{value:"Optimize: planning-time only steps",id:"optimize-planning-time-only-steps",level:4},{value:"Optimize: simplification",id:"optimize-simplification",level:4},{value:"finalize",id:"finalize",level:3},{value:"Other properties",id:"other-properties",level:2},{value:"id",id:"id",level:3},{value:"hasSideEffects",id:"hassideeffects",level:3},{value:"isSyncAndSafe",id:"issyncandsafe",level:3},{value:"isOptimized",id:"isoptimized",level:3},{value:"allowMultipleOptimizations",id:"allowmultipleoptimizations",level:3},{value:"metaKey",id:"metakey",level:3},{value:"Step function",id:"step-function",level:2}],d={toc:p},u="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"step-classes"},"Step classes"),(0,i.kt)("p",null,"A step details a particular action or transform that needs to be performed when\nexecuting a GraphQL request. Each step is an instance of a specific ",(0,i.kt)("em",{parentName:"p"},"step\nclass"),", produced during the planning of a field. Each step may depend on 0 or\nmore other steps, and through these dependencies ultimately form a directed\nacyclic graph which we refer to as the ",(0,i.kt)("em",{parentName:"p"},"execution plan"),". Thus the steps are the\nbuilding blocks of an execution plan."),(0,i.kt)("p",null,"A modest range of ",(0,i.kt)("a",{parentName:"p",href:"/grafast/step-library/standard-steps/"},"standard step classes")," are available for you\nto use; but when these aren't enough you are encouraged to write your own (or\npull down third party step classes from npm or similar)."),(0,i.kt)("p",null,"Step classes extend the ",(0,i.kt)("inlineCode",{parentName:"p"},"ExecutableStep")," class, the only required method to\ndefine is ",(0,i.kt)("inlineCode",{parentName:"p"},"execute"),", but you may also implement the various lifecycle methods,\nor add methods of your own to make it easier for you to write ",(0,i.kt)("a",{parentName:"p",href:"./plan-resolvers"},"plan\nresolvers"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"/** XKCD-221 step class @ref https://xkcd.com/221/ */\nclass GetRandomNumberStep extends ExecutableStep {\n  execute({ count }) {\n    return new Array(count).fill(4); // chosen by fair dice roll.\n                                     // guaranteed to be random.\n  }\n}\n\nfunction getRandomNumber() {\n  return new GetRandomNumberStep();\n}\n")),(0,i.kt)("admonition",{title:"Use prefixes on custom fields/methods.",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"If you add any custom fields or methods to your step classes we recommend that\nyou prefix them with your initials or organization name to avoid naming\nconflicts occurring.")),(0,i.kt)("admonition",{title:"Don't subclass steps.",type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"Don't subclass steps, this will make things very confusing for you. Always\ninherit directly from ",(0,i.kt)("inlineCode",{parentName:"p"},"ExecutableStep"),".")),(0,i.kt)("h2",{id:"built-in-methods"},"Built in methods"),(0,i.kt)("p",null,"Your custom step class will have access to all the built-in methods that come\nas part of ",(0,i.kt)("inlineCode",{parentName:"p"},"ExecutableStep"),"."),(0,i.kt)("h3",{id:"adddependency"},"addDependency"),(0,i.kt)("p",null,"When your step requires another step's value in order to execute (which is the\ncase for the majority of steps!) it must add a dependency via the\n",(0,i.kt)("inlineCode",{parentName:"p"},"this.addDependency($otherStep)")," method. This method will return a number,\nwhich is the index in the ",(0,i.kt)("inlineCode",{parentName:"p"},"execute")," values tuple that represents this step."),(0,i.kt)("p",null,"It's common to do this in the constructor, but it can be done at other stages\ntoo, for example during the optimize phase a step's descendent might ask it to\ndo additional work, and that work might depend on another step."),(0,i.kt)("p",null,"In the ",(0,i.kt)("a",{parentName:"p",href:"./getting-started"},"getting started")," guide we saw the constructor for the ",(0,i.kt)("inlineCode",{parentName:"p"},"AddStep")," step\nclass added two dependencies:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class AddStep extends ExecutableStep {\n  constructor($a, $b) {\n    super();\n    this.addDependency($a); // Returns 0\n    this.addDependency($b); // Returns 1\n  }\n")),(0,i.kt)("admonition",{title:"Steps are ethemeral, never store a reference to a step.",type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"You must never store a reference to another step directly (or indirectly) in\nyour step class. Steps come and go at quite a rate during planning - being\nremoved due to deduplicate, optimize, or tree shaking lifecycle events.\nReferring to a step that no longer exists is likely to make your program have\nvery unexpected behaviors and/or crash."),(0,i.kt)("p",{parentName:"admonition"},"In the exceedingly unlikely event that you need to reference another step but it\nis not a dependency, use its ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," â”€ you can then look up the step associated\nwith that ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," at a later time; if it exists it may be different to the step you\nremember, but it should serve the same purpose. However, it may have been\ndeleted due to tree shaking - if this causes a problem, then maybe that step\nshould have been a dependency after all?")),(0,i.kt)("h3",{id:"addunarydependency"},"addUnaryDependency"),(0,i.kt)("p",null,"Sometimes you'll want to ensure that one or more of the steps your step class\ndepends on will have exactly one value at runtime; to do so, you can use\n",(0,i.kt)("inlineCode",{parentName:"p"},"this.addUnaryDependency($step)")," rather than ",(0,i.kt)("inlineCode",{parentName:"p"},"this.addDependency($step)"),". This\nasserts that the given dependency is a ",(0,i.kt)("strong",{parentName:"p"},"unary step")," (a regular step which the\nsystem has determined will always represent exactly one value) and is primarily\nuseful when a parameter to a remote service request needs to be the same for\nall entries in the batch; typically this will be the case for ordering,\npagination and access control."),(0,i.kt)("admonition",{title:"Use with caution.",type:"warning"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"this.addUnaryDependency($step)")," will raise an error during planning if the\ngiven ",(0,i.kt)("inlineCode",{parentName:"p"},"$step")," is not unary, so you should be very careful using it. If in\ndoubt, use ",(0,i.kt)("inlineCode",{parentName:"p"},"this.addDependency($step)")," instead."),(0,i.kt)("p",{parentName:"admonition"},"The system steps which represent requestâ€“level data (e.g. context, variable and\nargument values) are always unary steps, and ","â€‹",(0,i.kt)("grafast",null)," will\nautomatically determine which other steps are also unary steps."),(0,i.kt)("p",{parentName:"admonition"},"It's generally intended for ",(0,i.kt)("inlineCode",{parentName:"p"},"addUnaryDependency")," to be used for arguments and\ntheir derivatives; it can also be used with ",(0,i.kt)("inlineCode",{parentName:"p"},"context"),"-derived values, but there\nis complexity when it comes to mutations since ",(0,i.kt)("inlineCode",{parentName:"p"},"context")," is mutable (whereas\ninput values are not).")),(0,i.kt)("h3",{id:"getdep"},"getDep"),(0,i.kt)("p",null,"Pass in the number of the dependency (",(0,i.kt)("inlineCode",{parentName:"p"},"0")," for the first dependency, ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," for the\nsecond, and so on) and Grafast will return the corresponding step. This should\nonly be used before or during the ",(0,i.kt)("inlineCode",{parentName:"p"},"optimize")," phase."),(0,i.kt)("p",null,"For example in the ",(0,i.kt)("inlineCode",{parentName:"p"},"AddStep")," example above we might have:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const $a = this.getDep(0);\nconst $b = this.getDep(1);\n")),(0,i.kt)("h3",{id:"getdepdeep"},"getDepDeep"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"EXPERIMENTAL")),(0,i.kt)("p",null,"Like ",(0,i.kt)("inlineCode",{parentName:"p"},"getDep"),", but skips over ",(0,i.kt)("inlineCode",{parentName:"p"},"__ItemStep"),' and similar builtin intermediary\nsteps to try and get to the original source. Typically useful if you have a\nstep representing an entry from a collection (e.g. a database "row") and you\nwant to get the step representing the entire collection (e.g. a database\n',(0,i.kt)("inlineCode",{parentName:"p"},"SELECT")," statement)."),(0,i.kt)("h3",{id:"tostring"},"toString"),(0,i.kt)("p",null,"Pretty formatting for the step."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'console.log("$a = " + $a.toString());\n')),(0,i.kt)("h3",{id:"tostringmeta"},"toStringMeta"),(0,i.kt)("p",null,"You may override this to add additional data to the ",(0,i.kt)("inlineCode",{parentName:"p"},"toString")," method (the data\nthat would occur between the triangular brackets)."),(0,i.kt)("h2",{id:"lifecycle-methods"},"Lifecycle methods"),(0,i.kt)("h3",{id:"execute"},"execute"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"execute(details: ExecutionDetails): PromiseOrDirect<GrafastResultsList>\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// These are simplified types\ninterface ExecutionDetails {\n  count: number;\n  values: [...ExecutionValue[]];\n  indexMap<T>(callback: (i: number) => T): ReadonlyArray<T>;\n  indexForEach(callback: (i: number) => any): void;\n  extra: ExecutionExtra;\n}\n\ntype ExecutionValue<TData> =\n  | { at(i: number): TData; isBatch: true; entries: ReadonlyArray<TData> }\n  | { at(i: number): TData; isBatch: false; value: TData };\n\ntype GrafastResultsList<T> = ReadonlyArray<PromiseOrDirect<T>>;\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"execute")," is the one method that your step class must define, and it has very\nstrict rules."),(0,i.kt)("p",null,'It is passed one argument, the "execution details", which is an object containing:'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"count")," â€” the size of the batch being processed (and thus the length of the list that must be returned)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"values"),' â€” the "values tuple", an n-tuple (a tuple with ',(0,i.kt)("inlineCode",{parentName:"li"},"n")," entries), where\n",(0,i.kt)("inlineCode",{parentName:"li"},"n"),' is the number of dependencies the step has. Each of the entries in the\ntuple will be an "execution value" containing the data that relates to the\ncorresponding dependency'),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"indexMap(callback)")," - a helper function that builds an array of length\n",(0,i.kt)("inlineCode",{parentName:"li"},"count")," by calling ",(0,i.kt)("inlineCode",{parentName:"li"},"callback")," for each index in the batch (from ",(0,i.kt)("inlineCode",{parentName:"li"},"0")," to\n",(0,i.kt)("inlineCode",{parentName:"li"},"count-1"),"); equivalent to ",(0,i.kt)("inlineCode",{parentName:"li"},"Array.from({ length: count }, (_, i) => callback(i))")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"indexForEach(callback)")," - a helper function that calls ",(0,i.kt)("inlineCode",{parentName:"li"},"callback")," for each\nindex in the batch (from ",(0,i.kt)("inlineCode",{parentName:"li"},"0")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"count-1"),") but does not return anything"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"extra")," â€” currently experimental, use it at your own risk (and see the source\nfor documentation)")),(0,i.kt)("p",null,'An "execution value", ',(0,i.kt)("inlineCode",{parentName:"p"},"dep"),', is an object containing the data for a given\ndependency. It will either be a "batch" value (',(0,i.kt)("inlineCode",{parentName:"p"},"dep.isBatch === true"),") in which\ncase ",(0,i.kt)("inlineCode",{parentName:"p"},"dep.entries")," will be an array containing ",(0,i.kt)("inlineCode",{parentName:"p"},"count"),' entries (the order of\nwhich is significant), or it will be a "unary" value (',(0,i.kt)("inlineCode",{parentName:"p"},"dep.isBatch === false"),")\nin which case ",(0,i.kt)("inlineCode",{parentName:"p"},"dep.value")," will be the common value for this dependency across\nall entries in the batch. Either way, ",(0,i.kt)("inlineCode",{parentName:"p"},"dep.at(i)")," will return the value for\nthis dependency corresponding with the i'th entry in the batch (",(0,i.kt)("inlineCode",{parentName:"p"},"dep.at(i)")," is\nequivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"dep.isBatch ? dep.entries[i] : dep.value"),")."),(0,i.kt)("p",null,"Execute must return a list (or a promise to a list) of size ",(0,i.kt)("inlineCode",{parentName:"p"},"count"),", where the\ni'th entry in this list corresponds to the ",(0,i.kt)("inlineCode",{parentName:"p"},"dep.at(i)")," value for each ",(0,i.kt)("inlineCode",{parentName:"p"},"dep"),' in\nthe "values tuple". The result of ',(0,i.kt)("inlineCode",{parentName:"p"},"execute")," may or may not be a promise, and\neach entry in the resulting list may or may not be a promise."),(0,i.kt)("admonition",{title:"If your step has no dependencies",type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"If the step has no dependencies then ",(0,i.kt)("inlineCode",{parentName:"p"},"values")," will be a 0-tuple (an empty\ntuple), but that doesn't mean the batch is empty or has size one, ",(0,i.kt)("inlineCode",{parentName:"p"},"count")," may\nbe any positive integer. It's therefore recommended that you use ",(0,i.kt)("inlineCode",{parentName:"p"},"indexMap")," to\ngenerate your results in the vast majority of cases:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"return indexMap((i) => 42);\n"))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"You might wonder why the ",(0,i.kt)("inlineCode",{parentName:"p"},"values")," input is a tuple of execution values, rather\nthan a list of tuples. The reason comes down to efficiency, by using a tuple of\nexecution values, ",(0,i.kt)("grafast",null)," only needs to build one new array (the tuple),\nand into that array it can insert the results from previously executed steps\nunmodified. Were it to provide a list of tuples instead then it would need to\nbuild N+1 new arrays, where N was the number of values being processed, which\ncan easily be in the thousands.")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"If you want one of your entries to throw an error, but the others shouldn't,\nthen an easy way to achieve this is to set the corresponding entry in the\nresults list to ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise.reject(new Error(...))"),". You can do this even if you\ndon't use promises for any of the other values, and even if your ",(0,i.kt)("inlineCode",{parentName:"p"},"execute"),"\nmethod is not marked as ",(0,i.kt)("inlineCode",{parentName:"p"},"async"),". You ",(0,i.kt)("strong",{parentName:"p"},"must not")," do this if you have marked\nyour step class with ",(0,i.kt)("inlineCode",{parentName:"p"},"isSyncAndSafe = true"),".")),(0,i.kt)("h4",{id:"example"},"Example"),(0,i.kt)("p",null,"In the ",(0,i.kt)("a",{parentName:"p",href:"./getting-started"},"getting started")," guide we built an ",(0,i.kt)("inlineCode",{parentName:"p"},"AddStep")," step class that adds two\nnumbers together. It's ",(0,i.kt)("inlineCode",{parentName:"p"},"execute")," method looked like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"  execute({ indexMap, values: [aDep, bDep] }) {\n    return indexMap((i) => {\n      const a = aDep.at(i);\n      const b = bDep.at(i);\n      return a + b;\n    });\n  }\n")),(0,i.kt)("p",null,"Imagine at runtime ",(0,i.kt)("grafast",null)," needed to execute this operation for three\n(",(0,i.kt)("inlineCode",{parentName:"p"},"count = 3"),") pairs of values: ",(0,i.kt)("inlineCode",{parentName:"p"},"[1, 2]"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"[3, 4]")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"[5, 6]"),". The values for\n",(0,i.kt)("inlineCode",{parentName:"p"},"$a")," accessible through ",(0,i.kt)("inlineCode",{parentName:"p"},"aDep.get(i)")," would be ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"3")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"5"),"; and the values\nfor ",(0,i.kt)("inlineCode",{parentName:"p"},"$b")," accessible through ",(0,i.kt)("inlineCode",{parentName:"p"},"bDep.get(i)")," would be ",(0,i.kt)("inlineCode",{parentName:"p"},"2"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"4")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"6"),". The\nexecute method then returns the same number of results in the same order: ",(0,i.kt)("inlineCode",{parentName:"p"},"[3,\n7, 11]"),"."),(0,i.kt)("h3",{id:"stream"},"stream"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"This method is optional.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"stream(details: StreamDetails): PromiseOrDirect<GrafastResultStreamList>\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"interface StreamDetails extends ExecutionDetails {\n  streamOptions: {\n    initialCount: number;\n  };\n}\n\ntype GrafastResultStreamList<T> = ReadonlyArray<\n  PromiseOrDirect<AsyncIterable<PromiseOrDirect<T>> | null>\n>;\n")),(0,i.kt)("p",null,"TODO: document stream. (It's like execute, except it returns a list of async iterators.)"),(0,i.kt)("h3",{id:"deduplicate"},"deduplicate"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"This method is optional.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"deduplicate(\n  peers: readonly ExecutableStep[]\n): readonly ExecutableStep[]\n")),(0,i.kt)("p",null,"After a field has been fully planned, ",(0,i.kt)("grafast",null),' will call this method on each\nnew step when more than one step exists in the draft execution plan with the\nsame step class and the same dependencies. These "peers" (including the step\nitself) will be passed in to the deduplicate method, and this method should\nreturn the list of the peers that are equivalent (or could cheaply be made\nequivalent) to the current step.'),(0,i.kt)("p",null,"To cause your step class to never be deduplicated, either don't implement this\nmethod or simply ",(0,i.kt)("inlineCode",{parentName:"p"},"return [];"),"."),(0,i.kt)("p",null,"You should not mutate your peers or yourself during this method, instead use\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"deduplicatedWith")," method to apply side-effects."),(0,i.kt)("h3",{id:"deduplicatedwith"},"deduplicatedWith"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"This method is optional.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"deduplicatedWith(\n  replacement: ExecutableStep\n): void\n")),(0,i.kt)("p",null,"If ",(0,i.kt)("grafast",null)," determines that this specific step instance should be replaced\nby one of its peers (thanks to the results from ",(0,i.kt)("inlineCode",{parentName:"p"},"deduplicate")," above), ",(0,i.kt)("grafast",null)," will call ",(0,i.kt)("inlineCode",{parentName:"p"},"deduplicatedWith")," on the step that is being replaced, passing the\nstep that it is being replaced with as the first argument. This gives your step\na chance to pass any information to the peer that may be necessary to make the\npeers equivalent."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"It's rare to need this functionality, so let's work through a hypothetical."),(0,i.kt)("p",{parentName:"admonition"},"Imagine step ",(0,i.kt)("inlineCode",{parentName:"p"},"$select1")," represents the SQL query ",(0,i.kt)("inlineCode",{parentName:"p"},"SELECT id, name FROM users"),"\nand step ",(0,i.kt)("inlineCode",{parentName:"p"},"$select2")," represents ",(0,i.kt)("inlineCode",{parentName:"p"},"SELECT id, avatar_url FROM users"),"."),(0,i.kt)("p",{parentName:"admonition"},"Lets further imagine that we've optimised our SQL handling step classes such\nthat both ",(0,i.kt)("inlineCode",{parentName:"p"},"$select1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"$select2")," return ",(0,i.kt)("inlineCode",{parentName:"p"},"[$select1, $select2]")," from their\n",(0,i.kt)("inlineCode",{parentName:"p"},"deduplicate"),' method (because they can "cheaply" be made equivalent).'),(0,i.kt)("p",{parentName:"admonition"},"Assuming ",(0,i.kt)("grafast",null)," chooses to keep ",(0,i.kt)("inlineCode",{parentName:"p"},"$select1"),' and\n"deduplicate" (get rid of) ',(0,i.kt)("inlineCode",{parentName:"p"},"$select2"),", ",(0,i.kt)("grafast",null)," would then call\n",(0,i.kt)("inlineCode",{parentName:"p"},"$select2.deduplicateWith($select1)"),". This would give ",(0,i.kt)("inlineCode",{parentName:"p"},"$select2")," a chance to\ninform ",(0,i.kt)("inlineCode",{parentName:"p"},"$select1")," that in order to be completely equivalent, it must also\nselect ",(0,i.kt)("inlineCode",{parentName:"p"},"avatar_url"),"."),(0,i.kt)("p",{parentName:"admonition"},"In this scenario, at the end of deduplication, only ",(0,i.kt)("inlineCode",{parentName:"p"},"$select1")," would remain and\nit would represent the SQL query ",(0,i.kt)("inlineCode",{parentName:"p"},"SELECT id, name, avatar_url FROM users"),".")),(0,i.kt)("h3",{id:"optimize"},"optimize"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"This method is optional.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"optimize(\n  options: { stream: StepStreamOptions | null }\n): ExecutableStep\n")),(0,i.kt)("p",null,"This method is called on each step during the optimize lifecycle event. It\ngives the step a chance to request that its ancestors do additional work,\nand/or replace itself with another step (new or old). If it does not want\nto be replaced, it can simply return itself: ",(0,i.kt)("inlineCode",{parentName:"p"},"return this;"),"."),(0,i.kt)("p",null,"This one method unlocks a significant proportion of ",(0,i.kt)("grafast",null),"'s efficiency\nimprovements. Here are some common use cases that it can be used for:"),(0,i.kt)("h4",{id:"optimize-inlining"},"Optimize: inlining"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"optimize"),' is often useful for "inlining" the requirements of this step into an\nancestor and then (optionally) replacing itself with a simple ',(0,i.kt)("inlineCode",{parentName:"p"},"access")," or\n",(0,i.kt)("inlineCode",{parentName:"p"},"remapKeys")," step. This reduces the number of asynchronous tasks the request\nneeds to execute and can enable significantly more efficient data fetching."),(0,i.kt)("h4",{id:"optimize-planning-time-only-steps"},"Optimize: planning-time only steps"),(0,i.kt)("p",null,"Another use case for ",(0,i.kt)("inlineCode",{parentName:"p"},"optimize"),' is to make planning-time only steps "evaporate"\nby replacing them with their parent or a different step.'),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"loadMany")," step represents each record via a ",(0,i.kt)("inlineCode",{parentName:"p"},"LoadedRecordStep")," instance\nwhich can be used to ",(0,i.kt)("inlineCode",{parentName:"p"},".get(attr)")," a named attribute. This reference is then\nstored, and at optimize time the ",(0,i.kt)("inlineCode",{parentName:"p"},"LoadedRecordStep")," can tell the ",(0,i.kt)("inlineCode",{parentName:"p"},"LoadStep")," to\nrequest this attribute (so that the ",(0,i.kt)("inlineCode",{parentName:"p"},"loadMany")," callback doesn't need to do the\nequivalent of ",(0,i.kt)("inlineCode",{parentName:"p"},"SELECT *")," - it can be more selective). However, since\n",(0,i.kt)("inlineCode",{parentName:"p"},"LoadedRecordStep")," has no run-time behavior (only planning-time behavior) it\ncan simply replace itself during ",(0,i.kt)("inlineCode",{parentName:"p"},"optimize")," with its parent step (typically an\n",(0,i.kt)("inlineCode",{parentName:"p"},"__ItemStep"),")."),(0,i.kt)("p",null,"The builtin ",(0,i.kt)("inlineCode",{parentName:"p"},"each")," step uses ",(0,i.kt)("inlineCode",{parentName:"p"},"optimize")," to replace itself with the underlying\nlist where possible."),(0,i.kt)("h4",{id:"optimize-simplification"},"Optimize: simplification"),(0,i.kt)("p",null,"Another use case is simplification."),(0,i.kt)("p",null,"For example the step representing ",(0,i.kt)("inlineCode",{parentName:"p"},"access(access(access($a, 'b'), 'c'), 'd')"),"\ncould be simplified down to just ",(0,i.kt)("inlineCode",{parentName:"p"},"access($a, ['b', 'c', 'd'])"),", reducing the\nnumber of steps in the operation plan."),(0,i.kt)("p",null,"Similarly ",(0,i.kt)("inlineCode",{parentName:"p"},"first(list([$a, $b]))")," can be simplified to just ",(0,i.kt)("inlineCode",{parentName:"p"},"$a"),"."),(0,i.kt)("h3",{id:"finalize"},"finalize"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"This method is optional.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"finalize(): void\n")),(0,i.kt)("p",null,"This method is called on each step during the finalize lifecycle event. It gives\neach step a chance to prepare for execution, doing anything that needs to be\ndone just once. A step that deals with a database might precompile its SQL, a\nstep that transforms an object might build an optimized function to do so, there\nare so many other actions that this step can be used for."),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"It is critical that the step calls ",(0,i.kt)("inlineCode",{parentName:"p"},"super.finalize()")," at the end of the\n",(0,i.kt)("inlineCode",{parentName:"p"},"finalize()")," step:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"finalize() {\n  // ... your code here ...\n\n  super.finalize();\n}\n"))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Importantly during this step the step should only worry about its own concerns\nand should not attempt to communicate with its ancestors or descendents - they\nmay not be the steps that it remembers as they may have been switched out\nduring ",(0,i.kt)("inlineCode",{parentName:"p"},"optimize"),"! If the step needs to communicate with its ancestors it\nshould use the ",(0,i.kt)("inlineCode",{parentName:"p"},"optimize")," method to do so.")),(0,i.kt)("h2",{id:"other-properties"},"Other properties"),(0,i.kt)("h3",{id:"id"},"id"),(0,i.kt)("p",null,"Every step is assigned a unique id by ",(0,i.kt)("grafast",null),". This id may be a string, number,\nor symbol - treat it as opaque."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Currently this value is a ",(0,i.kt)("inlineCode",{parentName:"p"},"number"),", but ",(0,i.kt)("grafast",null)," may change it to be a string or\nsymbol in a minor release so you should not rely on its data type. You may,\nhowever, rely on ",(0,i.kt)("inlineCode",{parentName:"p"},"String(id)")," being unique across an operation plan.")),(0,i.kt)("h3",{id:"hassideeffects"},"hasSideEffects"),(0,i.kt)("p",null,"Set this true if the step has side effects (i.e. causes a mutation) - if this\nis true then Gra",(0,i.kt)("em",{parentName:"p"},"fast")," will ",(0,i.kt)("em",{parentName:"p"},"not")," remove this step during tree shaking, and\nwill ensure that the step is executed even if it doesn't appear to be used in\nany output."),(0,i.kt)("h3",{id:"issyncandsafe"},"isSyncAndSafe"),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"This is a very dangerous optimization, only use it if you're 100% sure you know\nwhat you are doing!")),(0,i.kt)("p",null,"Setting this true is a performance optimization, but it comes with strong rules;\nwe do not test you comply with these rules (as that would undo the performance\ngains) but should you break them the behaviour is undefined (and, basically, the\nschema may no longer be GraphQL compliant)."),(0,i.kt)("p",null,"Do not set this true unless the following hold:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"execute")," method must be a regular (not async) function"),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"execute")," method must NEVER return a promise"),(0,i.kt)("li",{parentName:"ul"},"The values within the list returned from ",(0,i.kt)("inlineCode",{parentName:"li"},"execute")," must NEVER include promises"),(0,i.kt)("li",{parentName:"ul"},"The result of calling ",(0,i.kt)("inlineCode",{parentName:"li"},"execute")," should not differ after a\n",(0,i.kt)("inlineCode",{parentName:"li"},"step.hasSideEffects")," has executed (i.e. it should be pure, only dependent on\nits deps and use no external state)")),(0,i.kt)("p",null,"It's acceptable for the ",(0,i.kt)("inlineCode",{parentName:"p"},"execute")," method to throw if it needs to."),(0,i.kt)("p",null,"This optimisation applies to the majority of the built in plans and allows the\nengine to execute without needing to resolve any promises which saves precious\nevent-loop ticks."),(0,i.kt)("h3",{id:"isoptimized"},"isOptimized"),(0,i.kt)("p",null,"This is set ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," after the step has been optimized."),(0,i.kt)("h3",{id:"allowmultipleoptimizations"},"allowMultipleOptimizations"),(0,i.kt)("p",null,"Set this true if your plan's optimize method can be called a second time."),(0,i.kt)("admonition",{title:"Your dependencies may change classes!",type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"In this situation it's likely that your dependencies (or their dependencies)\nwill not be what you expect them to be (e.g. a ",(0,i.kt)("inlineCode",{parentName:"p"},"PgSelectSingleStep")," might\nbecome an ",(0,i.kt)("inlineCode",{parentName:"p"},"AccessStep")," due to having been optimized). This, and the fact\nthat it's rarely needed, is why it's not enabled by default.")),(0,i.kt)("h3",{id:"metakey"},"metaKey"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"EXPERIMENTAL")),(0,i.kt)("p",null,"You may optionally set this to indicate a key to use for which ",(0,i.kt)("inlineCode",{parentName:"p"},"meta")," object to\nbe passed in to ",(0,i.kt)("inlineCode",{parentName:"p"},"execute")," (typically used for caching). To make it unique to\nthe instance of your step, in the constructor after calling ",(0,i.kt)("inlineCode",{parentName:"p"},"super()"),", set it\nas ",(0,i.kt)("inlineCode",{parentName:"p"},"this.metaKey = this.id;"),". If you want to share the same ",(0,i.kt)("inlineCode",{parentName:"p"},"meta")," object\nbetween all steps of a given class, that class may set ",(0,i.kt)("inlineCode",{parentName:"p"},"metaKey"),' to be the name\nof the class. You can even set it to a shared value between multiple step\nclasses (a "family" of step classes) should that make sense. By default no\n',(0,i.kt)("inlineCode",{parentName:"p"},"metaKey")," is set, and your class will therefore have no ",(0,i.kt)("inlineCode",{parentName:"p"},"meta")," object."),(0,i.kt)("admonition",{title:"Inspiration",type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"loadMany")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"loadOne")," standard steps make use of this key to optimize\nvalue caching, you may want to look at them for more inspiration.")),(0,i.kt)("h2",{id:"step-function"},"Step function"),(0,i.kt)("p",null,"By convention, we always define a function that constructs an instance of our\nclass so we don't see the ",(0,i.kt)("inlineCode",{parentName:"p"},"new")," calls or redundant ",(0,i.kt)("inlineCode",{parentName:"p"},"Step")," text in our plan\nresolver functions."),(0,i.kt)("p",null,"This function is typically named after the corresponding\nstep class, but with the first letter in lower case and the ",(0,i.kt)("inlineCode",{parentName:"p"},"Step")," suffix\nomitted, for example ",(0,i.kt)("inlineCode",{parentName:"p"},"AddStep")," would become ",(0,i.kt)("inlineCode",{parentName:"p"},"add"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"function add($a, $b) {\n  return new AddStep($a, $b);\n}\n")),(0,i.kt)("p",null,"There's multiple reasons for this, a simple one is to make the plan code\neasier to read: we won't see the ",(0,i.kt)("inlineCode",{parentName:"p"},"new")," calls in our plan resolver functions,\nnor the redundant ",(0,i.kt)("inlineCode",{parentName:"p"},"Step")," wording, resulting in a higher signal-to-noise ratio.\nMore importantly, though, is that the small layer of indirection allows us to\ndo some minor manipulations before handing off to the class constructor, and\nmakes the APIs more future-proof since we can have the function return\nsomething different in future without having to refactor our plans in the\nschema. And remember that this cost is only incurred at planning time (which is\ngenerally cached and can be re-used for similar future requests), and each\nfield is only planned once, so the overhead of an additional function call is\nnegligible."))}m.isMDXComponent=!0}}]);