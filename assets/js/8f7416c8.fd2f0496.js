"use strict";(self.webpackChunk_localrepo_postgraphile_website=self.webpackChunk_localrepo_postgraphile_website||[]).push([[3979],{30876:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var r=t(2784);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),p=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=p(e.components);return r.createElement(s.Provider,{value:n},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),c=p(t),m=a,h=c["".concat(s,".").concat(m)]||c[m]||d[m]||l;return t?r.createElement(h,o(o({ref:n},u),{},{components:t})):r.createElement(h,o({ref:n},u))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var l=t.length,o=new Array(l);o[0]=m;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i[c]="string"==typeof e?e:a,o[1]=i;for(var p=2;p<l;p++)o[p]=t[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},26569:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>l,metadata:()=>i,toc:()=>p});var r=t(7896),a=(t(2784),t(30876));const l={layout:"page",path:"/postgraphile/make-wrap-resolvers-plugin/",title:"makeWrapResolversPlugin (graphile-utils)"},o=void 0,i={unversionedId:"make-wrap-resolvers-plugin",id:"version-4.x/make-wrap-resolvers-plugin",title:"makeWrapResolversPlugin (graphile-utils)",description:"NOTE: this documentation applies to PostGraphile v4.1.0+",source:"@site/versioned_docs/version-4.x/make-wrap-resolvers-plugin.md",sourceDirName:".",slug:"/make-wrap-resolvers-plugin",permalink:"/postgraphile/current/make-wrap-resolvers-plugin",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/postgraphile/website/versioned_docs/version-4.x/make-wrap-resolvers-plugin.md",tags:[],version:"4.x",frontMatter:{layout:"page",path:"/postgraphile/make-wrap-resolvers-plugin/",title:"makeWrapResolversPlugin (graphile-utils)"},sidebar:"docs",previous:{title:"makeProcessSchemaPlugin (graphile-utils)",permalink:"/postgraphile/current/make-process-schema-plugin"},next:{title:"makeAddPgTableConditionPlugin (graphile-utils v4.4.5+)",permalink:"/postgraphile/current/make-add-pg-table-condition-plugin"}},s={},p=[{value:"Method 1: wrapping individual resolvers of known fields",id:"method-1-wrapping-individual-resolvers-of-known-fields",level:3},{value:"Method 2: wrap all resolvers matching a filter",id:"method-2-wrap-all-resolvers-matching-a-filter",level:3},{value:"Usage",id:"usage",level:3},{value:"Leveraging PostgreSQL transaction",id:"leveraging-postgresql-transaction",level:3},{value:"Resolver wrapper functions",id:"resolver-wrapper-functions",level:3}],u={toc:p},c="wrapper";function d(e){let{components:n,...t}=e;return(0,a.kt)(c,(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"NOTE: this documentation applies to PostGraphile v4.1.0+")),(0,a.kt)("p",null,"Resolver wrapping enables you to easily take actions before or after an existing\nGraphQL field resolver, or even to prevent the resolver being called."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"makeWrapResolversPlugin")," helps you to easily generate a\n",(0,a.kt)("a",{parentName:"p",href:"./extending/"},'"schema plugin"')," for 'wrapping' the resolvers generated by\nPostGraphile. You can\n",(0,a.kt)("a",{parentName:"p",href:"./extending/#loading-plugins"},"load the resulting schema plugin")," with\n",(0,a.kt)("inlineCode",{parentName:"p"},"--append-plugins")," via the PostGraphile CLI, or with ",(0,a.kt)("inlineCode",{parentName:"p"},"appendPlugins")," via the\nPostGraphile library."),(0,a.kt)("p",null,"IMPORTANT: Because PostGraphile uses the Graphile Engine look-ahead features,\noverriding a resolver may not effect the SQL that will be generated. If you want\nto influence how the system executes, only use this for modifying root-level\nresolvers (as these are responsible for generating the SQL and fetching from the\ndatabase); however it's safe to use resolver wrapping for augmenting the\nreturned values (for example masking private data, performing normalisation,\netc) on any field."),(0,a.kt)("p",null,"Let's look at the ",(0,a.kt)("inlineCode",{parentName:"p"},"makeWrapResolvers")," definition in the ",(0,a.kt)("inlineCode",{parentName:"p"},"graphile-utils")," source\ncode to understand how it works. There are two ",(0,a.kt)("em",{parentName:"p"},"variants")," of\n",(0,a.kt)("inlineCode",{parentName:"p"},"makeWrapResolversPlugin")," with slightly different signatures (function\noverloading). These reflect the two methods of calling\n",(0,a.kt)("inlineCode",{parentName:"p"},"makeWrapResolversPlugin"),". If you want to wrap one or two specific resolvers\n(where you know the type name and field name) then method 1 is a handy shortcut.\nIf, however, you want to wrap a number of resolvers in the same way then the\nmore flexible method 2 is what you want."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"// Method 1: wrap individual resolvers of known fields\nfunction makeWrapResolversPlugin(\n  rulesOrGenerator: ResolverWrapperRules | ResolverWrapperRulesGenerator,\n): Plugin;\n\n// Method 2: wrap all resolvers that match a filter function\nfunction makeWrapResolversPlugin<T>(\n  filter: (\n    context: Context,\n    build: Build,\n    field: GraphQLFieldConfig,\n    options: Options,\n  ) => T,\n  rule: (match: T) => ResolverWrapperRule | ResolverWrapperFn,\n);\n\n/****************************************/\n\ninterface ResolverWrapperRules {\n  [typeName: string]: {\n    [fieldName: string]: ResolverWrapperRule | ResolverWrapperFn;\n  };\n}\ntype ResolverWrapperRulesGenerator = (options: Options) => ResolverWrapperRules;\n")),(0,a.kt)("h3",{id:"method-1-wrapping-individual-resolvers-of-known-fields"},"Method 1: wrapping individual resolvers of known fields"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"function makeWrapResolversPlugin(\n  rulesOrGenerator: ResolverWrapperRules | ResolverWrapperRulesGenerator,\n): Plugin;\n")),(0,a.kt)("p",null,"In this method, ",(0,a.kt)("inlineCode",{parentName:"p"},"makeWrapResolversPlugin")," takes either the resolver wrapper\nrules object directly, or a generator for this rules object, and returns a\nplugin. e.g.:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"module.exports = makeWrapResolversPlugin({\n  User: {\n    async email(resolve, source, args, context, resolveInfo) {\n      const result = await resolve();\n      return result.toLowerCase();\n    },\n  },\n});\n")),(0,a.kt)("p",null,"Also when plugin is only for one type, then still better to use first method.\ne.g.:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const validateUserData = (propName) => {\n  return async (resolve, source, args, context, resolveInfo) => {\n    const user = args.input[propName];\n\n    await isValidUserData(user); // throws error if invalid\n\n    return resolve();\n  };\n};\n\nmodule.exports = makeWrapResolversPlugin({\n  Mutation: {\n    createUser: validateUserData("user"),\n    updateUser: validateUserData("userPatch"),\n    updateUserById: validateUserData("userPatch"),\n    updateUserByEmail: validateUserData("userPatch"),\n  },\n});\n')),(0,a.kt)("p",null,"The rules object is a two-level map of ",(0,a.kt)("inlineCode",{parentName:"p"},"typeName")," (the name of a\nGraphQLObjectType) and ",(0,a.kt)("inlineCode",{parentName:"p"},"fieldName")," (the name of one of the fields of this type)\nto either a rule for that field, or a resolver wrapper function for that field.\nThe generator function accepts an ",(0,a.kt)("inlineCode",{parentName:"p"},"Options")," object (which contains everything\nyou may have added to ",(0,a.kt)("inlineCode",{parentName:"p"},"graphileBuildOptions")," and more)."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"interface ResolverWrapperRules {\n  [typeName: string]: {\n    [fieldName: string]: ResolverWrapperRule | ResolverWrapperFn;\n  };\n}\ntype ResolverWrapperRulesGenerator = (options: Options) => ResolverWrapperRules;\n")),(0,a.kt)("p",null,"Read about ",(0,a.kt)("a",{parentName:"p",href:"#resolver-wrapper-functions"},"resolver wrapper functions below"),"."),(0,a.kt)("p",null,"For example, this plugin wraps the ",(0,a.kt)("inlineCode",{parentName:"p"},"User.email")," field, returning ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," if the\nuser requesting the field is not the same as the user for which the email was\nrequested. (Note that the email is still retrieved from the database, it is just\nnot returned to the user.)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const { makeWrapResolversPlugin } = require("graphile-utils");\n\nmodule.exports = makeWrapResolversPlugin({\n  User: {\n    email: {\n      requires: {\n        siblingColumns: [{ column: "id", alias: "$user_id" }],\n      },\n      resolve(resolver, user, args, context, _resolveInfo) {\n        if (context.jwtClaims.user_id !== user.$user_id) return null;\n        return resolver();\n      },\n    },\n  },\n});\n')),(0,a.kt)("p",null,"This example shows a different order of operation. It uses the default resolver\nof the ",(0,a.kt)("inlineCode",{parentName:"p"},"User.email")," field to get the actual value, but then masks the value\ninstead of omitting it."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const { makeWrapResolversPlugin } = require("graphile-utils");\n\nmodule.exports = makeWrapResolversPlugin({\n  User: {\n    email: {\n      async resolve(resolver, user, args, context, _resolveInfo) {\n        const unmaskedValue = await resolver();\n        // someone@sub.example.com -> so***@su***.com\n        return unmaskedValue.replace(\n          /^(.{1,2})[^@]*@(.{,2})[^.]*\\.([A-z]{2,})$/,\n          "$1***@$2***.$3",\n        );\n      },\n    },\n  },\n});\n')),(0,a.kt)("h3",{id:"method-2-wrap-all-resolvers-matching-a-filter"},"Method 2: wrap all resolvers matching a filter"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"function makeWrapResolversPlugin<T>(\n  filter: (\n    context: Context,\n    build: Build,\n    field: GraphQLFieldConfig,\n    options: Options,\n  ) => T | null,\n  rule: (match: T) => ResolverWrapperRule | ResolverWrapperFn,\n);\n")),(0,a.kt)("p",null,"In this method, ",(0,a.kt)("inlineCode",{parentName:"p"},"makeWrapResolversPlugin")," takes two function arguments. The\nfirst function is a filter that is called for each field; it should return a\ntruthy value if the field is to be wrapped (or ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," otherwise). The second\nfunction is called for each field that passes the filter, it will be passed the\nreturn value of the filter and must return a resolve wrapper function or rule\n(see ",(0,a.kt)("a",{parentName:"p",href:"#resolver-wrapper-functions"},"Resolver wrapper functions")," below)."),(0,a.kt)("p",null,"The filter is called with the following arguments:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"context"),": the ",(0,a.kt)("inlineCode",{parentName:"li"},"Context")," value of the field, the ",(0,a.kt)("inlineCode",{parentName:"li"},"context.scope")," property is\nthe most likely to be used"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"build"),": the ",(0,a.kt)("inlineCode",{parentName:"li"},"Build")," objects which contains a lot of helpers"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"field"),": the field specification itself"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"options"),": object which contains everything you may have added to\n",(0,a.kt)("inlineCode",{parentName:"li"},"graphileBuildOptions")," and more")),(0,a.kt)("p",null,"The value you return can be any arbitrary truthy value, it should contain\nanything from the above arguments that you need to create your resolver wrapper."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"// Example: log before and after each mutation runs\nmodule.exports = makeWrapResolversPlugin(\n  (context) => {\n    if (context.scope.isRootMutation) {\n      return { scope: context.scope };\n    }\n    return null;\n  },\n  ({ scope }) =>\n    async (resolver, user, args, context, _resolveInfo) => {\n      console.log(\n        `Mutation '${scope.fieldName}' starting with arguments:`,\n        args,\n      );\n      const result = await resolver();\n      console.log(`Mutation '${scope.fieldName}' result:`, result);\n      return result;\n    },\n);\n")),(0,a.kt)("h3",{id:"usage"},"Usage"),(0,a.kt)("p",null,"As mentioned above, you can\n",(0,a.kt)("a",{parentName:"p",href:"./extending/#loading-plugins"},"load the resulting schema plugin")," with\n",(0,a.kt)("inlineCode",{parentName:"p"},"--append-plugins")," via the PostGraphile CLI, or with ",(0,a.kt)("inlineCode",{parentName:"p"},"appendPlugins")," via the\nPostGraphile library."),(0,a.kt)("p",null,"The above examples defined a single plugin function generated by calling\n",(0,a.kt)("inlineCode",{parentName:"p"},"makeWrapResolversPlugin")," and exported via CommonJS as the only element in the\nJavaScript file (module)."),(0,a.kt)("p",null,"If you are using ES6 modules (",(0,a.kt)("inlineCode",{parentName:"p"},"import"),"/",(0,a.kt)("inlineCode",{parentName:"p"},"export"),") rather than Common JS\n(",(0,a.kt)("inlineCode",{parentName:"p"},"require"),"/",(0,a.kt)("inlineCode",{parentName:"p"},"exports"),"), then the syntax should be adjusted slightly:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"import { makeWrapResolversPlugin } from 'graphile-utils';\n\nexport default makeWrapResolversPlugin(\n...\n);\n")),(0,a.kt)("h3",{id:"leveraging-postgresql-transaction"},"Leveraging PostgreSQL transaction"),(0,a.kt)("p",null,"If you want a mutation to succeed only if some custom code succeeds, you can do\nthat plugging into the current PostgreSQL transaction. This allows you to\n'rollback' the SQL transaction if the custom code fails."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'export const CreatePostPlugin = makeWrapResolversPlugin({\n  Mutation: {\n    createPost: {\n      requires: {\n        childColumns: [{ column: "id", alias: "$post_id" }],\n      },\n      async resolve(resolve: any, _source, _args, context: any, _resolveInfo) {\n        // The pgClient on context is already in a transaction configured for the user:\n        const { pgClient } = context;\n        // Create a savepoint we can roll back to\n        await pgClient.query("SAVEPOINT mutation_wrapper");\n        try {\n          // Run the original resolver\n          const result = await resolve();\n          // Do the custom thing\n          await doCustomThing(result.data.$post_id);\n          // Finally return the result of our original mutation\n          return result;\n        } catch (e) {\n          // Something went wrong - rollback!\n          // NOTE: Do NOT rollback entire transaction as a transaction may be\n          // shared across multiple mutations. Rolling back to the above defined\n          // SAVEPOINT allows other mutations to succeed.\n          await pgClient.query("ROLLBACK TO SAVEPOINT mutation_wrapper");\n          // Re-throw the error so the GraphQL client knows about it\n          throw e;\n        } finally {\n          await pgClient.query("RELEASE SAVEPOINT mutation_wrapper");\n        }\n      },\n    },\n  },\n});\n\nasync function doCustomThing(postId: number) {\n  throw new Error("to be implemented");\n}\n')),(0,a.kt)("h3",{id:"resolver-wrapper-functions"},"Resolver wrapper functions"),(0,a.kt)("p",null,"A resolver wrapper function is similar to a GraphQL resolver, except it takes an\nadditional argument (at the start) which allows delegating to the resolver that\nis being wrapped. If and when you call the ",(0,a.kt)("inlineCode",{parentName:"p"},"resolve")," function, you may\noptionally pass one or more of the arguments\n",(0,a.kt)("inlineCode",{parentName:"p"},"source, args, context, resolveInfo"),"; these will then override the values that\nthe resolver will be passed. Calling ",(0,a.kt)("inlineCode",{parentName:"p"},"resolve()")," with no arguments will just\npass through the original values unmodified."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"type ResolverWrapperFn = (\n  resolve: GraphQLFieldResolver, // Delegates to the resolver we're wrapping\n  source: TSource,\n  args: TArgs,\n  context: TContext,\n  resolveInfo: GraphQLResolveInfo,\n) => any;\n")),(0,a.kt)("p",null,"Should your wrapper require additional data, for example data about it's sibling\nor child columns, then instead of specifying the wrapper directly you can pass a\nrule object. The rule object should include the ",(0,a.kt)("inlineCode",{parentName:"p"},"resolve")," method (your wrapper)\nand can also include a list of requirements. It's advised that your alias should\nbegin with a dollar ",(0,a.kt)("inlineCode",{parentName:"p"},"$")," symbol to prevent it conflicting with any aliases\ngenerated by the system."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"interface ResolverWrapperRequirements {\n  childColumns?: Array<{ column: string; alias: string }>;\n  siblingColumns?: Array<{ column: string; alias: string }>;\n}\ninterface ResolverWrapperRule {\n  requires?: ResolverWrapperRequirements;\n  resolve?: ResolverWrapperFn;\n  // subscribe?: ResolverWrapperFn;\n}\n")))}d.isMDXComponent=!0}}]);