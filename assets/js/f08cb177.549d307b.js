"use strict";(self.webpackChunk_localrepo_grafast_website=self.webpackChunk_localrepo_grafast_website||[]).push([[8621],{30876:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(2784);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),u=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=u(e.components);return n.createElement(o.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(a),m=r,h=p["".concat(o,".").concat(m)]||p[m]||d[m]||l;return a?n.createElement(h,i(i({ref:t},c),{},{components:a})):n.createElement(h,i({ref:t},c))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=m;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[p]="string"==typeof e?e:r,i[1]=s;for(var u=2;u<l;u++)i[u]=a[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},82009:(e,t,a)=>{a.d(t,{Z:()=>i});var n=a(2784),r=a(524);const l={tabItem:"tabItem_OMyP"};function i(e){let{children:t,hidden:a,className:i}=e;return n.createElement("div",{role:"tabpanel",className:(0,r.Z)(l.tabItem,i),hidden:a},t)}},77336:(e,t,a)=>{a.d(t,{Z:()=>w});var n=a(7896),r=a(2784),l=a(524),i=a(24126),s=a(7267),o=a(32424),u=a(42244),c=a(24155);function p(e){return function(e){return r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:r}}=e;return{value:t,label:a,attributes:n,default:r}}))}function d(e){const{values:t,children:a}=e;return(0,r.useMemo)((()=>{const e=t??p(a);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function m(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:a}=e;const n=(0,s.k6)(),l=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,o._X)(l),(0,r.useCallback)((e=>{if(!l)return;const t=new URLSearchParams(n.location.search);t.set(l,e),n.replace({...n.location,search:t.toString()})}),[l,n])]}function f(e){const{defaultValue:t,queryString:a=!1,groupId:n}=e,l=d(e),[i,s]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:l}))),[o,u]=h({queryString:a,groupId:n}),[p,f]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,l]=(0,c.Nk)(a);return[n,(0,r.useCallback)((e=>{a&&l.set(e)}),[a,l])]}({groupId:n}),g=(()=>{const e=o??p;return m({value:e,tabValues:l})?e:null})();(0,r.useLayoutEffect)((()=>{g&&s(g)}),[g]);return{selectedValue:i,selectValue:(0,r.useCallback)((e=>{if(!m({value:e,tabValues:l}))throw new Error(`Can't select invalid tab value=${e}`);s(e),u(e),f(e)}),[u,f,l]),tabValues:l}}var g=a(89741);const b={tabList:"tabList_M0Dn",tabItem:"tabItem_ysIP"};function v(e){let{className:t,block:a,selectedValue:s,selectValue:o,tabValues:u}=e;const c=[],{blockElementScrollPositionUntilNextRender:p}=(0,i.o5)(),d=e=>{const t=e.currentTarget,a=c.indexOf(t),n=u[a].value;n!==s&&(p(t),o(n))},m=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const a=c.indexOf(e.currentTarget)+1;t=c[a]??c[0];break}case"ArrowLeft":{const a=c.indexOf(e.currentTarget)-1;t=c[a]??c[c.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":a},t)},u.map((e=>{let{value:t,label:a,attributes:i}=e;return r.createElement("li",(0,n.Z)({role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,key:t,ref:e=>c.push(e),onKeyDown:m,onClick:d},i,{className:(0,l.Z)("tabs__item",b.tabItem,i?.className,{"tabs__item--active":s===t})}),a??t)})))}function y(e){let{lazy:t,children:a,selectedValue:n}=e;const l=(Array.isArray(a)?a:[a]).filter(Boolean);if(t){const e=l.find((e=>e.props.value===n));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},l.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function k(e){const t=f(e);return r.createElement("div",{className:(0,l.Z)("tabs-container",b.tabList)},r.createElement(v,(0,n.Z)({},e,t)),r.createElement(y,(0,n.Z)({},e,t)))}function w(e){const t=(0,g.Z)();return r.createElement(k,(0,n.Z)({key:String(t)},e))}},39094:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>u,toc:()=>p});var n=a(7896),r=(a(2784),a(30876)),l=a(77336),i=a(82009);const s={sidebar_position:3},o="Using with existing schema",u={unversionedId:"getting-started/existing-schema",id:"getting-started/existing-schema",title:"Using with existing schema",description:"Requirements",source:"@site/grafast/getting-started/existing-schema.md",sourceDirName:"getting-started",slug:"/getting-started/existing-schema",permalink:"/grafast/getting-started/existing-schema",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/grafast/website/grafast/getting-started/existing-schema.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Getting started",permalink:"/grafast/getting-started/"},next:{title:"Servers",permalink:"/grafast/servers"}},c={},p=[{value:"Requirements",id:"requirements",level:2},{value:"Installation",id:"installation",level:2},{value:"Running",id:"running",level:2},{value:"Cache parse and validation",id:"cache-parse-and-validation",level:2},{value:"Replacing resolvers with plans",id:"replacing-resolvers-with-plans",level:2}],d={toc:p},m="wrapper";function h(e){let{components:t,...a}=e;return(0,r.kt)(m,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"using-with-existing-schema"},"Using with existing schema"),(0,r.kt)("h2",{id:"requirements"},"Requirements"),(0,r.kt)("p",null,"To run an existing GraphQL schema with ",(0,r.kt)("grafast",null)," you must ensure that the\nfollowing hold:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Your resolvers are built into your schema as is the norm (not passed via ",(0,r.kt)("inlineCode",{parentName:"li"},"rootValue"),")"),(0,r.kt)("li",{parentName:"ul"},"If any of your resolvers use ",(0,r.kt)("inlineCode",{parentName:"li"},"GraphQLResolveInfo")," (the 4th argument to the\nresolver) then they must not rely on the ",(0,r.kt)("inlineCode",{parentName:"li"},"path")," property since we can't\ncurrently populate that in an equivalent fashion"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"context")," must be an object (anything suitable to be used as the key to a\n",(0,r.kt)("inlineCode",{parentName:"li"},"WeakMap"),"); if you do not need a context then ",(0,r.kt)("inlineCode",{parentName:"li"},"{}")," is perfectly acceptable"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"rootValue"),", if specified, must be an object or ",(0,r.kt)("inlineCode",{parentName:"li"},"null"),"/",(0,r.kt)("inlineCode",{parentName:"li"},"undefined"))),(0,r.kt)("p",null,"(If you face any issues with your resolvers, please file an issue - it's\npossible that this list of constraints is not complete.)"),(0,r.kt)("h2",{id:"installation"},"Installation"),(0,r.kt)("p",null,"Ensure that you have both the ",(0,r.kt)("inlineCode",{parentName:"p"},"graphql")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"grafast")," modules installed:"),(0,r.kt)(l.Z,{groupId:"npm2yarn",mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"npm",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm install --save grafast@beta graphql\n"))),(0,r.kt)(i.Z,{value:"yarn",label:"Yarn",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"yarn add grafast@beta graphql\n"))),(0,r.kt)(i.Z,{value:"pnpm",label:"pnpm",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"pnpm add grafast@beta graphql\n")))),(0,r.kt)("h2",{id:"running"},"Running"),(0,r.kt)("p",null,"Replace any calls to graphql.js' ",(0,r.kt)("inlineCode",{parentName:"p"},"graphql")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"execute")," functions with Grafast's\n",(0,r.kt)("inlineCode",{parentName:"p"},"grafast")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"execute")," respectively."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},"-import { graphql, execute } from 'graphql';\n+import { grafast, execute } from 'grafast';\n\n-const result = await graphql({\n+const result = await grafast({\n   schema,\n   contextValue: {},\n   source: ...\n")),(0,r.kt)("h2",{id:"cache-parse-and-validation"},"Cache parse and validation"),(0,r.kt)("p",null,"At this point you should be able to execute your GraphQL API as you previously\ndid, but unless you're using the ",(0,r.kt)("inlineCode",{parentName:"p"},"grafast")," function we're not yet as optimal as\nwe could be."),(0,r.kt)("p",null,"Without further intervention, using ",(0,r.kt)("inlineCode",{parentName:"p"},"execute")," directly makes it likely you'll\nbe planning each request every time, rather than reusing operation plans. To\nsolve this, you should cache the parsing of the GraphQL request so that when\nthe same document is seen again the exact same parsed document AST will be\npassed to ",(0,r.kt)("grafast",null),". You can either handle this yourself, use the ",(0,r.kt)("inlineCode",{parentName:"p"},"grafast"),"\nfunction instead, or use a server/framework that does this for you; see\n",(0,r.kt)("a",{parentName:"p",href:"../servers"},"Servers"),"."),(0,r.kt)("h2",{id:"replacing-resolvers-with-plans"},"Replacing resolvers with plans"),(0,r.kt)("p",null,"​",(0,r.kt)("grafast",null),' automatically supports resolvers (with the\n"Requirements" mentioned above) to help maintain compatibility with legacy\nschemas, but if you\'re ready to get the next level of performance you can\nreplace the resolver with a plan on a field-by-field basis in a schema.'),(0,r.kt)("p",null,"For more information, see ",(0,r.kt)("a",{parentName:"p",href:"../plan-resolvers"},"Plan Resolvers"),"."))}h.isMDXComponent=!0}}]);