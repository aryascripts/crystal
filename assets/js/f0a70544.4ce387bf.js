"use strict";(self.webpackChunk_localrepo_postgraphile_website=self.webpackChunk_localrepo_postgraphile_website||[]).push([[2285],{30876:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>m});var r=t(2784);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),p=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=p(e.components);return r.createElement(s.Provider,{value:n},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},c=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=p(t),c=a,m=u["".concat(s,".").concat(c)]||u[c]||h[c]||o;return t?r.createElement(m,i(i({ref:n},d),{},{components:t})):r.createElement(m,i({ref:n},d))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=c;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[u]="string"==typeof e?e:a,i[1]=l;for(var p=2;p<o;p++)i[p]=t[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}c.displayName="MDXCreateElement"},45814:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var r=t(7896),a=(t(2784),t(30876));const o={layout:"page",path:"/postgraphile/extending-raw/",title:"Schema Plugins - Graphile Engine"},i=void 0,l={unversionedId:"extending-raw",id:"version-4.x/extending-raw",title:"Schema Plugins - Graphile Engine",description:"The PostGraphile GraphQL schema is constructed out of a number of Graphile",source:"@site/versioned_docs/version-4.x/extending-raw.md",sourceDirName:".",slug:"/extending-raw",permalink:"/postgraphile/current/extending-raw",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/postgraphile/website/versioned_docs/version-4.x/extending-raw.md",tags:[],version:"4.x",frontMatter:{layout:"page",path:"/postgraphile/extending-raw/",title:"Schema Plugins - Graphile Engine"},sidebar:"docs",previous:{title:"makePluginByCombiningPlugins (graphile-utils)",permalink:"/postgraphile/current/make-plugin-by-combining-plugins"},next:{title:"PostGraphile Plugin Gallery",permalink:"/postgraphile/current/plugin-gallery"}},s={},p=[{value:"Adding root query/mutation fields",id:"adding-root-querymutation-fields",level:3},{value:"Wrapping an existing resolver",id:"wrapping-an-existing-resolver",level:3},{value:"Removing things from the schema",id:"removing-things-from-the-schema",level:3}],d={toc:p},u="wrapper";function h(e){let{components:n,...t}=e;return(0,a.kt)(u,(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The PostGraphile GraphQL schema is constructed out of a number of Graphile\nEngine plugins. The core PG-related plugins can be found here:"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/graphile/graphile-engine/tree/master/packages/graphile-build-pg/src/plugins"},"https://github.com/graphile/graphile-engine/tree/master/packages/graphile-build-pg/src/plugins")),(0,a.kt)("p",null,"These plugins introduce small amounts of functionality, and build upon each\nother. The order in which the plugins are loaded is significant, and can be\nfound from the ",(0,a.kt)("inlineCode",{parentName:"p"},"defaultPlugins")," export in\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/graphile/graphile-engine/blob/master/packages/graphile-build-pg/src/index.ts"},(0,a.kt)("inlineCode",{parentName:"a"},"src/index.ts")),"\nof the ",(0,a.kt)("inlineCode",{parentName:"p"},"graphile-build-pg")," module."),(0,a.kt)("p",null,"You can extend PostGraphile's GraphQL schema by adding plugins before or after\nthe default plugins. You may even opt to replace the entire list of plugins used\nto build the schema. Graphile Engine plugins are built on top of the\n",(0,a.kt)("a",{parentName:"p",href:"http://graphql.org/graphql-js/"},"GraphQL reference JS implementation"),", so it is\nrecommended that you have familiarity with that before attempting to write your\nown plugins."),(0,a.kt)("h3",{id:"adding-root-querymutation-fields"},"Adding root query/mutation fields"),(0,a.kt)("p",null,"A common request is to add additional root-level fields to your schema, for\nexample to integrate external services. The easiest way to do this is to\n",(0,a.kt)("a",{parentName:"p",href:"./make-extend-schema-plugin/"},"use ",(0,a.kt)("inlineCode",{parentName:"a"},"makeExtendSchemaPlugin"))," to generate a\nplugin that will extend your schema (this can be used to add fields anywhere,\nnot just at the root-level):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'// add-http-bin-plugin.js\nconst { makeExtendSchemaPlugin, gql } = require("graphile-utils");\nconst fetch = require("node-fetch");\n\nmodule.exports = makeExtendSchemaPlugin({\n  typeDefs: gql`\n    extend type Query {\n      httpBinHeaders: JSON\n    }\n  `,\n  resolvers: {\n    Query: {\n      async httpBinHeaders() {\n        const response = await fetch("https://httpbin.org/headers");\n        return response.json();\n      },\n    },\n  },\n});\n')),(0,a.kt)("p",null,"If you need to do this using the low-level plugins API for some reason (for\nexample you want access to the look-ahead features, or you're defining the\nfields in a more automated way) then you can use a 'GraphQLObjectType:fields'\nhook and to add our new field:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'// add-http-bin-plugin-raw.js\nconst fetch = require("node-fetch");\n\nfunction AddHttpBinPlugin(builder, { pgExtendedTypes }) {\n  builder.hook(\n    "GraphQLObjectType:fields",\n    (\n      fields, // Input object - the fields for this GraphQLObjectType\n      { extend, getTypeByName }, // Build object - handy utils\n      { scope: { isRootQuery } }, // Context object - used for filtering\n    ) => {\n      if (!isRootQuery) {\n        // This isn\'t the object we want to modify:\n        // return the input object unmodified\n        return fields;\n      }\n\n      // We don\'t want to introduce a new JSON type as that will clash,\n      // so let\'s find the JSON type that other fields use:\n      const JSONType = getTypeByName("JSON");\n\n      return extend(fields, {\n        httpBinHeaders: {\n          type: JSONType,\n          async resolve() {\n            const response = await fetch("https://httpbin.org/headers");\n            if (pgExtendedTypes) {\n              // This setting is enabled through postgraphile\'s\n              // `--dynamic-json` option, if enabled return JSON:\n              return response.json();\n            } else {\n              // If Dynamic JSON is not enabled, we want a JSON string instead\n              return response.text();\n            }\n          },\n        },\n      });\n    },\n  );\n}\n\nmodule.exports = AddHttpBinPlugin;\n')),(0,a.kt)("p",null,"(If you wanted to add a mutation you'd use ",(0,a.kt)("inlineCode",{parentName:"p"},"isRootMutation")," rather than\n",(0,a.kt)("inlineCode",{parentName:"p"},"isRootQuery"),".)"),(0,a.kt)("p",null,"We can then load our plugin into PostGraphile via:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"postgraphile --append-plugins `pwd`/add-http-bin-plugin.js -c postgres:///mydb\n")),(0,a.kt)("p",null,"Note that the types of added fields do not need to be implemented via Graphile\nEngine's\n",(0,a.kt)("a",{parentName:"p",href:"https://graphile.org/graphile-build/build-object/#newwithhookstype-spec-scope"},(0,a.kt)("inlineCode",{parentName:"a"},"newWithHooks"))," -\nyou can use standard GraphQL objects too, as we have demonstrated with the\n",(0,a.kt)("inlineCode",{parentName:"p"},"JSONType")," above. (However, if you do not use ",(0,a.kt)("inlineCode",{parentName:"p"},"newWithHooks")," then the objects\nreferenced cannot be extended via plugins.)"),(0,a.kt)("h3",{id:"wrapping-an-existing-resolver"},"Wrapping an existing resolver"),(0,a.kt)("p",null,"Sometimes you might want to override what an existing field does. Due to the way\nthat PostGraphile works (where the root Query field resolvers are the only ones\nwho perform SQL queries) this is generally most useful at the top level."),(0,a.kt)("p",null,"In PostGraphile version 4.1 and above, you can\n",(0,a.kt)("a",{parentName:"p",href:"./make-wrap-resolvers-plugin/"},"use ",(0,a.kt)("inlineCode",{parentName:"a"},"makeWrapResolversPlugin"))," to easily wrap a\nresolver:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"module.exports = makeWrapResolversPlugin({\n  User: {\n    async email(resolve, source, args, context, resolveInfo) {\n      const result = await resolve();\n      return result.toLowerCase();\n    },\n  },\n});\n")),(0,a.kt)("p",null,"If you need to process the resolvers in a more powerful way than possible via\n",(0,a.kt)("inlineCode",{parentName:"p"},"makeWrapResolversPlugin"),", then you can drop down to the raw plugin API. The\nfollowing example modifies the 'createLink' mutation so that it performs some\nadditional validation (thrown an error if the link's ",(0,a.kt)("inlineCode",{parentName:"p"},"title")," is too short) and\nperforms an action after the link has been saved. You could use a plugin like\nthis to achieve many different tasks, including emailing a user after their\naccount is created or logging failed authentication attempts."),(0,a.kt)("p",null,"Previously we used ",(0,a.kt)("inlineCode",{parentName:"p"},"GraphQLObjectType:fields")," to add a field, as that\nmanipulates the list of fields. This time we are manipulating an individual\nfield, so we will use the ",(0,a.kt)("inlineCode",{parentName:"p"},"GraphQLObjectType:fields:field")," hook. This makes our\nintent clear, and also grants us access to\n",(0,a.kt)("a",{parentName:"p",href:"https://graphile.org/graphile-build/look-ahead/#when-processing-arguments-addargdatagenerator"},"the ",(0,a.kt)("inlineCode",{parentName:"a"},"addArgDataGenerator")),"\nfunction which we need to request the record id. The following example also uses\nan instance of ",(0,a.kt)("a",{parentName:"p",href:"./make-extend-schema-plugin/#querybuilder"},(0,a.kt)("inlineCode",{parentName:"a"},"queryBuilder.")),"\n(Read more about the different hooks\n",(0,a.kt)("a",{parentName:"p",href:"https://graphile.org/graphile-build/all-hooks/"},"in the Graphile Engine docs"),".)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"function performAnotherTask(linkId) {\n  console.log(`We created link ${linkId}!`);\n}\n\nmodule.exports = function CreateLinkWrapPlugin(builder) {\n  builder.hook(\n    \"GraphQLObjectType:fields:field\",\n    (\n      field,\n      { pgSql: sql },\n      { scope: { isRootMutation, fieldName }, addArgDataGenerator },\n    ) => {\n      if (!isRootMutation || fieldName !== \"createLink\") {\n        // The 'GraphQLObjectType:fields:field' hook runs for every field on\n        // every object type in the schema. If it's not a field in the root\n        // mutation type, or the field isn't named 'createLink', we don't want\n        // to modify it in this hook - so return the input object unmodified.\n        return field;\n      }\n\n      // We're going to need link.id for our `performAnotherTask`; so we're going\n      // to abuse addArgDataGenerator to make sure that this field is ALWAYS\n      // requested, even if the user doesn't specify it. We're careful to alias\n      // the result to a field that begins with `__` as that's forbidden by\n      // GraphQL and thus cannot clash with a user's fields.\n      addArgDataGenerator(() => ({\n        pgQuery: (queryBuilder) => {\n          queryBuilder.select(\n            // Select this value from the result of the INSERT:\n            sql.query`${queryBuilder.getTableAlias()}.id`,\n            // And give it this name in the result data:\n            \"__createdRecordId\",\n          );\n        },\n      }));\n\n      // It's possible that `resolve` isn't specified on a field, so in that case\n      // we fall back to a default resolver.\n      const defaultResolver = (obj) => obj[fieldName];\n\n      // Extract the old resolver from `field`\n      const { resolve: oldResolve = defaultResolver, ...rest } = field;\n\n      return {\n        // Copy over everything except 'resolve'\n        ...rest,\n\n        // Add our new resolver which wraps the old resolver\n        async resolve(...resolveParams) {\n          // Perform some validation (or any other action you want to do before\n          // calling the old resolver)\n          const RESOLVE_ARGS_INDEX = 1;\n          const {\n            input: {\n              link: { title },\n            },\n          } = resolveParams[RESOLVE_ARGS_INDEX];\n          if (title.length < 3) {\n            throw new Error(\"Title is too short!\");\n          }\n\n          // Call the old resolver (you SHOULD NOT modify the arguments it\n          // receives unless you also manipulate the AST it gets passed as the\n          // 4th argument; which is quite a lot of effort) and store the result.\n          const oldResolveResult = await oldResolve(...resolveParams);\n\n          // Perform any tasks we want to do after the record is created.\n          await performAnotherTask(oldResolveResult.data.__createdRecordId);\n\n          // Finally return the result.\n          return oldResolveResult;\n        },\n      };\n    },\n  );\n};\n")),(0,a.kt)("h3",{id:"removing-things-from-the-schema"},"Removing things from the schema"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"WARNING"),": removing things from your GraphQL schema this way may have\nunintended consequences - especially if you add back a field or type with the\nsame name as that which you removed. It's advised that rather than removing\nthings, you instead avoid them being generated in the first place."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"If you're looking for an easy way to prevent certain tables, fields, functions\nor relations being added to your GraphQL schema, check out\n",(0,a.kt)("a",{parentName:"strong",href:"./smart-comments/"},"smart comments"),".")),(0,a.kt)("p",null,"If you want to remove a class of things from the schema then you can remove the\nplugin that adds them; for example if you no longer wanted to allow ordering by\nall the columns of a table (i.e. only allow ordering by the primary key) you\ncould omit\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/graphile/graphile-engine/blob/master/packages/graphile-build-pg/src/plugins/PgOrderAllColumnsPlugin.ts"},"PgOrderAllColumnsPlugin"),".\nIf you didn't want computed columns added you could omit\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/graphile/graphile-engine/blob/master/packages/graphile-build-pg/src/plugins/PgComputedColumnsPlugin.ts"},"PgComputedColumnsPlugin"),"."),(0,a.kt)("p",null,"However, sometimes you need more surgical precision, and you only want to remove\none specific type of thing. To achieve this you need to add a hook to the thing\nthat owns the thing you wish to remove - for example if you want to remove a\nfield ",(0,a.kt)("inlineCode",{parentName:"p"},"bar")," from an object type ",(0,a.kt)("inlineCode",{parentName:"p"},"Foo")," you could hook ",(0,a.kt)("inlineCode",{parentName:"p"},"GraphQLObjectType:fields"),"\nand return the set of fields less the one you want removed."),(0,a.kt)("p",null,"Here's an example of a plugin generator you could use to generate plugins to\nremove individual fields. This is just to demonstrate how a plugin to do this\nmight work, ",(0,a.kt)("a",{parentName:"p",href:"./smart-comments/"},"smart comments")," are likely a better approach."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const omit = require("lodash/omit");\n\nfunction removeFieldPluginGenerator(objectName, fieldName) {\n  const fn = function (builder) {\n    builder.hook("GraphQLObjectType:fields", (fields, _, { Self }) => {\n      if (Self.name !== objectName) return fields;\n      return omit(fields, [fieldName]);\n    });\n  };\n  // For debugging:\n  fn.displayName = `RemoveFieldPlugin:${objectName}.${fieldName}`;\n  return fn;\n}\n\nconst RemoveFooDotBarPlugin = removeFieldPluginGenerator("Foo", "bar");\n\nmodule.exports = RemoveFooDotBarPlugin;\n')))}h.isMDXComponent=!0}}]);