"use strict";(self.webpackChunk_localrepo_postgraphile_website=self.webpackChunk_localrepo_postgraphile_website||[]).push([[6339],{30876:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>m});var a=t(2784);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=p(t),h=r,m=d["".concat(l,".").concat(h)]||d[h]||c[h]||i;return t?a.createElement(m,s(s({ref:n},u),{},{components:t})):a.createElement(m,s({ref:n},u))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,s=new Array(i);s[0]=h;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o[d]="string"==typeof e?e:r,s[1]=o;for(var p=2;p<i;p++)s[p]=t[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},16565:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=t(7896),r=(t(2784),t(30876));const i={layout:"page",path:"/postgraphile/make-extend-schema-plugin/",title:"makeExtendSchemaPlugin"},s=void 0,o={unversionedId:"make-extend-schema-plugin",id:"make-extend-schema-plugin",title:"makeExtendSchemaPlugin",description:"makeExtendSchemaPlugin is the plugin generator you need to know about. It's",source:"@site/postgraphile/make-extend-schema-plugin.md",sourceDirName:".",slug:"/make-extend-schema-plugin",permalink:"/postgraphile/next/make-extend-schema-plugin",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/postgraphile/website/postgraphile/make-extend-schema-plugin.md",tags:[],version:"current",frontMatter:{layout:"page",path:"/postgraphile/make-extend-schema-plugin/",title:"makeExtendSchemaPlugin"},sidebar:"docs",previous:{title:"makeChangeNullabilityPlugin",permalink:"/postgraphile/next/make-change-nullability-plugin"},next:{title:"makeProcessSchemaPlugin",permalink:"/postgraphile/next/make-process-schema-plugin"}},l={},p=[{value:"Signature",id:"signature",level:2},{value:"Example",id:"example",level:2},{value:"The <code>gql</code> helper",id:"the-gql-helper",level:2},{value:"&quot;Special&quot; fields",id:"special-fields",level:2},{value:"Object type step assertion",id:"object-type-step-assertion",level:3},{value:"Type and field scopes",id:"type-and-field-scopes",level:3},{value:"Querying the database",id:"querying-the-database",level:2},{value:"Example",id:"example-1",level:3},{value:"Running custom SQL",id:"running-custom-sql",level:2},{value:"The executor",id:"the-executor",level:3},{value:"Example",id:"example-2",level:3},{value:"Reading database column values",id:"reading-database-column-values",level:2},{value:"Mutation Example",id:"mutation-example",level:2},{value:"Mutation Example with Node ID",id:"mutation-example-with-node-id",level:2},{value:"Polymorphism mutation example",id:"polymorphism-mutation-example",level:2},{value:"Plugin SQL Privileges",id:"plugin-sql-privileges",level:2}],u={toc:p},d="wrapper";function c(e){let{components:n,...t}=e;return(0,r.kt)(d,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"makeExtendSchemaPlugin")," is ",(0,r.kt)("em",{parentName:"p"},"the"),' plugin generator you need to know about. It\'s\nthe "bread and butter" of customizing your PostGraphile schema, enabling you to\nadd new fields and types to your GraphQL schema in a convenient and concise\nfamiliar syntax - GraphQL SDL.'),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Though the SDL syntax is used, it is not validated - if you define a type but\nnever use that type, that will likely not cause a schema validation error. If\nyou use a directive that does not exist (or pass the wrong arguments to a\ndirective), that's also unlikely to error. The SDL is just used as a convenient\nsyntax, it is converted under the hood into ",(0,r.kt)("a",{parentName:"p",href:"https://build.graphile.org/graphile-build/hooks"},"schema\nhooks")," as if you had written\na Graphile Build plugin by hand.")),(0,r.kt)("p",null,"If you're already familiar with the ",(0,r.kt)("inlineCode",{parentName:"p"},"typeDefs"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"resolvers")," pattern used by\nsystems such as ",(0,r.kt)("inlineCode",{parentName:"p"},"graphql-tools")," then using ",(0,r.kt)("inlineCode",{parentName:"p"},"makeExtendSchemaPlugin")," should feel\nfamiliar for you."),(0,r.kt)("h2",{id:"signature"},"Signature"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"makeExtendSchemaPlugin")," is called with a single parameter: a callback\nfunction. This function will be passed the ",(0,r.kt)("inlineCode",{parentName:"p"},"build")," object, and it must return\n(synchronously) an object defining ",(0,r.kt)("inlineCode",{parentName:"p"},"typeDefs"),", and one or more of ",(0,r.kt)("inlineCode",{parentName:"p"},"plans"),"\nand/or ",(0,r.kt)("inlineCode",{parentName:"p"},"resolvers"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"build")," argument to the makeExtendSchemaPlugin callback contains lots of\ninformation and helpers defined by various plugins, in particular the registry\n(",(0,r.kt)("inlineCode",{parentName:"p"},"build.input.pgRegistry"),") which contains all the resources and codecs from\nintrospection, the inflection functions (",(0,r.kt)("inlineCode",{parentName:"p"},"build.inflection"),"), and the SQL helper\n(",(0,r.kt)("inlineCode",{parentName:"p"},"build.sql"),") which is an instance of\n",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/pg-sql2"},"pg-sql2"),"."),(0,r.kt)("p",null,"The callback should return an object with the following keys:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"typeDefs"),": a GraphQL AST generated with the ",(0,r.kt)("inlineCode",{parentName:"li"},"gql")," helper from\n",(0,r.kt)("inlineCode",{parentName:"li"},"postgraphile/utils")," (note this is NOT from the ",(0,r.kt)("inlineCode",{parentName:"li"},"graphql-tag")," library, ours\nworks in a slightly different way)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"plans")," (optional, recommended): an object keyed by GraphQL type name that you're adding\nor extending in ",(0,r.kt)("inlineCode",{parentName:"li"},"typeDefs"),", the values of which are objects keyed by the\nfieldName you've added, and the value of which is typically a plan resolver\nfunction (although it can be an object that defines both this and other\ndetails)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"resolvers")," (optional, not recommended): like ",(0,r.kt)("inlineCode",{parentName:"li"},"plans"),", except the functions are\na traditional resolver functions rather than plan resolver functions")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Unlike in PostGraphile v4, the fourth argument to the resolver functions in\n",(0,r.kt)("inlineCode",{parentName:"p"},"resolvers")," does ",(0,r.kt)("em",{parentName:"p"},"not")," contain Graphile Build-related helpers. Since the\nlookahead system from V4 has been replaced by Gra",(0,r.kt)("em",{parentName:"p"},"fast")," query planning, you\nshould use ",(0,r.kt)("inlineCode",{parentName:"p"},"plans")," rather than ",(0,r.kt)("inlineCode",{parentName:"p"},"resolvers"),".")),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { makeExtendSchemaPlugin, gql } from "postgraphile/utils";\nimport { constant } from "postgraphile/grafast";\n\nexport const MyPlugin = makeExtendSchemaPlugin((build) => {\n  // Get any helpers we need from `build`\n  const { sql, inflection } = build;\n\n  return {\n    typeDefs: gql`\n      extend type Query {\n        meaningOfLife: Int\n      }\n    `,\n\n    plans: {\n      Query: {\n        meaningOfLife() {\n          return constant(42);\n        },\n      },\n    },\n\n    /*\n    // Though makeExtendSchemaPlugin and Grafast both support traditional\n    // resolvers, plan resolvers are preferred for a "pure" Grafast schema.\n    // Here\'s what the above would look like with traditional resolvers:\n    resolvers: {\n      Query: {\n        meaningOfLife() {\n          return 42;\n        },\n      },\n    },\n    */\n  };\n});\n')),(0,r.kt)("h2",{id:"the-gql-helper"},"The ",(0,r.kt)("inlineCode",{parentName:"h2"},"gql")," helper"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"gql")," helper is responsible for turning the human-readable GraphQL schema\nlanguage you write into an abstract syntax tree (AST) that the application can\nunderstand. Our ",(0,r.kt)("inlineCode",{parentName:"p"},"gql")," help differs slightly from the one you may be familiar\nwith in the ",(0,r.kt)("inlineCode",{parentName:"p"},"graphql-tag")," npm module, namely in how the placeholders work. Ours\nis designed to work with PostGraphile's ",(0,r.kt)("a",{parentName:"p",href:"./inflection/"},"inflection system"),", so\nyou can embed strings directly. You may also embed other gql tags directly. For\nexample:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const nameOfType = "MyType"; // Or use the inflection system to generate a type\n\n// This tag interpolates the string `nameOfType` to allow dynamic naming of the\n// type.\nconst Type = gql`\n  type ${nameOfType} {\n    str: String\n    int: Int\n  }\n`;\n\n// This tag interpolates the entire definition in `Type` above.\nconst typeDefs = gql`\n  ${Type}\n\n  extend type Query {\n    fieldName: Type\n  }\n`;\n')),(0,r.kt)("h2",{id:"special-fields"},'"Special" fields'),(0,r.kt)("p",null,"In GraphQL, it is forbidden to name any fields beginning with ",(0,r.kt)("inlineCode",{parentName:"p"},"__")," (two\nunderscores) since that is reserved for introspection. We therefore use this\nprefix to provide additional details to types. What additional information is\nrelevant depends on the type:"),(0,r.kt)("h3",{id:"object-type-step-assertion"},"Object type step assertion"),(0,r.kt)("p",null,"Object types in Gra",(0,r.kt)("em",{parentName:"p"},"fast")," can ",(0,r.kt)("a",{parentName:"p",href:"https://grafast.org/grafast/plan-resolvers#asserting-an-object-types-step"},"indicate that they must be represented by a\nparticular\nstep"),"\nor one of a set of steps; this can help to catch bugs early. For example, in\nPostGraphile a database table resource should be represented by a\n",(0,r.kt)("inlineCode",{parentName:"p"},"pgSelectSingle")," or similar class; representing it with ",(0,r.kt)("inlineCode",{parentName:"p"},"object({id: 1})")," or\nsimilar would mean the step doesn't have the expected helper methods and\ndownstream fields may fail to plan because their expectations are broken."),(0,r.kt)("p",null,"Object types' ",(0,r.kt)("inlineCode",{parentName:"p"},"plans")," entries may define an ",(0,r.kt)("inlineCode",{parentName:"p"},"__assertStep")," property to indicate\nthe type of step the object type's fields' resolvers will be expecting; this is\nequivalent to ",(0,r.kt)("inlineCode",{parentName:"p"},"typeConfig.extensions.grafast.assertStep")," when defining a object\ntype programatically."),(0,r.kt)("p",null,"The value for ",(0,r.kt)("inlineCode",{parentName:"p"},"__assertStep")," can either be a step class itself (e.g.\n",(0,r.kt)("inlineCode",{parentName:"p"},"PgSelectSingleStep"),') or\nit can be an "assertion function" that throws an error if the passed step is\nnot of the right type, e.g.:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { makeExtendSchemaPlugin, gql } from \"postgraphile/utils\";\n\nconst schema = makeExtendSchemaPlugin({\n  typeDefs: gql`\n    type MyObject {\n      id: Int\n    }\n  `,\n  plans: {\n    MyObject: {\n      assertStep($step) {\n        if ($step instanceof PgSelectSingleStep) return true;\n        if ($step instanceof PgInsertSingleStep) return true;\n        if ($step instanceof PgUpdateSingleStep) return true;\n        throw new Error(\n          `Type 'User' expects a step of type PgSelectSingleStep, PgInsertSingleStep ` +\n            `or PgUpdateSingleStep; but found step of type '${$step.constructor.name}'.`,\n        );\n      },\n      a($obj: PgSelectSingleStep | PgInsertSingleStep | PgUpdateSingleStep) {\n        return $obj.get(\"id\");\n      },\n    },\n  },\n});\n")),(0,r.kt)("h3",{id:"type-and-field-scopes"},"Type and field scopes"),(0,r.kt)("p",null,'Graphile Build plugins use the "scope" that a type/field/argument/etc is\ndefined with in order to determine whether or not to hook that entity and\naugment it. For example, the builtin ',(0,r.kt)("inlineCode",{parentName:"p"},"PgFirstLastBeforeAfterArgsPlugin")," will\nautomatically add ",(0,r.kt)("inlineCode",{parentName:"p"},"first"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"last"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"before")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"after")," arguments to fields\nthat are scoped as ",(0,r.kt)("inlineCode",{parentName:"p"},"isPgFieldConnection: true")," and have an associated and\nsuitable ",(0,r.kt)("inlineCode",{parentName:"p"},"pgFieldResource")," scope set."),(0,r.kt)("p",null,'You can add to/overwrite the Graphile Build "scope" of a type by adding the\n',(0,r.kt)("inlineCode",{parentName:"p"},"__scope")," property to the object's ",(0,r.kt)("inlineCode",{parentName:"p"},"plans")," object."),(0,r.kt)("p",null,"You can add to/overwrite the Graphile Build scope of a field by making the\nfield definition an object (if it was previously a function, move the function\nto be inside the object using the ",(0,r.kt)("inlineCode",{parentName:"p"},"plan")," key) and adding the ",(0,r.kt)("inlineCode",{parentName:"p"},"scope")," property."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { makeExtendSchemaPlugin, gql } from "postgraphile/utils";\n\nconst schema = makeExtendSchemaPlugin((build) => {\n  const { users } = build.input.pgRegistry.pgResources;\n  return {\n    typeDefs: gql`\n      type MyObject {\n        id: Int\n      }\n    `,\n    plans: {\n      MyObject: {\n        // Graphile Build "scope" for the object type \'MyObject\'\n        __scope: {\n          pgTypeResource: users,\n        },\n\n        id: {\n          // The Graphile Build "scope" for the \'MyObject.id\' field\n          scope: {\n            pgFieldAttribute: users.codec.attributes.id,\n          },\n\n          // The plan resolver for the \'MyObject.id\' field\n          plan($obj) {\n            return $obj.get("id");\n          },\n        },\n      },\n    },\n  };\n});\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"makeExtendSchemaPlugin")," might try and guess the scopes to use to be helpful;\nif it gets them wrong then be sure to overwrite them using the instructions\nabove. To unset scopes, set them to ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),".")),(0,r.kt)("h2",{id:"querying-the-database"},"Querying the database"),(0,r.kt)("p",null,"You should read ",(0,r.kt)("a",{parentName:"p",href:"https://grafast.org/grafast/"},"the Gra",(0,r.kt)("em",{parentName:"a"},"fast")," introduction")," and\nthe ",(0,r.kt)("a",{parentName:"p",href:"https://grafast.org/grafast/plan-resolvers"},'page on "plan resolvers"'),"\nbefore reading further here."),(0,r.kt)("p",null,"Gra",(0,r.kt)("em",{parentName:"p"},"fast"),' operate based on "steps", instances of step classes, returned from\n"plan resolvers". Though there are many different step classes, most will\naccept as input any other step, no matter the class.'),(0,r.kt)("p",null,"However, the plan resolvers attached to the fields on a GraphQL type will\ntypically expect the incoming step to be of the right class, otherwise it will\nnot have the expected methods on it. For example, all the fields on a GraphQL\nobject type that PostGraphile has generated from a database table will expect\nthe parent step to be a ",(0,r.kt)("inlineCode",{parentName:"p"},"PgSelectSingleStep")," instance (or similar) so that they\nmay do things like ",(0,r.kt)("inlineCode",{parentName:"p"},"$row.get('avatar_url')")," and have that access the relevant\ncolumn in the database."),(0,r.kt)("p",null,"Thus, what you do inside your plan resolver and what you return from your plan\nresolver are two different concerns. It's essential that you return the right\nclass of step from your plan resolver, to be compatible with what the schema is\nexpecting, but you have a lot of freedom within your plan resolver as to how to\nachieve that."),(0,r.kt)("p",null,"One common desire is to access the data in the GraphQL context. You can access\nthis in Gra",(0,r.kt)("em",{parentName:"p"},"fast")," using the ",(0,r.kt)("inlineCode",{parentName:"p"},"context()")," step; for example, you may have stored\nthe current user's ID on the GraphQL context via the ",(0,r.kt)("inlineCode",{parentName:"p"},"userId")," property, to\nretrieve these you might do this in your plan resolver function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const $userId = context().get("userId");\n')),(0,r.kt)("p",null,'Data from the database can be retrieved using "resources." Resources can be\nfound on ',(0,r.kt)("inlineCode",{parentName:"p"},"build.input.pgRegistry.pgResources"),", keyed by their name. For\nexample, if you have ",(0,r.kt)("inlineCode",{parentName:"p"},"organizations"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"users")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"channels")," tables, you can\nget the resources for them via:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { organizations, users, channels } = build.input.pgRegistry.pgResources;\n")),(0,r.kt)("p",null,"Now that you have a reference to the ",(0,r.kt)("inlineCode",{parentName:"p"},"users")," resource, inside a plan resolver\nfunction you could get a step representing a set of rows using ",(0,r.kt)("inlineCode",{parentName:"p"},"resource.find"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const $users = users.find();\n//    ^ PgSelectStep - represents a set of rows\n")),(0,r.kt)("p",null,"Or you could get a step representing just a single row via ",(0,r.kt)("inlineCode",{parentName:"p"},"resource.get")," (the\nfilter argument is required, and must represent a combination of columns that\nmatches a unique constraint):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const $user = users.get({ id: $userId });\n//    ^ PgSelectSingleStep - represents a single row\n")),(0,r.kt)("p",null,"Now that you have a step representing a single row (",(0,r.kt)("inlineCode",{parentName:"p"},"$user"),") you can retrieve\nits column values using ",(0,r.kt)("inlineCode",{parentName:"p"},"$row.get"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const $organizationId = $user.get("organization_id");\n')),(0,r.kt)("p",null,"You could then feed this into another step, for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const $channels = channels.find({ organization_id: $organizationId });\n")),(0,r.kt)("h3",{id:"example-1"},"Example"),(0,r.kt)("p",null,"Pulling this all together, you could build a plugin that adds a ",(0,r.kt)("inlineCode",{parentName:"p"},"Query.myChannels")," field returning all the channels just from your organization:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { makeExtendSchemaPlugin, gql } from "postgraphile/utils";\nimport { context } from "postgraphile/grafast";\n\nexport const MyChannelsPlugin = makeExtendSchemaPlugin((build) => {\n  const { users, channels } = build.input.pgRegistry.pgResources;\n  return {\n    typeDefs: gql`\n      extend type Query {\n        myChannels: [Channel]\n      }\n    `,\n    plans: {\n      Query: {\n        myChannels() {\n          const $userId = context().get("userId");\n          const $user = users.get({ id: $userId });\n          const $orgId = $user.get("organization_id");\n          const $channels = channels.find({ organization_id: $orgId });\n          return $channels;\n        },\n      },\n    },\n  };\n});\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Channel")," type used in the ",(0,r.kt)("inlineCode",{parentName:"p"},"typeDefs")," above is the type that PostGraphile\ngenerated automatically for the ",(0,r.kt)("inlineCode",{parentName:"p"},"channels")," table. See\n",(0,r.kt)("a",{parentName:"p",href:"/postgraphile/next/tables"},"Tables")," for more on the artifacts generated for each\ndatabase table.")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Though you might be thinking that this would result in multiple requests being\nissued to the database, thanks to the magic of Gra",(0,r.kt)("em",{parentName:"p"},"fast")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"@dataplan/pg"),",\nthis is not the case. During the optimization phase for the operation plan,\n",(0,r.kt)("inlineCode",{parentName:"p"},"@dataplan/pg")," will recognize that all of these steps represent data coming\nfrom the database, and will optimize this into something roughly equivalent to:"),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"select ...\nfrom channels\nwhere organization_id = (\n  select users.organization_id\n  from users\n  where users.id = $1\n);\n"))),(0,r.kt)("h2",{id:"running-custom-sql"},"Running custom SQL"),(0,r.kt)("p",null,"As mentioned above, though what we return from the plan resolver is critical,\nhow we get there is less so. If we want, we can replace some of the logic above\nwith our own custom logic, so long as the result of the plan resolver is still\na ",(0,r.kt)("inlineCode",{parentName:"p"},"PgSelectStep")," representing a set of rows."),(0,r.kt)("p",null,"One way to issue arbitrary SQL queries against the database is to use the\n",(0,r.kt)("inlineCode",{parentName:"p"},"withPgClient")," step, or its cousin ",(0,r.kt)("inlineCode",{parentName:"p"},"withPgClientTransaction"),'. These both accept\nan "executor" as the first argument, a step representing arbitrary data as the\nsecond argument, and an asynchronous callback as the third argument. The callback\nwill be called with a ',(0,r.kt)("inlineCode",{parentName:"p"},"PgClient")," instance and the resolved data from the step\nin the second argument."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"PgClient")," instance is an abstraction provided by ",(0,r.kt)("inlineCode",{parentName:"p"},"@dataplan/pg"),", it\ncontains common functionality but also any helpers that the specific Postgres\nadaptor you're using wishes to expose. ",(0,r.kt)("a",{parentName:"p",href:"https://grafast.org/grafast/step-library/dataplan-pg/adaptors"},"Read more about Postgres adaptors in\nthe @dataplan/pg\ndocumentation"),".")),(0,r.kt)("h3",{id:"the-executor"},"The executor"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"What is an executor?")),(0,r.kt)("p",null,"It's the thing that tells Gra",(0,r.kt)("em",{parentName:"p"},"fast")," (or, more\nspecifically, ",(0,r.kt)("inlineCode",{parentName:"p"},"@dataplan/pg"),") how to communicate with the database. Normally\nit's embedded directly into the resources, but since we're doing arbitrary SQL\nno resource is involved."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Why is it explicit rather than implicit?")),(0,r.kt)("p",null,"The simple answer for that is that there can be more than one\nexecutor, for example if your schema represents more than one PostgreSQL\ndatabase."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"How do I get an executor?")),(0,r.kt)("p",null,"You can get the executor from any resource representing the target database,\nfor example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { executor } = channels;\n")),(0,r.kt)("h3",{id:"example-2"},"Example"),(0,r.kt)("p",null,"Here's the previous example again, this time rewritten to use ",(0,r.kt)("inlineCode",{parentName:"p"},"withPgClient")," to\nretrieve the ",(0,r.kt)("inlineCode",{parentName:"p"},"organization_id")," rather than the user resource:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { makeExtendSchemaPlugin, gql } from "postgraphile/utils";\nimport { context } from "postgraphile/grafast";\n// highlight-next-line\nimport { withPgClient } from "postgraphile/@dataplan/pg";\n\nexport const MyChannelsPlugin = makeExtendSchemaPlugin((build) => {\n  const { channels } = build.input.pgRegistry.pgResources;\n  const { executor } = channels;\n\n  return {\n    typeDefs: gql`\n      extend type Query {\n        myChannels: [Channel]\n      }\n    `,\n    plans: {\n      Query: {\n        myChannels() {\n          const $userId = context().get("userId");\n          // highlight-start\n          const $orgId = withPgClient(\n            executor,\n            $userId,\n            async (\n              // The PgClient instance, with all of the "claims" (if any) already set:\n              pgClient,\n              // This is the runtime data that the `$userId` step represented\n              userId,\n            ) => {\n              if (!userId) return null;\n\n              // Here we\'re using the standard `pgClient.query` function that\n              // all adaptors must provide, but if you\'re using an adaptor\n              // related to your ORM of choice, you could likely use its\n              // various methods to retrieve this value instead.\n              const result = await pgClient.query<{ id: number }>({\n                text: `select id from get_organization_for_user_id($1)`,\n                values: [userId],\n              });\n\n              // Return the \'id\' value from the first (and only) row, if it exists:\n              return result.rows[0]?.id;\n            },\n          );\n          // highlight-end\n          const $channels = channels.find({ organization_id: $orgId });\n          return $channels;\n        },\n      },\n    },\n  };\n});\n')),(0,r.kt)("h2",{id:"reading-database-column-values"},"Reading database column values"),(0,r.kt)("p",null,"When extending a schema, it's often because you want to expose data from Node.js\nthat would be too difficult (or impossible) to access from PostgreSQL. When\ndefining a field on an existing table-backed type defined by PostGraphile, it's\nuseful to access data from the underlying table in the plan resolver."),(0,r.kt)("p",null,"To do this you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"$row.get(columnName)")," method, where ",(0,r.kt)("inlineCode",{parentName:"p"},"$row")," is the\nfirst parameter passed to your plan resolver function (representing the current\nrecord)."),(0,r.kt)("p",null,"Here's an example to illustrate."),(0,r.kt)("p",null,"In the database you have a ",(0,r.kt)("inlineCode",{parentName:"p"},"product")," table (imagine an online store), that\nPostGraphile will include in the GraphQL schema by creating a type ",(0,r.kt)("inlineCode",{parentName:"p"},"Product"),"\nwith fields ",(0,r.kt)("inlineCode",{parentName:"p"},"id"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"name"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"price_in_us_cents"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"create table product (\n  id uuid primary key,\n  name text not null,\n  price_in_us_cents integer not null\n);\n")),(0,r.kt)("p",null,"This may result in the following GraphQL type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-graphql"},"type Product {\n  id: UUID!\n  name: String!\n  priceInUsCents: Int!\n}\n")),(0,r.kt)("p",null,"However imagine you're selling internationally, and you want to expose the price\nin other currencies directly from the ",(0,r.kt)("inlineCode",{parentName:"p"},"Product")," type itself. This kind of\nfunctionality is well suited to being performed in Node.js (e.g. by making a\nREST call to a foreign exchange service over the internet) but might be a\nstruggle from with PostgreSQL."),(0,r.kt)("p",null,"We'll retrieve the ",(0,r.kt)("inlineCode",{parentName:"p"},"price_in_us_cents")," value from the database, and then use\nthe ",(0,r.kt)("a",{parentName:"p",href:"https://grafast.org/grafast/step-library/standard-steps/loadOne"},(0,r.kt)("inlineCode",{parentName:"a"},"loadOne"),"\nstep")," to\nbatch-convert these values from USD to AUD:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { makeExtendSchemaPlugin, gql } from "postgraphile/utils";\nimport { loadOne } from "postgraphile/grafast";\nimport { getExchangeRate } from "./myBusinessLogic.mjs";\n\n// highlight-start\nasync function convertUsdToAud(values) {\n  const usdToAud = await getExchangeRate("USD", "AUD");\n  return values.map((usd) => usd * usdToAud);\n}\n// highlight-end\n\nexport const MyForeignExchangePlugin = makeExtendSchemaPlugin((build) => {\n  return {\n    typeDefs: gql`\n      extend type Product {\n        priceInAuCents: Int!\n      }\n    `,\n    plans: {\n      Product: {\n        priceInAuCents($product) {\n          // highlight-next-line\n          const $cents = $product.get("price_in_us_cents");\n          // highlight-next-line\n          return loadOne($cents, convertUsdToAud);\n        },\n      },\n    },\n  };\n});\n')),(0,r.kt)("h2",{id:"mutation-example"},"Mutation Example"),(0,r.kt)("p",null,"You might want to add a custom ",(0,r.kt)("inlineCode",{parentName:"p"},"registerUser")," mutation which inserts the new\nuser into the database and also sends them an email:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { makeExtendSchemaPlugin, gql } from "postgraphile/utils";\nimport { access, constant, object } from "postgraphile/grafast";\nimport { withPgClientTransaction } from "postgraphile/@dataplan/pg";\n\nexport const MyRegisterUserMutationPlugin = makeExtendSchemaPlugin((build) => {\n  const { sql } = build;\n  const { users } = build.input.pgRegistry.pgResources;\n  const { executor } = users;\n  return {\n    typeDefs: gql`\n      input RegisterUserInput {\n        name: String!\n        email: String!\n        bio: String\n      }\n\n      type RegisterUserPayload {\n        user: User\n        query: Query\n      }\n\n      extend type Mutation {\n        registerUser(input: RegisterUserInput!): RegisterUserPayload\n      }\n    `,\n    plans: {\n      Mutation: {\n        registerUser(_, fieldArgs) {\n          const $input = fieldArgs.getRaw("input");\n          const $user = withPgClientTransaction(\n            executor,\n            $input,\n            async (pgClient, input) => {\n              // Our custom logic to register the user:\n              const {\n                rows: [user],\n              } = await pgClient.query({\n                text: `\n                  INSERT INTO app_public.users (name, email, bio)\n                  VALUES ($1, $2, $3)\n                  RETURNING *`,\n                values: [input.name, input.email, input.bio],\n              });\n\n              // Send the email. If this fails then the error will be caught\n              // and the transaction rolled back; it will be as if the user\n              // never registered\n              await mockSendEmail(\n                input.email,\n                "Welcome to my site",\n                `You\'re user ${user.id} - thanks for being awesome`,\n              );\n\n              // Return the newly created user\n              return user;\n            },\n          );\n\n          // To allow for future expansion (and for the `clientMutationId`\n          // field to work), we\'ll return an object step containing our data:\n          return object({ user: $user });\n        },\n      },\n\n      // The payload also needs plans detailing how to resolve its fields:\n      RegisterUserPayload: {\n        user($data) {\n          const $user = $data.get("user");\n          // It would be tempting to return $user here, but the step class\n          // is not compatible with the auto-generated `User` type, so\n          // errors will occur. We must ensure that we return a compatible\n          // step, so we will retrieve the relevant record from the database:\n\n          // Get the \'.id\' property from $user:\n          const $userId = access($user, "id");\n\n          // Return a step representing this row in the database.\n          return users.get({ id: $userId });\n        },\n        query($user) {\n          // Anything truthy should work for the `query: Query` field.\n          return constant(true);\n        },\n      },\n    },\n  };\n});\n')),(0,r.kt)("h2",{id:"mutation-example-with-node-id"},"Mutation Example with Node ID"),(0,r.kt)("p",null,"In this example we'll use a GraphQL Global Object Identifier (aka Node ID) to\nsoft-delete an entry from our ",(0,r.kt)("inlineCode",{parentName:"p"},"app_public.items")," table. We're also going to\ncheck that the user performing the soft-delete is the owner of the record."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Aside"),": if you're interested in soft-deletes, check out\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/graphile-contrib/pg-omit-archived"},"@graphile-contrib/pg-omit-archived")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { makeExtendSchemaPlugin, gql } from "postgraphile/utils";\nimport { context, list, specFromNodeId } from "postgraphile/grafast";\nimport { withPgClientTransaction } from "postgraphile/@dataplan/pg";\n\nconst DeleteItemByNodeIdPlugin = makeExtendSchemaPlugin((build) => {\n  // We need the nodeId handler for the Item type so that we can decode the ID.\n  const handler = build.getNodeIdHandler("Item")!;\n\n  // Extract the executor from the items resource\n  const { items } = build.input.pgRegistry.pgResources;\n  const { executor } = items;\n\n  return {\n    typeDefs: gql`\n      input DeleteItemInput {\n        id: ID!\n      }\n      type DeleteItemPayload {\n        success: Boolean\n      }\n      extend type Mutation {\n        deleteItem(input: DeleteItemInput!): DeleteItemPayload\n      }\n    `,\n\n    plans: {\n      Mutation: {\n        deleteItem(_, fieldArgs) {\n          // jwtClaims is decrypted jwt token data\n          const $jwtClaims = context().get("jwtClaims");\n\n          // Read the input.id value from the arguments\n          const $nodeId = fieldArgs.getRaw(["input", "id"]);\n\n          // Decode the node ID, to something like: `{ id: $someStep }`\n          const spec = specFromNodeId(handler, $nodeId);\n          const $itemId = spec.id;\n\n          const $success = withPgClientTransaction(\n            executor,\n            // Passing a `list` step allows us to pass more than one dependency\n            // through to our callback:\n            list([$jwtClaims, $itemId]),\n            async (pgClient, [jwtClaims, itemId]) => {\n              if (!itemId || !jwtClaims?.user_id) {\n                return false;\n              }\n              const {\n                rows: [row],\n              } = await pgClient.query(\n                ` UPDATE app_public.items\n                  SET is_archived = true\n                  WHERE id = $1\n                  AND user_id = $2\n                  RETURNING *;`,\n                [itemId, jwtClaims.user_id],\n              );\n              return !!row;\n            },\n          );\n\n          // Since we\'re returning this data in the same shape as the payload\n          // and the payload\'s fields don\'t need specific step classes, we don\'t\n          // need to implement plan resolvers on the payload.\n          return object({ success: $success });\n        },\n      },\n    },\n  };\n});\n')),(0,r.kt)("h2",{id:"polymorphism-mutation-example"},"Polymorphism mutation example"),(0,r.kt)("p",null,"This is a full example of adding a custom ",(0,r.kt)("inlineCode",{parentName:"p"},"registerUser")," mutation whose payload\ncontains a union of a successful result or two expected error types. It uses a\ntransaction to perform the mutation, and catches errors that happen in that\ntransaction (in which case the transaction will be rolled back) and if they are\nthe known, supported, errors then it will return the given error type. It uses\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"polymorphicBranch")," logic to determine which of the event occurred, and\nthus which type to return."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { withPgClient } from "@dataplan/pg";\nimport { gql, makeExtendSchemaPlugin } from "graphile-utils";\nimport {\n  ObjectStep,\n  constant,\n  object,\n  ExecutableStep,\n  access,\n  polymorphicBranch,\n  list,\n} from "postgraphile/grafast";\nimport { DatabaseError } from "pg";\n\nexport const RegisterUserPlugin = makeExtendSchemaPlugin((build) => {\n  const { users } = build.input.pgRegistry.pgResources;\n  const { executor } = users;\n  return {\n    typeDefs: gql`\n      extend type Mutation {\n        registerUser(input: RegisterUserInput!): RegisterUserPayload\n      }\n\n      input RegisterUserInput {\n        username: String!\n        email: String!\n      }\n\n      type RegisterUserPayload {\n        result: RegisterUserResult\n        query: Query\n      }\n\n      union RegisterUserResult = User | UsernameConflict | EmailAddressConflict\n\n      type UsernameConflict {\n        message: String!\n        username: String!\n      }\n\n      type EmailAddressConflict {\n        message: String!\n        email: String!\n      }\n    `,\n    plans: {\n      Mutation: {\n        registerUser(_, { $input: { $username, $email } }) {\n          const $result = withPgClient(\n            executor,\n            list([$username, $email]),\n            async (pgClient, [username, email]) => {\n              try {\n                return await pgClient.withTransaction(async (pgClient) => {\n                  const {\n                    rows: [user],\n                  } = await pgClient.query<{\n                    id: string;\n                    username: string;\n                  }>({\n                    text: `\n                      insert into app_public.users (username)\n                      values ($1)\n                      returning *`,\n                    values: [username],\n                  });\n\n                  await pgClient.query({\n                    text: `\n                      insert into app_public.user_emails(user_id, email)\n                      values ($1, $2)`,\n                    values: [user.id, email],\n                  });\n\n                  await sendEmail(email, "Welcome!");\n\n                  return { id: user.id };\n                });\n              } catch (e) {\n                if (e instanceof DatabaseError && e.code === "23505") {\n                  if (e.constraint === "unique_user_username") {\n                    return {\n                      __typename: "UsernameConflict",\n                      message: `The username \'${username}\' is already in use`,\n                      username,\n                    };\n                  } else if (e.constraint === "unique_user_email") {\n                    return {\n                      __typename: "EmailAddressConflict",\n                      message: `The email address \'${email}\' is already in use`,\n                      email,\n                    };\n                  }\n                }\n                throw e;\n              }\n            },\n          );\n\n          return object({ result: $result });\n        },\n      },\n\n      RegisterUserPayload: {\n        __assertStep: ObjectStep,\n        result($data: ObjectStep) {\n          const $result = $data.get("result");\n          return polymorphicBranch($result, {\n            UsernameConflict: {\n              // This is a `UsernameConflict` if the object has a `__typename` property.\n              match(obj) {\n                return obj.__typename === "UsernameConflict";\n              },\n              // In this case, we can just return the object itself as the step\n              // representing this polymorphic branch.\n              plan($obj) {\n                return $obj;\n              },\n            },\n            EmailAddressConflict: {\n              // If `match` is not specified, it defaults to checking\n              // `obj.__typename === \'EmailAddressConfict\'`.\n              // If `plan` is not specified, it defaults to `($obj) => $obj`.\n            },\n            User: {\n              match(obj) {\n                return obj.id != null;\n              },\n              // In this case, we need to get the record from the database\n              // associated with the given user id.\n              plan($obj) {\n                const $id = access($obj, "id");\n                return users.get({ id: $id });\n              },\n            },\n          });\n        },\n        query() {\n          // The `Query` type just needs any truthy value.\n          return constant(true);\n        },\n      },\n\n      UsernameConflict: {\n        // Since User expects a step, our types must also expect a step. We\n        // don\'t care what the step is though.\n        __assertStep: ExecutableStep,\n      },\n      EmailAddressConflict: {\n        __assertStep: ExecutableStep,\n      },\n    },\n  };\n});\n\nasync function sendEmail(email: string, message: string) {\n  /*\n    Write your email-sending logic here. Note that we recommend you enqueue a\n    job to send the email rather than sending it directly; if you don\'t already\n    have a job queue then check out https://worker.graphile.org\n  */\n}\n')),(0,r.kt)("h2",{id:"plugin-sql-privileges"},"Plugin SQL Privileges"),(0,r.kt)("p",null,"Plugins access the database with the same privileges as everything else - they\nare subject to RLS/RBAC/etc. If your database user does not have privileges to\nperform the action your plugin is attempting to achieve then you may need to\ncreate a companion database function that is marked as ",(0,r.kt)("inlineCode",{parentName:"p"},"SECURITY DEFINER")," in\norder to perform the action with elevated privileges; alternatively you could\nuse this database function directly - see ",(0,r.kt)("a",{parentName:"p",href:"./custom-mutations/"},"Custom\nMutations")," for more details."))}c.isMDXComponent=!0}}]);