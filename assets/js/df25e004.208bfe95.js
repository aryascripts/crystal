"use strict";(self.webpackChunk_localrepo_grafast_website=self.webpackChunk_localrepo_grafast_website||[]).push([[4596],{30876:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(n),m=r,h=c["".concat(l,".").concat(m)]||c[m]||u[m]||i;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},38115:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(7896),r=(n(2784),n(30876));const i={},o="node",s={unversionedId:"step-library/standard-steps/node",id:"step-library/standard-steps/node",title:"node",description:"A step to get a Node by its global object identifier (string). Accepts two parameters:",source:"@site/grafast/step-library/standard-steps/node.md",sourceDirName:"step-library/standard-steps",slug:"/step-library/standard-steps/node",permalink:"/grafast/step-library/standard-steps/node",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/grafast/website/grafast/step-library/standard-steps/node.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"loadOne",permalink:"/grafast/step-library/standard-steps/loadOne"},next:{title:"object",permalink:"/grafast/step-library/standard-steps/object"}},l={},p=[{value:"codecs",id:"codecs",level:2},{value:"handlers",id:"handlers",level:2},{value:"specFromNodeId",id:"specfromnodeid",level:2}],d={toc:p},c="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"node"},"node"),(0,r.kt)("p",null,"A step to get a Node by its global object identifier (string). Accepts two parameters:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"handlers"),": a map from typeName to handler spec (codec to use, how to find the record, etc) - see below"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"$id"),": the step (typically supplied from a field argument) representing the Node ID")),(0,r.kt)("p",null,"Returns a polymorphic-capable step representing the record this ",(0,r.kt)("inlineCode",{parentName:"p"},"$id")," represents."),(0,r.kt)("p",null,"Usage:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const $nodeIdString = fieldArgs.get("id");\nconst $node = node(handlers, $nodeIdString);\n')),(0,r.kt)("h2",{id:"codecs"},"codecs"),(0,r.kt)("p",null,"A node identifier is a string that uniquely identifies an entity in the GraphQL\nschema for the lifetime of that entity."),(0,r.kt)("p",null,"A codec is responsible for parsing and deparsing this string. There are many\ndifferent ways of encoding node identifiers, so we allow for many different\ncodecs."),(0,r.kt)("p",null,"A code is made of a ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," (string) and two methods:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"encode")," takes an intermediate representation and turns it into the final node identifier string"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"decode")," takes the final node identifier string and turns it back into an intermediate representation")),(0,r.kt)("p",null,"This intermediate representation is produced by and consumed by the handlers\n(see below)."),(0,r.kt)("p",null,"Here's an example ",(0,r.kt)("inlineCode",{parentName:"p"},"base64JSONCodec")," which simply JSON stringifies the\nintermediate representation and then base64 encodes it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'function base64JSONEncode(value: any): string | null {\n  return Buffer.from(JSON.stringify(value), "utf8").toString("base64");\n}\nbase64JSONEncode.isSyncAndSafe = true; // Optimization\n\nfunction base64JSONDecode(value: string): any {\n  return JSON.parse(Buffer.from(value, "base64").toString("utf8"));\n}\nbase64JSONDecode.isSyncAndSafe = true; // Optimization\n\nconst base64JSONCodec = {\n  name: "base64JSON",\n  encode: base64JSONEncode,\n  decode: base64JSONDecode,\n};\n')),(0,r.kt)("h2",{id:"handlers"},"handlers"),(0,r.kt)("p",null,"Each GraphQL object type that supports the ",(0,r.kt)("inlineCode",{parentName:"p"},"Node")," interface must have its own\n",(0,r.kt)("inlineCode",{parentName:"p"},"NodeIdHandler"),". This handler specifies:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"typeName")," - the GraphQL object type name to which the handler applies"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"codec")," - the NodeID codec (see above) to use with this handler"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"match")," - determines whether a given intermediate representation of a node\nidentifier string (i.e. the result of ",(0,r.kt)("inlineCode",{parentName:"li"},"codec.decode()"),") relates to this type\nor not"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"plan")," - takes an entity of the given object type and return a step\nrepresenting the intermediate representation for this entity (ready to be fed\nto ",(0,r.kt)("inlineCode",{parentName:"li"},"codec.encode()"),")"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"getSpec"),' - builds a "specification" of the entity from a step representing a\nmatching intermediate representation'),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"get")," - given the specification from ",(0,r.kt)("inlineCode",{parentName:"li"},"getSpec")," above, returns a step\nrepresenting the entity identified by the matching node identifier string, if\nit exists")),(0,r.kt)("p",null,"Specifications (returned from ",(0,r.kt)("inlineCode",{parentName:"p"},"getSpec"),") may differ for each object type. They\ncould be something simple like just a step that represents the numeric primary\nkey in the database, or they may be more complex such as an object with\nmultiple keys where each key's value is a step representing a related value to\nmatch in the remote source."),(0,r.kt)("p",null,"Here's an example of a ",(0,r.kt)("inlineCode",{parentName:"p"},"userHandler"),", which could be used across a schema when\nhandling node identifiers for the ",(0,r.kt)("inlineCode",{parentName:"p"},"User")," type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const USER = "User";\n\nconst userHandler = {\n  typeName: USER,\n\n  codec: base64JSONCodec,\n\n  // Given a User record, return a step describing the data to be encoded by\n  // the codec:\n  plan($user: PgSelectSingleStep) {\n    return list([constant(USER), $user.get("id")]);\n  },\n\n  // Given the data decoded by the codec, determine if the data is for our\n  // type. In this particular handler, the check looks at the first entry in\n  // the list to see if it matches our type name.\n  match(list) {\n    return list[0] === USER;\n  },\n\n  // Given a step representing decoded data that passes the `match` test above,\n  // return a specifier object that can be used to retrieve or reference\n  // this entity.\n  getSpec($list: ListStep<any[]>) {\n    return {\n      id: access($list, 1),\n    };\n  },\n\n  // Given a spec (the result of `getSpec` above), return a step that resolves\n  // to the entity (if found).\n  get(spec: any) {\n    return pgResource.get(spec);\n  },\n};\n\nconst handlers = {\n  User: userHandler,\n  // Add more handlers here\n};\n')),(0,r.kt)("h2",{id:"specfromnodeid"},"specFromNodeId"),(0,r.kt)("p",null,"Given you have a Node ID represented by the step ",(0,r.kt)("inlineCode",{parentName:"p"},"$id")," and you already know\nwhat type it should be (e.g. for an ",(0,r.kt)("inlineCode",{parentName:"p"},"updateUser")," mutation you might know that\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"$id")," should represent a ",(0,r.kt)("inlineCode",{parentName:"p"},"User"),"), you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"specFromNodeId")," passing the\nrelevant handler to get a specification for the entity in question. This is\ntypically useful when you want to mutate an entity without having to actually\nretrieve it (if you want to retrieve it then use ",(0,r.kt)("inlineCode",{parentName:"p"},"node()")," above instead)."),(0,r.kt)("p",null,"If the handler doesn't match then the executable steps inside the resulting\nspec will resolve to null-ish values (or maybe raise an error)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"function specFromNodeId(\n  handler: NodeIdHandler<any>,\n  $id: ExecutableStep<string> | AnyInputStep,\n): any;\n")),(0,r.kt)("p",null,"Here's an example of an ",(0,r.kt)("inlineCode",{parentName:"p"},"updateUser")," mutation that uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"userHandler"),"\nexample handler from above:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const typeDefs = /* GraphQL */ `\n  extend type Mutation {\n    updateUser(id: ID!, patch: UserPatch!): UpdateUserPayload\n  }\n`;\n\nconst plans = {\n  Mutation: {\n    updateUser(parent, { $id }) {\n      // Turn the $id into a specifier:\n      const spec = specFromNodeId(userHandler, $id);\n\n      // Now use this specifier to plan an update for this user:\n      const $result = pgUpdateSingle(userSource, spec);\n\n      // Leave space in our result so we can add more properties later:\n      const $payload = object({ result: $result });\n\n      // Apply all the plans from the 'patch' argument (omitted for brevity):\n      fieldArgs.apply($payload);\n\n      // Return the payload plan:\n      return $payload;\n    },\n  },\n};\n")))}u.isMDXComponent=!0}}]);