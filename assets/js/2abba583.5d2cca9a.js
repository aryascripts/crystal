"use strict";(self.webpackChunk_localrepo_postgraphile_website=self.webpackChunk_localrepo_postgraphile_website||[]).push([[3169],{30876:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var i=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),u=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return i.createElement(l.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=u(n),h=a,m=c["".concat(l,".").concat(h)]||c[h]||d[h]||r;return n?i.createElement(m,o(o({ref:t},p),{},{components:n})):i.createElement(m,o({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:a,o[1]=s;for(var u=2;u<r;u++)o[u]=n[u];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},80255:(e,t,n)=>{n.d(t,{Z:()=>r});var i=n(74224),a=n(2784);function r(){return a.createElement(a.Fragment,null,a.createElement("span",{className:i.Z.proTag},a.createElement("a",{href:"/pricing/"},a.createElement("span",{className:i.Z.firstLetter},"P"),"ro")))}},50058:(e,t,n)=>{n.d(t,{Z:()=>r});var i=n(74224),a=n(2784);function r(){return a.createElement(a.Fragment,null,a.createElement("span",{className:i.Z.sponTag},a.createElement("a",{href:"/sponsor/"},a.createElement("span",{className:i.Z.firstLetter},"S"),"pon")))}},24346:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>u,toc:()=>c});var i=n(7896),a=(n(2784),n(30876)),r=n(80255),o=n(50058);const s={layout:"page",path:"/postgraphile/live-queries/",title:"Live Queries"},l=void 0,u={unversionedId:"live-queries",id:"version-4.x/live-queries",title:"Live Queries",description:"A \u201clive query\u201d monitors the query a user provides and gives the client an updated version whenever the query would return a different result.",source:"@site/versioned_docs/version-4.x/live-queries.md",sourceDirName:".",slug:"/live-queries",permalink:"/postgraphile/current/live-queries",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/postgraphile/website/versioned_docs/version-4.x/live-queries.md",tags:[],version:"4.x",frontMatter:{layout:"page",path:"/postgraphile/live-queries/",title:"Live Queries"},sidebar:"docs",previous:{title:"GraphQL Subscriptions",permalink:"/postgraphile/current/subscriptions"},next:{title:"Background Tasks in PostGraphile",permalink:"/postgraphile/current/background-tasks"}},p={},c=[{value:"What are live queries?",id:"what-are-live-queries",level:3},{value:"Live queries via logical decoding",id:"live-queries-via-logical-decoding",level:3},{value:"When (not) to use live queries",id:"when-not-to-use-live-queries",level:3},{value:"Enabling live queries",id:"enabling-live-queries",level:3},{value:"Realtime provider plugins",id:"realtime-provider-plugins",level:3},{value:"@graphile/subscriptions-lds",id:"graphilesubscriptions-lds",level:4},{value:"Configuration",id:"configuration",level:3},{value:"<code>LD_WAIT</code> (default 125)",id:"ld_wait-default-125",level:4},{value:"<code>LIVE_THROTTLE</code> (default 500)",id:"live_throttle-default-500",level:4},{value:"<code>LD_TABLE_PATTERN</code> (default &quot;*.*&quot;)",id:"ld_table_pattern-default-",level:4},{value:"Performance",id:"performance",level:3},{value:"Scaling",id:"scaling",level:3},{value:"Inflection",id:"inflection",level:3},{value:"Limitations",id:"limitations",level:3},{value:"Amazon RDS",id:"amazon-rds",level:3}],d={toc:c},h="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(h,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",{class:"intro"},"A \u201clive query\u201d monitors the query a user provides and gives the client an updated version whenever the query would return a different result."),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"This feature requires PostGraphile v4.4.0 or higher.")),(0,a.kt)("h3",{id:"what-are-live-queries"},"What are live queries?"),(0,a.kt)("p",null,"You can think of live queries as akin to extremely frequent polling of a regular\nquery, but without the bandwidth costs. Live queries are not yet an official\nfeature of GraphQL, and so there are a number of different implementations.\nPostGraphile\u2019s live queries do not require specific client software since we use\nthe standard GraphQL subscriptions interface \u2014 simply change your ",(0,a.kt)("inlineCode",{parentName:"p"},"query")," to a\n",(0,a.kt)("inlineCode",{parentName:"p"},"subscription")," and it becomes live, as in the following example\n(",(0,a.kt)("a",{parentName:"p",href:"https://github.com/graphile/livesotope"},"available on GitHub"),") showing\nreal-time points rankings of fictional players:"),(0,a.kt)("div",{class:"tc"},(0,a.kt)("img",{alt:"Changing a query to a live query",src:"/images/query2subscription.png",style:{maxHeight:"230px"}})),(0,a.kt)("p",null),(0,a.kt)("div",{class:"tc"},(0,a.kt)("img",{alt:"Demo of live query",src:"/images/live_demo_rankings.gif"})),(0,a.kt)("p",null,"Live queries are an incredibly powerful tool for frontend developers, as it\nmeans they don\u2019t need to worry about monitoring for changes in the data \u2014 they\nknow the data they\u2019ve requested will always be up to date. However, live queries\nare not a panacea: they can come with significant backend cost and/or\ncomplexity."),(0,a.kt)("p",null,"One way to achieve 100% accurate live queries is to run the users query over and\nover on the server side, and send an update whenever the results change. This,\nhowever, is not very efficient and puts an excessive load on the server."),(0,a.kt)("h3",{id:"live-queries-via-logical-decoding"},"Live queries via logical decoding"),(0,a.kt)("p",null,'PostGraphile supports "realtime provider plugins" to source information about\nwhen data changes. Our initial official realtime provider plugin,\n',(0,a.kt)("inlineCode",{parentName:"p"},"@graphile/subscriptions-lds"),", monitors a \u201clogical replication slot\u201d from\nPostgreSQL (this is similar to the system that PostgreSQL read-replicas use to\nstay up to date with the primary database). This allows us to determine relevant\nchanges without putting too much additional load on the database."),(0,a.kt)("p",null,"However, we must re-run the user's query to see if anything else (e.g. computed\nvalues from functions, views, plugins, etc; reordering of results; effects on\npagination) has changed before returning the updated data to the user.\nTherefore, it\u2019s best to keep live queries small and simple: the more complex the\nquery, the more sources of change it has (so updates may happen more\nfrequently), and the longer it will take to execute."),(0,a.kt)("h3",{id:"when-not-to-use-live-queries"},"When (not) to use live queries"),(0,a.kt)("p",null,"PostGraphile has worked hard to decrease the costs associated with live queries,\nbut there\u2019s still more to be done. Currently we feel PostGraphile live queries\nmay be suitable in apps with relatively small user bases (such as for internal\ntooling used across a large enterprise), but if you\u2019re targeting an internet\nscale deployment hoping for millions of users you will likely be better off\nusing ",(0,a.kt)("a",{parentName:"p",href:"./subscriptions/"},"subscriptions"),", or keeping live queries to a very small\narea of your application."),(0,a.kt)("p",null,'One particular problem to be aware of is the "thundering herd" \u2014 if thousands of\nusers are all subscribed to the same data, and that data is updated, then\nthousands of SQL queries will be issued against the database at the same time.\nThis issue can be lessened by ensuring that live queries only apply to a subset\nof users at a time.'),(0,a.kt)("h3",{id:"enabling-live-queries"},"Enabling live queries"),(0,a.kt)("p",null,"To enable live queries support in PostGraphile, you will need:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"to pass ",(0,a.kt)("inlineCode",{parentName:"li"},"--live")," (or ",(0,a.kt)("inlineCode",{parentName:"li"},"live: true"),")"),(0,a.kt)("li",{parentName:"ul"},"to provide a plugin that can inform PostGraphile of realtime changes")),(0,a.kt)("h3",{id:"realtime-provider-plugins"},"Realtime provider plugins"),(0,a.kt)("p",null,"You may track changes to your database data in many ways, for example using\ndatabase triggers and LISTEN/NOTIFY, using logical decoding, or even by\nstreaming from an external source such as Kafka."),(0,a.kt)("p",null,"Currently we have one first-party realtime provider plugin,\n",(0,a.kt)("inlineCode",{parentName:"p"},"@graphile/subscriptions-lds"),":"),(0,a.kt)("h4",{id:"graphilesubscriptions-lds"},"@graphile/subscriptions-lds"),(0,a.kt)("p",null,"This plugin uses the Logical Decoding features of PostgreSQL to get a stream of\ndata changes very efficiently from the database (using its replication\ninterface). When a change occurs, if any of the live queries would be affected\nby it, they're informed of the change and PostGraphile re-runs the query and\nsends the results to the client - this ensures that database permissions are\nalways respected, and that no caching issues occur."),(0,a.kt)("p",null,"To enable this plugin, you must alter your PostgreSQL configuration\n",(0,a.kt)("inlineCode",{parentName:"p"},"postgresql.conf")," and ensure that the following settings are enabled:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"wal_level = logical\nmax_wal_senders = 10\nmax_replication_slots = 10\n")),(0,a.kt)("p",null,"You must also install the ",(0,a.kt)("inlineCode",{parentName:"p"},"wal2json")," extension into PostgreSQL if you don't\nalready have it (normally takes under 10 seconds):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"git clone https://github.com/eulerto/wal2json.git\ncd wal2json\nUSE_PGXS=1 make\nUSE_PGXS=1 make install\n")),(0,a.kt)("p",null,"Now PostgreSQL is ready, you can enable live queries support in PostGraphile.\nFirst, install the plugin:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"yarn add @graphile/subscriptions-lds\n")),(0,a.kt)("p",null,"Because of the power the replication interface gives, it's necessary to use a\nsuperuser or database owner account, so in addition to your normal connection\nstring you must also pass an \"owner\" connection string which has elevated\nprivileges. (If you're not using RLS/etc and normally use PostGraphile with a\nsuperuser/database owner account then this is unnecessary.)"),(0,a.kt)("p",null,"On the CLI:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"postgraphile \\\n  --connection postgres://postgraphile_user:postgraphile_pass@host/db \\\n  --live \\\n  --owner-connection postgres://db_owner:db_owner_pass@host/db \\\n  --append-plugins @graphile/subscriptions-lds \\\n  ...\n")),(0,a.kt)("p",null,"Via the library:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'app.use(\n  postgraphile(process.env.AUTH_DATABASE_URL, SCHEMA, {\n    // ...\n\n    // Enable live support in PostGraphile\n    live: true,\n    // We need elevated privileges for logical decoding\n    ownerConnectionString: process.env.ROOT_DATABASE_URL,\n    // Add this plugin\n    appendPlugins: [\n      //...\n      require("@graphile/subscriptions-lds").default,\n    ],\n  }),\n);\n')),(0,a.kt)("p",null,"Then to make a query live, you simply turn it into a subscription, e.g."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},"{\n  allPeople {\n    nodes {\n      name\n    }\n  }\n}\n")),(0,a.kt)("p",null,"would become:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},"subscription {\n  allPeople {\n    nodes {\n      name\n    }\n  }\n}\n")),(0,a.kt)("p",null,"More detailed instructions are available in the\n",(0,a.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@graphile/subscriptions-lds"},"@graphile/subscriptions-lds README"),"."),(0,a.kt)("h3",{id:"configuration"},"Configuration"),(0,a.kt)("p",null,"You can configure the live query support with the following environmental\nvariables:"),(0,a.kt)("h4",{id:"ld_wait-default-125"},(0,a.kt)("inlineCode",{parentName:"h4"},"LD_WAIT")," (default 125)"),(0,a.kt)("p",null,"This environmental variable controls how often in milliseconds we check for\nchanges from the database. Setting it smaller leads to more timely updates but\nincreases overhead. Setting it larger increases efficiency but means each batch\ntakes longer to process which may slow the Node.js event loop."),(0,a.kt)("h4",{id:"live_throttle-default-500"},(0,a.kt)("inlineCode",{parentName:"h4"},"LIVE_THROTTLE")," (default 500)"),(0,a.kt)("p",null,"This environmental variable is the minimum duration in milliseconds between live\nupdates to the same subscription."),(0,a.kt)("p",null,"If your server is getting overwhelmed, you may increase this to increase the\nperiod between live updates sent to clients."),(0,a.kt)("p",null,"If your application is not responsive enough, you may decrease this to get\ncloser to real-time updates."),(0,a.kt)("p",null,"(Throttle fires on both the leading and trailing edge, so decreasing this only\naffects successive updates, not the initial update.)"),(0,a.kt)("h4",{id:"ld_table_pattern-default-"},(0,a.kt)("inlineCode",{parentName:"h4"},"LD_TABLE_PATTERN"),' (default "',"*",".","*",'")'),(0,a.kt)("p",null,"Set this envvar to e.g. ",(0,a.kt)("inlineCode",{parentName:"p"},"app_public.*")," to only monitor tables in the\n",(0,a.kt)("inlineCode",{parentName:"p"},"app_public")," schema. See\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/eulerto/wal2json#parameters"},(0,a.kt)("inlineCode",{parentName:"a"},"filter-tables")," in the wal2json documentation"),".\nThis should increase performance by ignoring irrelevant data."),(0,a.kt)("h3",{id:"performance"},"Performance"),(0,a.kt)("p",null,"Live queries are a lot more expensive than regular subscriptions \u2014 the server\nmust monitor a lot more sources to detect a change (monitoring each individual\nrecord returned, plus monitoring for additions/removals from any collection\nincluding filtering constraints), and changes will most likely be more frequent\nas they're coming from multiple sources. Use live queries with care - it's wise\nto keep the queries as small as possible since they must be recalculated any\ntime anything within the query results changes."),(0,a.kt)("p",null,'Logical decoding uses a "logical" PostgreSQL replication slot (replication slots\nare the technology behind how PostgreSQL read replicas stay up to date with the\nprimary). We poll this slot for changes using the efficient\n',(0,a.kt)("inlineCode",{parentName:"p"},"pg_logical_slot_get_changes")," API in PostgreSQL. When a change is detected, we\ncheck to see if this change is relevant to any of the running live queries, and\nif so we tell that live query to refetch its data."),(0,a.kt)("p",null,"This refetching process requires the query to be executed again (in order for us\nto ensure any requested data still matches the permissions you have set via RLS,\nand to ensure that no old (cached) data can make the request\ninconsistent/stale). However, it does come at a cost as any relevant data may\ntrigger multiple (or ",(0,a.kt)("em",{parentName:"p"},"all"),') connected clients to all request the same data at\nthe same time (the "thundering herd" problem). We solve this slightly by giving\neach client their own throttled callback, so the callbacks are offset. There\'s a\nlot more that can be done to optimise our logical decoding support, so if you\nget to a point where logical decoding performance is an issue, please get in\ntouch!'),(0,a.kt)("p",null,"Optimization steps you can take currently:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Whitelist (or otherwise limit) the live queries that your system may perform"),(0,a.kt)("li",{parentName:"ul"},"Only write small non-overlapping live queries - since the entire query must\nrun again on change it's better to have 20 small queries than one large one\n(quite the opposite to normal queries!)"),(0,a.kt)("li",{parentName:"ul"},"Use ",(0,a.kt)("inlineCode",{parentName:"li"},"LD_TABLE_PATTERN")," to ignore irrelevant data"),(0,a.kt)("li",{parentName:"ul"},"Increase ",(0,a.kt)("inlineCode",{parentName:"li"},"LIVE_THROTTLE")," and/or ",(0,a.kt)("inlineCode",{parentName:"li"},"LD_WAIT")," to reduce the frequency data is\nrecalculated"),(0,a.kt)("li",{parentName:"ul"},"Move the logical decoding system to a dedicated server"),(0,a.kt)("li",{parentName:"ul"},"Add more ",(0,a.kt)("inlineCode",{parentName:"li"},"liveConditions")," to queries to filter rows the user may not see so\nthat they do not trigger live updates for that user (TODO: document this!)"),(0,a.kt)("li",{parentName:"ul"},"Use read replicas ",(0,a.kt)(r.Z,{mdxType:"Pro"}),"\xa0",(0,a.kt)(o.Z,{mdxType:"Spon"}))),(0,a.kt)("p",null,"We do not currently recommend live queries for very large deployments - if\nyou're expecting tens of thousands of concurrent users it's going to be\nsignificantly more efficient to use regular ",(0,a.kt)("a",{parentName:"p",href:"./subscriptions/"},"subscriptions"),"."),(0,a.kt)("h3",{id:"scaling"},"Scaling"),(0,a.kt)("p",null,"Once you reach beyond a few PostGraphile instances you'll want to make your live\ndecoding usage more efficient. We support this by allowing you to run a\ndedicated live decoding server (LDS) and have PostGraphile instances connect to\nthis server. You can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"LDS_URL")," envvar to tell PostGraphile where to find\nthis shared server. To set up the server, follow the instructions in the\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/graphile/graphile-engine/blob/master/packages/lds/README.md"},"@graphile/lds"),"\nproject. When running LDS standalone like this, there are more options for\nconfiguring it."),(0,a.kt)("h3",{id:"inflection"},"Inflection"),(0,a.kt)("p",null,"By default, live fields use the same names as fields in the ",(0,a.kt)("inlineCode",{parentName:"p"},"Query")," type;\nhowever these field names are sent through the ",(0,a.kt)("inlineCode",{parentName:"p"},"live")," inflector so you may\ncustomise these if you wish using ",(0,a.kt)("a",{parentName:"p",href:"./inflection/"},"the inflection system"),"."),(0,a.kt)("h3",{id:"limitations"},"Limitations"),(0,a.kt)("p",null,"Note that each live provider plugin has its own limitations, and may not be able\nto detect all changes. For example ",(0,a.kt)("inlineCode",{parentName:"p"},"@graphile/subscriptions-lds")," can detect\nchanges to results queried from tables, but cannot currently detect changes to\nresults queried from views and functions. In particular, computed columns are\nnot kept up to date (although they are re-calculated whenever a table update\ntriggers the subscription)."),(0,a.kt)("p",null,"Monitored tables must also use primary keys. Problems may arise if such key is a\n",(0,a.kt)("inlineCode",{parentName:"p"},"bigint")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"bigserial")," due to how PostgreSQL serializes these to JSON as a\nnumber (which is allowed by the JSON spec), but JavaScript's JSON.parse will not\nmaintain precision when parsing them, leading to potential divergence. We\nrecommend the key to be either a regular ",(0,a.kt)("inlineCode",{parentName:"p"},"int")," or a ",(0,a.kt)("inlineCode",{parentName:"p"},"uuid"),"."),(0,a.kt)("h3",{id:"amazon-rds"},"Amazon RDS"),(0,a.kt)("p",null,"Configuring Live Queries on Amazon RDS is slightly different, as it's a managed\nservice. (Also note that RDS runs a slightly out-of-date ",(0,a.kt)("inlineCode",{parentName:"p"},"wal2json"),".)"),(0,a.kt)("p",null,"To set up your RDS server:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Go to 'Parameter groups' in the AWS management console and change the\n",(0,a.kt)("inlineCode",{parentName:"li"},"rds.logical_replication")," setting to ",(0,a.kt)("inlineCode",{parentName:"li"},"1"),", then reboot your database"),(0,a.kt)("li",{parentName:"ul"},"Connect to the RDS server as your superuser and\n",(0,a.kt)("inlineCode",{parentName:"li"},"grant rds_replication to DB_OWNER;")," where ",(0,a.kt)("inlineCode",{parentName:"li"},"DB_OWNER")," is the name of the\nPostgreSQL role that created your database.")))}m.isMDXComponent=!0},74224:(e,t,n)=>{n.d(t,{Z:()=>i});const i={contents:"contents_OrL_",content:"content_ilvp",row:"row_ARn8",header:"header_zTVt",footnote:"footnote_D0nB",footnoteText:"footnoteText_OEd0",note:"note_qBn0",small:"small_Gqq2",tagline:"tagline_Ld2x",tooltipped:"tooltipped_t_JO",tooltiptext:"tooltiptext_u7mD",proTag:"proTag_vRmB",sponTag:"sponTag_Nh0y",firstLetter:"firstLetter_NMLh"}}}]);