"use strict";(self.webpackChunk_localrepo_graphile_build_website=self.webpackChunk_localrepo_graphile_build_website||[]).push([[368],{876:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var i=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=i.createContext({}),s=function(e){var t=i.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=s(e.components);return i.createElement(p.Provider,{value:t},e.children)},h="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),h=s(n),u=a,m=h["".concat(p,".").concat(u)]||h[u]||c[u]||r;return n?i.createElement(m,o(o({ref:t},d),{},{components:n})):i.createElement(m,o({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=u;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[h]="string"==typeof e?e:a,o[1]=l;for(var s=2;s<r;s++)o[s]=n[s];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9390:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var i=n(7896),a=(n(2784),n(876));const r={layout:"page",path:"/graphile-build/plugins/",title:"Plugins",sidebar_position:2},o=void 0,l={unversionedId:"plugins",id:"plugins",title:"Plugins",description:"The plugin system Graphile Build uses is provided by the graphile-config",source:"@site/graphile-build/plugins.md",sourceDirName:".",slug:"/plugins",permalink:"/graphile-build/plugins",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/graphile-build/website/graphile-build/plugins.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{layout:"page",path:"/graphile-build/plugins/",title:"Plugins",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Graphile Build",permalink:"/graphile-build/"},next:{title:"Hooks",permalink:"/graphile-build/hooks"}},p={},s=[{value:"Presets",id:"presets",level:2},{value:"Writing Plugins",id:"writing-plugins",level:2},{value:"<code>inflection</code> scope",id:"inflection-scope",level:3},{value:"<code>gather</code> scope",id:"gather-scope",level:3},{value:"<code>schema</code> scope",id:"schema-scope",level:3},{value:"Example 1",id:"example-1",level:4},{value:"Example 2",id:"example-2",level:4}],d={toc:s},h="wrapper";function c(e){let{components:t,...n}=e;return(0,a.kt)(h,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The plugin system Graphile Build uses is provided by the ",(0,a.kt)("inlineCode",{parentName:"p"},"graphile-config"),"\nmodule. This module isn't specific to any project (it's used by Graphile Build,\nPostGraphile, Gra",(0,a.kt)("em",{parentName:"p"},"fast"),', Grafserv, and more), and it handles the common\nrequirements of a plugin and preset system (composing plugins, ordering them,\nhandling dependencies, disabling plugins, etc) without worrying about the\ndetails specific to any one use case. The specifics are handled by named\n"scopes", which are root-level keys in the plugin object.'),(0,a.kt)("p",null,"Graphile Build plugins are ",(0,a.kt)("inlineCode",{parentName:"p"},"graphile-config")," plugins that have one or more of\nthe following scopes:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"inflection")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"gather")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"schema"))),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Plugins with none of the scopes listed above can still be included in a\nGraphile Build preset, they will just have no effect. This allows users\nto share a single configuration across many different projects.")),(0,a.kt)("h2",{id:"presets"},"Presets"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"graphile-config")," also provides the preset system used by Graphile Build. A\npreset is simply a collection of other presets, plugins, and configuration\noptions to use. Presets can \"extend from\" other presets, and it's very common\nto start your preset off by extending Graphile Build's ",(0,a.kt)("inlineCode",{parentName:"p"},"defaultPreset"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js",metastring:'title="graphile.config.mjs"',title:'"graphile.config.mjs"'},'import { defaultPreset } from "graphile-build";\n\nexport default {\n  extends: [defaultPreset],\n};\n')),(0,a.kt)("p",null,"Once you have a preset, you can feed it into the relevant Graphile Build methods, such as ",(0,a.kt)("inlineCode",{parentName:"p"},"buildSchema"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js",metastring:"{3, 5}","{3,":!0,"5}":!0},'import { buildSchema } from "graphile-build";\nimport { printSchema } from "graphql";\nimport preset from "./graphile.config.mjs";\n\nconst schema = await buildSchema(preset);\nconsole.log(printSchema(schema));\n')),(0,a.kt)("h2",{id:"writing-plugins"},"Writing Plugins"),(0,a.kt)("p",null,"A Graphile Build plugin is a simple object with a ",(0,a.kt)("inlineCode",{parentName:"p"},"name"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"description"),",\n",(0,a.kt)("inlineCode",{parentName:"p"},"version")," and entries for any of the scopes it wishes to implement."),(0,a.kt)("p",null,"Here's a plugin that does nothing:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const NoopPlugin = {\n  name: "NoopPlugin",\n  version: "0.0.0",\n  description: "Does nothing",\n};\n')),(0,a.kt)("p",null,"The scopes that a plugin might implement relate to the phases of schema\nbuilding. Schema building starts with the ",(0,a.kt)("inlineCode",{parentName:"p"},"inflection")," phase, where the various\ninflectors which control the naming of things are registered and customized.\nNext comes the ",(0,a.kt)("inlineCode",{parentName:"p"},"gather")," phase, where data is collected (for example by\nperforming introspection against your database). Finally we have the ",(0,a.kt)("inlineCode",{parentName:"p"},"schema"),"\nphase where the behaviors of all the entities from the gather phase are\ndetermined and then the schema is generated."),(0,a.kt)("h3",{id:"inflection-scope"},(0,a.kt)("inlineCode",{parentName:"h3"},"inflection")," scope"),(0,a.kt)("p",null,"If a plugin wants to name things, or change how things are named, it would\nimplement the ",(0,a.kt)("inlineCode",{parentName:"p"},"inflection")," scope."),(0,a.kt)("p",null,"This plugin replaces the ",(0,a.kt)("inlineCode",{parentName:"p"},"builtin")," inflector so that the root types ",(0,a.kt)("inlineCode",{parentName:"p"},"Query"),",\n",(0,a.kt)("inlineCode",{parentName:"p"},"Mutation")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Subscription")," are renamed to ",(0,a.kt)("inlineCode",{parentName:"p"},"RootQuery"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"RootMutation")," and\n",(0,a.kt)("inlineCode",{parentName:"p"},"RootSubscription"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const RootNamingPlugin = {\n  name: "RootNamingPlugin",\n  version: "0.0.0",\n  description: "Prefixes \'Root\' to the root operation types",\n\n  inflection: {\n    replace: {\n      builtin(previous, options, text) {\n        if (["Query", "Mutation", "Subscription"].includes(text)) {\n          return `Root${text}`;\n        } else {\n          return previous(text);\n        }\n      },\n    },\n  },\n};\n')),(0,a.kt)("h3",{id:"gather-scope"},(0,a.kt)("inlineCode",{parentName:"h3"},"gather")," scope"),(0,a.kt)("p",null,"If a plugin needs to do something asynchronous, such as gather data from a\nremote source, or read it from a file, then that work should be done via the\n",(0,a.kt)("inlineCode",{parentName:"p"},"gather")," scope."),(0,a.kt)("h3",{id:"schema-scope"},(0,a.kt)("inlineCode",{parentName:"h3"},"schema")," scope"),(0,a.kt)("p",null,"Most commonly, Graphile Build plugins will want to implement the ",(0,a.kt)("inlineCode",{parentName:"p"},"schema")," scope\nin order to affect the GraphQL schema that is being built. The GraphQL schema\nis built by hooking the various configuration objects that are passed to the\nconstructors in GraphQL.js (such as ",(0,a.kt)("inlineCode",{parentName:"p"},"GraphQLObjectType"),",\n",(0,a.kt)("inlineCode",{parentName:"p"},"GraphQLInputObjectType"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"GraphQLUnionType"),", etc) and some of their\nconfiguration fields (such as ",(0,a.kt)("inlineCode",{parentName:"p"},"GraphQLObjectType"),"'s ",(0,a.kt)("inlineCode",{parentName:"p"},"fields")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"interfaces"),"\nconfiguration fields), and sometimes even the fields within that, or deeper\nstill. The deepest hook is ",(0,a.kt)("inlineCode",{parentName:"p"},"GraphQLObjectType_fields_field_args_arg")," which is\nused to manipulate a specific argument from the list of arguments from a\nspecific field from a list of fields on a specific GraphQL object type."),(0,a.kt)("p",null,"Every hook is passed three parameters, the first parameter is the entity\nconfiguration being manipulated, the second is the ",(0,a.kt)("a",{parentName:"p",href:"./build-object"},"build object"),"\nwhich is common to all hooks, and the third is the ",(0,a.kt)("a",{parentName:"p",href:"./context-object"},"context object"),"\nspecific to that hook, which gives a description (via the ",(0,a.kt)("inlineCode",{parentName:"p"},"scope"),") of what is\nactually being hooked."),(0,a.kt)("h4",{id:"example-1"},"Example 1"),(0,a.kt)("p",null,"For example this plugin adds a field to the root\nquery type by hooking ",(0,a.kt)("inlineCode",{parentName:"p"},"GraphQLObjectType_fields"),", and looking at the\n",(0,a.kt)("inlineCode",{parentName:"p"},"context.scope.isRootQuery")," to determine if this is the object that we want to\nmodify:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'import { constant } from "grafast";\n\nconst RootQueryFieldPlugin = {\n  name: "RootQueryFieldPlugin",\n  version: "0.0.0",\n  description: "Adds a field to the root Query type",\n\n  schema: {\n    hooks: {\n      GraphQLObjectType_fields(fields, build, context) {\n        // Only add the field to the root query type\n        if (!context.scope.isRootQuery) return fields;\n\n        // Add a field called `meaningOfLife`\n        fields.meaningOfLife = {\n          // It\'s an integer\n          type: build.graphql.GraphQLInt,\n\n          // When you call the field, you should always return the number \'42\'\n          plan() {\n            return constant(42);\n          },\n        };\n\n        return fields;\n      },\n    },\n  },\n};\n')),(0,a.kt)("h4",{id:"example-2"},"Example 2"),(0,a.kt)("p",null,"This plugin will add a field ",(0,a.kt)("inlineCode",{parentName:"p"},"random(sides: Int)")," to every GraphQLObjectType\nthat is generated:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'// No imports required!\n\nconst MyRandomFieldPlugin = {\n  name: "MyRandomFieldPlugin",\n  version: "0.0.0",\n\n  schema: {\n    GraphQLObjectType_fields(fields, build, context) {\n      const {\n        extend,\n        graphql: { GraphQLInt },\n        options: { myDefaultMin = 1, myDefaultMax = 100 },\n      } = build;\n      return extend(fields, {\n        random: {\n          type: GraphQLInt,\n          args: {\n            sides: {\n              type: GraphQLInt,\n            },\n          },\n          plan(_, fieldArgs) {\n            const $sides = fieldArgs.get("sides");\n            return lambda(\n              $sides,\n              (sides) =>\n                Math.floor(\n                  Math.random() * ((sides ?? myDefaultMax) - myDefaultMin + 1),\n                ) + myDefaultMin,\n            );\n          },\n        },\n      });\n    },\n  },\n};\n')),(0,a.kt)("p",null,"First it registers a hook on ",(0,a.kt)("inlineCode",{parentName:"p"},"GraphQLObjectType_fields")," which will be called for\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"fields")," property of every ",(0,a.kt)("inlineCode",{parentName:"p"},"GraphQLObjectType")," that is constructed."),(0,a.kt)("p",null,"The callback to this ",(0,a.kt)("a",{parentName:"p",href:"./hooks"},"hook")," is passed the three standard\noptions:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"input object, ",(0,a.kt)("inlineCode",{parentName:"li"},"fields"),", which is basically a\n",(0,a.kt)("a",{parentName:"li",href:"http://graphql.org/graphql-js/type/#graphqlobjecttype"},(0,a.kt)("inlineCode",{parentName:"a"},"GraphQLFieldConfigMap")," from graphql-js"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/graphile-build/build-object/"},(0,a.kt)("inlineCode",{parentName:"a"},"Build")," object")," (from which we're using\n",(0,a.kt)("inlineCode",{parentName:"li"},"extend")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"graphql.GraphQLInt")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/graphile-build/context-object/"},(0,a.kt)("inlineCode",{parentName:"a"},"Context")," object")," which it is ignoring; but\nif we wanted to filter which objects get the ",(0,a.kt)("inlineCode",{parentName:"li"},"random")," field added this would\nbe what we'd use")),(0,a.kt)("p",null,"Finally we're returning a derivative of the ",(0,a.kt)("inlineCode",{parentName:"p"},"fields")," that were input by adding\nan additonal property ",(0,a.kt)("inlineCode",{parentName:"p"},"field")," which is a GraphQL field config\n",(0,a.kt)("inlineCode",{parentName:"p"},"GraphQLFieldConfig")," (see the ",(0,a.kt)("a",{parentName:"p",href:"http://graphql.org/graphql-js/type/#graphqlobjecttype"},"GraphQL-js\ndocumentation"),") but with\nGra",(0,a.kt)("em",{parentName:"p"},"fast")," features mixed in - most notably the ",(0,a.kt)("inlineCode",{parentName:"p"},"plan")," (rather than a ",(0,a.kt)("inlineCode",{parentName:"p"},"resolve"),"\nmethod)."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"./hooks"},"Read more about hooks"),"."))}c.isMDXComponent=!0}}]);