"use strict";(self.webpackChunk_localrepo_postgraphile_website=self.webpackChunk_localrepo_postgraphile_website||[]).push([[4615],{30876:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var o=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(n),h=a,m=c["".concat(l,".").concat(h)]||c[h]||d[h]||i;return n?o.createElement(m,r(r({ref:t},u),{},{components:n})):o.createElement(m,r({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:a,r[1]=s;for(var p=2;p<i;p++)r[p]=n[p];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},80255:(e,t,n)=>{n.d(t,{Z:()=>i});var o=n(74224),a=n(2784);function i(){return a.createElement(a.Fragment,null,a.createElement("span",{className:o.Z.proTag},a.createElement("a",{href:"/pricing/"},a.createElement("span",{className:o.Z.firstLetter},"P"),"ro")))}},50058:(e,t,n)=>{n.d(t,{Z:()=>i});var o=n(74224),a=n(2784);function i(){return a.createElement(a.Fragment,null,a.createElement("span",{className:o.Z.sponTag},a.createElement("a",{href:"/sponsor/"},a.createElement("span",{className:o.Z.firstLetter},"S"),"pon")))}},54635:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>p,toc:()=>c});var o=n(7896),a=(n(2784),n(30876)),i=n(80255),r=n(50058);const s={layout:"page",path:"/postgraphile/production/",title:"Production Considerations"},l=void 0,p={unversionedId:"production",id:"version-4.x/production",title:"Production Considerations",description:"When it comes time to deploy your PostGraphile application to production,",source:"@site/versioned_docs/version-4.x/production.md",sourceDirName:".",slug:"/production",permalink:"/postgraphile/current/production",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/postgraphile/website/versioned_docs/version-4.x/production.md",tags:[],version:"4.x",frontMatter:{layout:"page",path:"/postgraphile/production/",title:"Production Considerations"},sidebar:"docs",previous:{title:"PostGraphile best practices",permalink:"/postgraphile/current/best-practices"},next:{title:"PostGraphile JWT Guide",permalink:"/postgraphile/current/jwt-guide"}},u={},c=[{value:"Database Access Considerations",id:"database-access-considerations",level:3},{value:"Common Middleware Considerations",id:"common-middleware-considerations",level:3},{value:"Denial of Service Considerations",id:"denial-of-service-considerations",level:3},{value:"Statement Timeout",id:"statement-timeout",level:4},{value:"Simple: Query Allowlist (&quot;persisted queries&quot; / &quot;persisted operations&quot;)",id:"simple-query-allowlist-persisted-queries--persisted-operations",level:4},{value:"Advanced",id:"advanced",level:4},{value:"Sending queries to read replicas",id:"sending-queries-to-read-replicas",level:4},{value:"Pagination caps",id:"pagination-caps",level:4},{value:"Limiting GraphQL query depth",id:"limiting-graphql-query-depth",level:4},{value:"EXPERIMENTAL GraphQL cost limit",id:"experimental-graphql-cost-limit",level:4}],d={toc:c},h="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(h,(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"When it comes time to deploy your PostGraphile application to production,\nthere's a few things you'll want to think about including topics such as\nlogging, security and stability. This article outlines some of the issues you\nmight face, and how to solve them."),(0,a.kt)("h3",{id:"database-access-considerations"},"Database Access Considerations"),(0,a.kt)("p",null,"PostGraphile is just a node app / middleware, so you can deploy it to any number\nof places: Heroku, Now.sh, a VM, a container such as Docker, or of course onto\nbare metal. Typically you won't run PostGraphile on the same\nhardware/container/VM as the database, so PostGraphile needs to be able to\nconnect to your database without you putting your DB at risk."),(0,a.kt)("p",null,"A standard way of doing this is to put the DB behind a firewall. However, if\nyou're using a system like Heroku or Now.sh you probably can't do that, so\ninstead you must make your DB accessible to the internet. When doing so here are\na few things we recommend:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Only allow connections over SSL (",(0,a.kt)("inlineCode",{parentName:"li"},"force_ssl")," setting)"),(0,a.kt)("li",{parentName:"ol"},"Use a secure username (not ",(0,a.kt)("inlineCode",{parentName:"li"},"root"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"admin"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"postgres"),", etc which are all\nfairly commonly used)"),(0,a.kt)("li",{parentName:"ol"},"Use a super secure password; you can use a command like this to generate\none: ",(0,a.kt)("inlineCode",{parentName:"li"},"openssl rand -base64 30 | tr '+/' '-_'")),(0,a.kt)("li",{parentName:"ol"},"Use a non-standard port for your PostgreSQL server if you can (pick a random\nport number)"),(0,a.kt)("li",{parentName:"ol"},"Use a hard-to-guess hostname, and never reveal the hostname to anyone who\ndoesn't need to know it"),(0,a.kt)("li",{parentName:"ol"},"If possible, limit the IP addresses that can connect to your DB to be just\nthose of your hosting provider.")),(0,a.kt)("p",null,"Heroku have some instructions on making RDS available for use under Heroku which\nshould also work for Now.sh or any other service:\n",(0,a.kt)("a",{parentName:"p",href:"https://devcenter.heroku.com/articles/amazon-rds"},"https://devcenter.heroku.com/articles/amazon-rds")),(0,a.kt)("p",null,"It is recommended that you use the ",(0,a.kt)("inlineCode",{parentName:"p"},"--no-ignore-rbac")," (or ",(0,a.kt)("inlineCode",{parentName:"p"},"ignoreRBAC: false")," in\nthe library). It inspects the RBAC (GRANT / REVOKE) privileges in the database\nand reflects these in your GraphQL schema. As is GraphQL best practices, this\nstill only results in one GraphQL schema (not one per user), so it takes the\nuser account you connect to PostgreSQL with (from your connection string) and\nwalks all the roles that this user can become within the database, and uses the\nunion of all these permissions. Using this flag is recommended, as it results in\na much leaner schema that doesn't contain functionality that you can't actually\nuse."),(0,a.kt)("h3",{id:"common-middleware-considerations"},"Common Middleware Considerations"),(0,a.kt)("p",null,"In a production app, you typically want to add a few common enhancements, e.g."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Logging"),(0,a.kt)("li",{parentName:"ul"},"Gzip or similar compression"),(0,a.kt)("li",{parentName:"ul"},"Security protections"),(0,a.kt)("li",{parentName:"ul"},"Rate limiting")),(0,a.kt)("p",null,"Since there's already a lot of options and opinions in this space, and they're\nnot directly related to the problem of serving GraphQL from your PostgreSQL\ndatabase, PostGraphile does not include these things by default. We recommend\nthat you use something like Express middlewares to implement these common\nrequirements. This is why we recommend\n",(0,a.kt)("a",{parentName:"p",href:"./usage-library/"},"using PostGraphile as a library")," for production usage."),(0,a.kt)("p",null,"Picking the Express (or similar) middlewares that work for you is beyond the\nscope of this article; below is an example of where to place these middlewares."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const express = require(\"express\");\nconst { postgraphile } = require(\"postgraphile\");\n\nconst app = express();\n\n/* Example middleware you might want to put in front of PostGraphile */\n// app.use(require('morgan')(...));\n// app.use(require('compression')({...}));\n// app.use(require('helmet')({...}));\n\napp.use(postgraphile(process.env.DATABASE_URL || \"postgres:///\"));\n\napp.listen(process.env.PORT || 3000);\n")),(0,a.kt)("p",null,"Should you want to use something like PostGraphile's built in logging, but send\nit to your own logging provider, you can compose a PostGraphile server plugin to\ndo so. Here's an example plugin that uses Nuxt's consola library for logging,\nyou could use it as a base for your own plugin:\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/graphile/postgraphile-log-consola"},"https://github.com/graphile/postgraphile-log-consola")),(0,a.kt)("h3",{id:"denial-of-service-considerations"},"Denial of Service Considerations"),(0,a.kt)("p",null,"When you run PostGraphile in production you'll want to ensure that people cannot\neasily trigger denial of service (DOS) attacks against you. Due to the nature of\nGraphQL it's easy to construct a small query that could be very expensive for\nthe server to run, for example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},"allUsers {\n  nodes {\n    postsByAuthorId {\n      nodes {\n        commentsByPostId {\n          userByAuthorId {\n            postsByAuthorId {\n              nodes {\n                commentsByPostId {\n                  userByAuthorId {\n                    postsByAuthorId {\n                      nodes {\n                        commentsByPostId {\n                          userByAuthorId {\n                            id\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n")),(0,a.kt)("p",null,"There's lots of techniques for protecting your server from these kinds of\nqueries; a great introduction to this subject is\n",(0,a.kt)("a",{parentName:"p",href:"https://dev-blog.apollodata.com/securing-your-graphql-api-from-malicious-queries-16130a324a6b"},"this blog post"),"\nfrom Apollo."),(0,a.kt)("p",null,"These techniques should be used in conjunction with common HTTP protection\nmethods such as rate limiting which are typically better implemented at a\nseparate layer; for example you could use\n",(0,a.kt)("a",{parentName:"p",href:"https://www.cloudflare.com/rate-limiting/"},"Cloudflare rate limiting")," for this,\nor an Express.js middleware."),(0,a.kt)("h4",{id:"statement-timeout"},"Statement Timeout"),(0,a.kt)("p",null,"One simple solution to this issue is to place a timeout on the database\noperations via the\n",(0,a.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/current/runtime-config-client.html#GUC-STATEMENT-TIMEOUT"},(0,a.kt)("inlineCode",{parentName:"a"},"statement_timeout")," PostgreSQL setting"),".\nThis will halt any query that takes longer than the specified number of\nmilliseconds to execute. This can still enable nefarious actors to have your\ndatabase work hard for that duration, but it does prevent these malicious\nqueries from running for an extended period, reducing the ease of a DoS (Denial\nof Service) attack. This solution is a good way to catch anything that may have\nslipped through the cracks of your other defences, or just to get you up and\nrunning while you work on more robust/lower level solutions, but when you expose\nyour GraphQL endpoint to the world it's better to cut things off at the source\nbefore a query is ever sent to the database using one or more of the techniques\ndetailed below."),(0,a.kt)("p",null,"Currently you can set this on a per-transaction basis using the\n",(0,a.kt)("a",{parentName:"p",href:"./usage-library/#pgsettings-function"},(0,a.kt)("inlineCode",{parentName:"a"},"pgSettings")," functionality")," in\nPostGraphile library mode, e.g.:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'app.use(\n  postgraphile(process.env.DATABASE_URL, "public", {\n    // ...\n    pgSettings: {\n      statement_timeout: "3000",\n    },\n  }),\n);\n')),(0,a.kt)("p",null,"You can also set this up on a per connection basis if you pass a correctly\nconfigured ",(0,a.kt)("inlineCode",{parentName:"p"},"pg.Pool")," instance to PostGraphile directly, e.g.:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const { Pool } = require('pg');\n\nconst pool = new Pool();\npool.on('connect', (client) => {\n  client.query('SET statement_timeout TO 3000')\n});\n\n// ...\napp.use(postgraphile(pool, \"public\", { ... }));\n// ...\n")),(0,a.kt)("h4",{id:"simple-query-allowlist-persisted-queries--persisted-operations"},'Simple: Query Allowlist ("persisted queries" / "persisted operations")'),(0,a.kt)("p",null,"If you do not intend to allow third parties to run arbitrary operations against\nyour API then using\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/graphile/persisted-operations"},"persisted operations")," as a\nquery allowlist is a highly recommended solution to protect your GraphQL\nendpoint. This technique ensures that only the operations you use in your own\napplications can be executed on the server, preventing malicious (or merely\ncurious) actors from executing operations which may be more expensive than those\nyou have written."),(0,a.kt)("p",null,"This technique is suitable for the vast majority of use cases and supports many\nGraphQL clients, but it does have a few caveats:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Your API will only accept operations that you've approved, so it's not\nsuitable if you want third parties to run arbitrary custom operations."),(0,a.kt)("li",{parentName:"ul"},'You must be able to generate a unique ID (e.g. a hash) from each operation at\nbuild time of your application/web page - your GraphQL operations must be\n"static". It\'s important to note this only applies to the operation document\nitself, the variables can of course change at runtime.'),(0,a.kt)("li",{parentName:"ul"},"You must have a way of sharing these static operations from the application\nbuild process to the server so that the server will know what operation the ID\nrepresents."),(0,a.kt)("li",{parentName:"ul"},"You must be careful not to use variables in dangerous places within your\noperation; for example if you were to use ",(0,a.kt)("inlineCode",{parentName:"li"},"allUsers(first: $myVar)")," a\nmalicious attacker could set ",(0,a.kt)("inlineCode",{parentName:"li"},"$myVar")," to 2147483647 to cause your server to\nprocess as much data as possible. Use fixed limits, conditions and orders\nwhere possible, even if it means having additional static operations."),(0,a.kt)("li",{parentName:"ul"},"It does not protect you from writing expensive queries yourself; it may be\nwise to combine this technique with a cost estimation technique such as that\nprovided by the ",(0,a.kt)("a",{parentName:"li",href:"/pricing/"},"Graphile Pro plugin")," to help guide your developers\nand avoid accidentally writing expensive queries.")),(0,a.kt)("p",null,"PostGraphile has first-party support for persisted operations via the open\nsource\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/graphile/persisted-operations"},"@graphile/persisted-operations"),"\nplugin; we recommend its use to the vast majority of our users."),(0,a.kt)("h4",{id:"advanced"},"Advanced"),(0,a.kt)("p",null,"Using a query allowlist puts the decision in the hands of your engineers whether\na particular query should be accepted or not. Sometimes this isn't enough - it\ncould be that your engineers need guidance to help them avoid common pit-falls\n(e.g. forgetting to put limits on collections they query), or it could be that\nyou wish arbitrary third parties to be able to send queries to your API without\nthe queries being pre-approved and without the risk of bringing your servers to\ntheir knees."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"You are highly encouraged to purchase the ",(0,a.kt)("a",{parentName:"p",href:"/pricing/"},"Pro Plugin")," ",(0,a.kt)(i.Z,{mdxType:"Pro"}),", which\nimplements these protections in a deeply-integrated and PostGraphile-optimized\nway. Sponsors ",(0,a.kt)(r.Z,{mdxType:"Spon"})," also have access to the Pro Plugin and have the added benefit\nof helping sustain development and maintenance on the project. You can read the\n",(0,a.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@graphile/pro"},"@graphile/pro README on npm"),".")),(0,a.kt)("p",null,"The following details how the Pro Plugin addresses these issues, including hints\non how you might go about solving the issues for yourself. Many of these\ntechniques can be implemented outside of PostGraphile, for example in an express\nmiddleware or a nginx reverse proxy between PostGraphile and the client."),(0,a.kt)("h4",{id:"sending-queries-to-read-replicas"},"Sending queries to read replicas"),(0,a.kt)("p",null,"Probably the most important thing regarding scalability is making sure that your\nmaster database doesn't bow under the pressure of all the clients talking to it.\nIt's wise to perform load testing to figure out at what point this will occur,\nand have a plan for it. One way to reduce this pressure is to offload read\noperations to read replicas (clones of your primary database)"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"this reduces the load on your primary database significantly, and reduces the\nneed for complex caching layers. In GraphQL it's easy to tell if a request\nwill perform any writes or not: if it's a ",(0,a.kt)("inlineCode",{parentName:"li"},"query")," then it's read-only, if it's\na ",(0,a.kt)("inlineCode",{parentName:"li"},"mutation")," then it may perform writes.")),(0,a.kt)("p",null,"Using ",(0,a.kt)("inlineCode",{parentName:"p"},"--read-only-connection <string>")," ",(0,a.kt)(i.Z,{mdxType:"Pro"}),"\xa0",(0,a.kt)(r.Z,{mdxType:"Spon"})," you may give PostGraphile a\nseparate connection string to use for queries, to compliment the connection\nstring passed via ",(0,a.kt)("inlineCode",{parentName:"p"},"--connection")," which will now be used only for mutations."),(0,a.kt)("p",null,"(If you're using middleware, then you should use the ",(0,a.kt)("inlineCode",{parentName:"p"},"readOnlyConnection")," option\ninstead.)"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"NOTE: We don't currently support the multi-host syntax for this connection\nstring, but you can use a PostgreSQL proxy such a PgPool or PgBouncer between\nPostGraphile and your database to enable connecting to multiple read replicas.")),(0,a.kt)("h4",{id:"pagination-caps"},"Pagination caps"),(0,a.kt)("p",null,"It's unlikely that you want users to request ",(0,a.kt)("inlineCode",{parentName:"p"},"allUsers")," and receive back\nliterally all of the users in the database. More likely you want users to use\ncursor-based pagination over this connection with ",(0,a.kt)("inlineCode",{parentName:"p"},"first")," / ",(0,a.kt)("inlineCode",{parentName:"p"},"after"),". The Pro\nPlugin introduces the ",(0,a.kt)("inlineCode",{parentName:"p"},"--default-pagination-cap [int]")," ",(0,a.kt)(i.Z,{mdxType:"Pro"}),"\xa0",(0,a.kt)(r.Z,{mdxType:"Spon"})," option (library\noption: ",(0,a.kt)("inlineCode",{parentName:"p"},"defaultPaginationCap"),") which enables you to enforce a pagination cap on\nall connections. Whatever number you pass will be used as the pagination cap\n(allowing requests smaller or equal to this cap to go through, and blocking\nthose above it), but you can override it on a table-by-table basis using\n",(0,a.kt)("a",{parentName:"p",href:"./smart-comments/"},"smart comments")," - in this case the ",(0,a.kt)("inlineCode",{parentName:"p"},"@paginationCap"),(0,a.kt)(i.Z,{mdxType:"Pro"}),"\xa0",(0,a.kt)(r.Z,{mdxType:"Spon"}),"\nSmart Comment."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"comment on table users is\n  E'@paginationCap 20\\nSomeone who can log in.';\n")),(0,a.kt)("h4",{id:"limiting-graphql-query-depth"},"Limiting GraphQL query depth"),(0,a.kt)("p",null,"Most GraphQL queries tend to be only a few levels deep, queries like the deep\none at the top of this article are generally not required. You may use\n",(0,a.kt)("inlineCode",{parentName:"p"},"--graphql-depth-limit [int]")," ",(0,a.kt)(i.Z,{mdxType:"Pro"}),"\xa0",(0,a.kt)(r.Z,{mdxType:"Spon"})," to limit the depth of any GraphQL queries\nthat hit PostGraphile - any deeper than this will be discarded during query\nvalidation."),(0,a.kt)("h4",{id:"experimental-graphql-cost-limit"},"[EXPERIMENTAL]"," GraphQL cost limit"),(0,a.kt)("p",null,"The most powerful way of preventing DOS is to limit the cost of GraphQL queries\nthat may be executed against your GraphQL server. The Pro Plugin contains a\nearly implementation of this technique with heuristically estimated costs. You\nmay enable a cost limit with ",(0,a.kt)("inlineCode",{parentName:"p"},"--graphql-cost-limit [int]")," ",(0,a.kt)(i.Z,{mdxType:"Pro"}),"\xa0",(0,a.kt)(r.Z,{mdxType:"Spon"})," and the\ncalculated cost of any GraphQL queries will be made available on ",(0,a.kt)("inlineCode",{parentName:"p"},"meta")," field in\nthe GraphQL payload."),(0,a.kt)("p",null,"If your GraphQL query is seen to be too expensive, here's some techniques to\nbring the calculated cost down:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If you've not specified a limit (",(0,a.kt)("inlineCode",{parentName:"li"},"first"),"/",(0,a.kt)("inlineCode",{parentName:"li"},"last"),") on a connection, we assume it\nwill return 1000 results. You should always specify a limit."),(0,a.kt)("li",{parentName:"ul"},"Cost is based on number of expected results (without looking at the database!)\nso lowering your limits on connections will also lower the costs."),(0,a.kt)("li",{parentName:"ul"},"Connections multiply the cost of their children by the number of results\nthey're expected to return, so lower the limits on parent connections."),(0,a.kt)("li",{parentName:"ul"},"Nested fields multiply costs; so pulling a connection inside a connection\ninside a connection is going to be expensive - to address this, try placing\nlower ",(0,a.kt)("inlineCode",{parentName:"li"},"first"),"/",(0,a.kt)("inlineCode",{parentName:"li"},"last")," values on the connections or avoiding fetching nested\ndata until you need to display it (split into multiple requests / only request\nthe data you need for the current view)."),(0,a.kt)("li",{parentName:"ul"},"Subscriptions are automatically seen as 10x as expensive as queries - try and\nminimise the amount of data your subscription requests."),(0,a.kt)("li",{parentName:"ul"},"Procedure connections are treated as more expensive than table connections."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"totalCount")," on a table has a high cost"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"totalCount")," on a procedure has a higher cost"),(0,a.kt)("li",{parentName:"ul"},"Using ",(0,a.kt)("inlineCode",{parentName:"li"},"pageInfo")," adds significant cost to connections"),(0,a.kt)("li",{parentName:"ul"},"Computed columns are seen as fairly expensive - in future we may factor in\nPostgreSQL's ",(0,a.kt)("inlineCode",{parentName:"li"},"COST")," parameter when figuring this out.")),(0,a.kt)("p",null,"Keep in mind cost analysis is hard and the real cost of a query varies wildly\nbased on what your database has been dealing with recently, what indexes are\navailable, and many more factors. Our cost estimation is based on analysis of a\nlarge test suite, but feel free to reach out with any bad costs/queries so we\ncan improve this feature."))}m.isMDXComponent=!0},74224:(e,t,n)=>{n.d(t,{Z:()=>o});const o={contents:"contents_OrL_",content:"content_ilvp",row:"row_ARn8",header:"header_zTVt",footnote:"footnote_D0nB",footnoteText:"footnoteText_OEd0",note:"note_qBn0",small:"small_Gqq2",tagline:"tagline_Ld2x",tooltipped:"tooltipped_t_JO",tooltiptext:"tooltiptext_u7mD",proTag:"proTag_vRmB",sponTag:"sponTag_Nh0y",firstLetter:"firstLetter_NMLh"}}}]);