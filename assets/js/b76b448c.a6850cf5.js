"use strict";(self.webpackChunk_localrepo_grafast_website=self.webpackChunk_localrepo_grafast_website||[]).push([[3117],{30876:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var a=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=a.createContext({}),s=function(e){var t=a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(u.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,u=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=s(n),d=r,f=c["".concat(u,".").concat(d)]||c[d]||m[d]||i;return n?a.createElement(f,o(o({ref:t},p),{},{components:n})):a.createElement(f,o({ref:t},p))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l[c]="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},71043:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>u});var a=n(7896),r=(n(2784),n(30876));const i={},o="Execute and Stream V2 Migration",l={type:"mdx",permalink:"/errors/ev2",source:"@site/src/pages/errors/ev2.mdx",title:"Execute and Stream V2 Migration",description:'In March 2024, Grafast gained support for ["unary"',frontMatter:{}},u=[{value:"Quick fix",id:"quick-fix",level:2},{value:"Better fix",id:"better-fix",level:2},{value:"<code>stream</code>",id:"stream",level:2}],s={toc:u},p="wrapper";function c(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"execute-and-stream-v2-migration"},"Execute and Stream V2 Migration"),(0,r.kt)("p",null,"In March 2024, Gra",(0,r.kt)("em",{parentName:"p"},"fast")," gained support for ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/graphile/crystal/pull/1973"},'"unary"\nsteps'),". This was critical for\nmaking Gra",(0,r.kt)("em",{parentName:"p"},"fast")," easier to integrate with other data sources that aren't as\ncapable as Postgres (and let's be honest, what other data sources are as\ncapable as Postgres?) but unfortunately it meant that we had to account for\nsingular values coming into ",(0,r.kt)("inlineCode",{parentName:"p"},"execute")," methods. At first we added an ",(0,r.kt)("inlineCode",{parentName:"p"},"executeV2"),"\nbut this was really ugly and annoying to explain, so since we're still in beta\nwe made the hard decision to break this API, and replace ",(0,r.kt)("inlineCode",{parentName:"p"},"execute"),"."),(0,r.kt)("h2",{id:"quick-fix"},"Quick fix"),(0,r.kt)("p",null,"If you just want what you had before to start working again, you can change\neach of your ",(0,r.kt)("inlineCode",{parentName:"p"},"execute")," methods:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"execute")," now only accepts one argument; destructure ",(0,r.kt)("inlineCode",{parentName:"li"},"count"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"values"),"\n(as ",(0,r.kt)("inlineCode",{parentName:"li"},"newValues"),") and ",(0,r.kt)("inlineCode",{parentName:"li"},"extra")," from this argument."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"newValues")," is a tuple of objects rather than arrays; to convert it back to\nthe legacy form (a tuple of arrays): map over each entry, ",(0,r.kt)("inlineCode",{parentName:"li"},"dep"),", in\n",(0,r.kt)("inlineCode",{parentName:"li"},"newValues")," and:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"if it's a batch entry (",(0,r.kt)("inlineCode",{parentName:"li"},"dep.isBatch === true"),"):",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"use the ",(0,r.kt)("inlineCode",{parentName:"li"},"dep.entries")," property"))),(0,r.kt)("li",{parentName:"ul"},"otherwise:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"use an array of length ",(0,r.kt)("inlineCode",{parentName:"li"},"count"),", where each entry in the array is ",(0,r.kt)("inlineCode",{parentName:"li"},"dep.value"),".")))))),(0,r.kt)("p",null,"Here's an example diff of applying this change to your code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},"- async execute(count: number, values: any[][], extra: ExecutionExtra) {\n+ async execute({ count, values: newValues, extra }: ExecutionDetails) {\n+   const values = newValues.map((dep) =>\n+     dep.isBatch ? dep.entries : new Array(count).fill(dep.value)\n+   );\n")),(0,r.kt)("p",null,"Once done, your functions should work as they did before."),(0,r.kt)("h2",{id:"better-fix"},"Better fix"),(0,r.kt)("p",null,"The above is not the most efficient way of using the new system though (since\nit requires creating a new array for each unary dependency in each step);\ninstead you should map over each incoming index via ",(0,r.kt)("inlineCode",{parentName:"p"},"indexMap")," and use the\n",(0,r.kt)("inlineCode",{parentName:"p"},"dep.at(i)")," method rather than ",(0,r.kt)("inlineCode",{parentName:"p"},"dep[i]")," array syntax to access the value at\neach index."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Before"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"function execute(count: number, values: ReadonlyArray<[number, number]>) {\n  const [allA, allB] = values;\n  const results: number[] = [];\n  for (let i = 0; i < count; i++) {\n    const a = allA[i];\n    const b = allB[i];\n    results.push(a + b);\n  }\n  return results;\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"After"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"function execute({ indexMap, values }: ExecutionDetails<[number, number]>) {\n  const [allA, allB] = values;\n  return indexMap((i) => {\n    const a = allA.at(i);\n    const b = allB.at(i);\n    return a + b;\n  });\n}\n")),(0,r.kt)("h2",{id:"stream"},(0,r.kt)("inlineCode",{parentName:"h2"},"stream")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"stream")," goes through the same transition as ",(0,r.kt)("inlineCode",{parentName:"p"},"execute"),", except the type of the\n",(0,r.kt)("inlineCode",{parentName:"p"},"details")," variable is ",(0,r.kt)("inlineCode",{parentName:"p"},"StreamDetails")," rather than ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecutionDetails"),"."))}c.isMDXComponent=!0}}]);