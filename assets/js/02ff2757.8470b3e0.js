"use strict";(self.webpackChunk_localrepo_grafast_website=self.webpackChunk_localrepo_grafast_website||[]).push([[8],{30876:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(2784);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(n),m=i,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||r;return n?a.createElement(h,l(l({ref:t},p),{},{components:n})):a.createElement(h,l({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[d]="string"==typeof e?e:i,l[1]=o;for(var c=2;c<r;c++)l[c]=n[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},59945:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var a=n(7896),i=(n(2784),n(30876));const r={sidebar_position:1},l="Codecs",o={unversionedId:"step-library/dataplan-pg/registry/codecs",id:"step-library/dataplan-pg/registry/codecs",title:"Codecs",description:'A PgCodec ("codec") represents a type (data type) in the database. There are',source:"@site/grafast/step-library/dataplan-pg/registry/codecs.md",sourceDirName:"step-library/dataplan-pg/registry",slug:"/step-library/dataplan-pg/registry/codecs",permalink:"/grafast/step-library/dataplan-pg/registry/codecs",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/grafast/website/grafast/step-library/dataplan-pg/registry/codecs.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Registry",permalink:"/grafast/step-library/dataplan-pg/registry/"},next:{title:"Resources",permalink:"/grafast/step-library/dataplan-pg/registry/resources"}},s={},c=[{value:"<code>TYPES</code>",id:"types",level:2},{value:"recordCodec(config)",id:"recordcodecconfig",level:2},{value:"Example",id:"example",level:3},{value:"listOfCodec(innerCodec, config = {})",id:"listofcodecinnercodec-config--",level:2},{value:"rangeOfCodec(innerCodec, name, identifier)",id:"rangeofcodecinnercodec-name-identifier",level:2},{value:"Custom scalar codecs",id:"custom-scalar-codecs",level:2}],p={toc:c},d="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"codecs"},"Codecs"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"PgCodec"),' ("codec") represents a type (data type) in the database. There are\nloads of built in codecs for dealing with the builtin types in Postgres made\navailable via the ',(0,i.kt)("a",{parentName:"p",href:"#TYPES"},(0,i.kt)("inlineCode",{parentName:"a"},"TYPES")," export"),", but you can also create your own\ncodecs for other types using the various helpers."),(0,i.kt)("p",null,"Every codec has a ",(0,i.kt)("inlineCode",{parentName:"p"},"name"),", which is a handy identifier for you to use to\nreference it (you can reference codecs from the registry via\n",(0,i.kt)("inlineCode",{parentName:"p"},"registry.pgCodecs[name]"),"). A codec also has an ",(0,i.kt)("inlineCode",{parentName:"p"},"identifier")," which is the name\nof the type in the database."),(0,i.kt)("p",null,"Codecs are responsible for performing coercion and validation; they should\nthrow errors if the value supplied is invalid."),(0,i.kt)("h2",{id:"types"},(0,i.kt)("inlineCode",{parentName:"h2"},"TYPES")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'import { TYPES } from "@dataplan/pg";\n\nconst intCodec = TYPES.int;\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"TYPES")," object comprises a number of builtin codecs for common types in your\ndatabase; the following keys on ",(0,i.kt)("inlineCode",{parentName:"p"},"TYPES")," represent the similarly named database\ntypes (e.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"TYPES.boolean")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"bool")," type):"),(0,i.kt)("ul",{style:{columnWidth:"10em"}},(0,i.kt)("li",null,"boolean"),(0,i.kt)("li",null,"int2"),(0,i.kt)("li",null,"int"),(0,i.kt)("li",null,"bigint"),(0,i.kt)("li",null,"float4"),(0,i.kt)("li",null,"float"),(0,i.kt)("li",null,"money"),(0,i.kt)("li",null,"numeric"),(0,i.kt)("li",null,"char"),(0,i.kt)("li",null,"bpchar"),(0,i.kt)("li",null,"varchar"),(0,i.kt)("li",null,"text"),(0,i.kt)("li",null,"name"),(0,i.kt)("li",null,"json"),(0,i.kt)("li",null,"jsonb"),(0,i.kt)("li",null,"xml"),(0,i.kt)("li",null,"citext"),(0,i.kt)("li",null,"uuid"),(0,i.kt)("li",null,"timestamp"),(0,i.kt)("li",null,"timestamptz"),(0,i.kt)("li",null,"date"),(0,i.kt)("li",null,"time"),(0,i.kt)("li",null,"timetz"),(0,i.kt)("li",null,"inet"),(0,i.kt)("li",null,"regproc"),(0,i.kt)("li",null,"regprocedure"),(0,i.kt)("li",null,"regoper"),(0,i.kt)("li",null,"regoperator"),(0,i.kt)("li",null,"regclass"),(0,i.kt)("li",null,"regtype"),(0,i.kt)("li",null,"regrole"),(0,i.kt)("li",null,"regnamespace"),(0,i.kt)("li",null,"regconfig"),(0,i.kt)("li",null,"regdictionary"),(0,i.kt)("li",null,"cidr"),(0,i.kt)("li",null,"macaddr"),(0,i.kt)("li",null,"macaddr8"),(0,i.kt)("li",null,"interval"),(0,i.kt)("li",null,"bit"),(0,i.kt)("li",null,"varbit"),(0,i.kt)("li",null,"point"),(0,i.kt)("li",null,"line"),(0,i.kt)("li",null,"lseg"),(0,i.kt)("li",null,"box"),(0,i.kt)("li",null,"path"),(0,i.kt)("li",null,"polygon"),(0,i.kt)("li",null,"circle"),(0,i.kt)("li",null,"hstore"),(0,i.kt)("li",null,"void")),(0,i.kt)("h2",{id:"recordcodecconfig"},"recordCodec(config)"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"recordCodec"),' is a helper function that returns a PgCodec representing a\n"composite type" (or "record") - a structured type with attributes. This is\nmost commonly used when defining a table (the "attributes" in this case being\nwhich columns it has), but is also useful in other cases.'),(0,i.kt)("p",null,"The record codec config should contain:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"name: string")," - the name to use for this codec"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"identifier: SQL")," - the database name for this type"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"attributes: Record<string, PgCodecAttribute>")," - the attributes (columns) on this codec; the keys on this object are the attribute names, and the values are objects with the following options:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"codec: PgCodec")," - the PgCodec that details the type of this attribute"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"notNull: boolean")," (optional) - if true, indicates that the column cannot be null"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"hasDefault: boolean")," (optional) - if true, indicates that the column has a default (and\nthus may be omitted from ",(0,i.kt)("inlineCode",{parentName:"li"},"INSERT")," operations)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"expression(alias: SQL): SQL")," (optional) - indicates that this attribute is not a real\nattribute, but instead a computed value that can be computed using the given\nexpression"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"polymorphism")," (extremely optional) - see ",(0,i.kt)("a",{parentName:"li",href:"/grafast/step-library/dataplan-pg/polymorphism"},"polymorphism"))),(0,i.kt)("h3",{id:"example"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'const forumCodec = recordCodec({\n  name: "forums",\n  identifier: sql`app_public.forums`,\n  attributes: {\n    id: {\n      codec: TYPES.uuid,\n      notNull: true,\n      hasDefault: true,\n    },\n    name: {\n      codec: TYPES.citext,\n      notNull: true,\n    },\n    archived_at: {\n      codec: TYPES.timestamptz,\n    },\n    is_archived: {\n      codec: TYPES.boolean,\n      expression(alias) {\n        return sql`${alias}.archived_at is not null`;\n      },\n    },\n  },\n});\n')),(0,i.kt)("h2",{id:"listofcodecinnercodec-config--"},"listOfCodec(innerCodec, config = {})"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"listOfCodec")," returns a new codec that represents a list (array) of the given\n",(0,i.kt)("inlineCode",{parentName:"p"},"innerCodec"),". Optionally you may provide details about this codec:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"identifier")," - the database name for this type")),(0,i.kt)("h2",{id:"rangeofcodecinnercodec-name-identifier"},"rangeOfCodec(innerCodec, name, identifier)"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"rangeOfCodec")," returns a new codec that represents a range of the given\n",(0,i.kt)("inlineCode",{parentName:"p"},"innerCodec"),". You must specify the ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"identifier")," to use for this\ncodec."),(0,i.kt)("h2",{id:"custom-scalar-codecs"},"Custom scalar codecs"),(0,i.kt)("p",null,"Should you need to define more scalar codecs than those available via ",(0,i.kt)("inlineCode",{parentName:"p"},"TYPES"),", you may create a PgCodec object representing them. The object can have the following properties:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"name: string")," (required) - the name to use for this codec"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"sqlType: string")," (required) - the ",(0,i.kt)("inlineCode",{parentName:"li"},"identifier")," for this codec, the SQL fragment that represents the name of the type in the database"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fromPg")," - optional callback function that, given the textual representation from postgres, returns the internal representation for the value to use in JavaScript"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"toPg")," - optional callback function that, given the internal representation used in JavaScript, returns the value to insert into an SQL statement - this should be a simple scalar (text, etc) that can be cast by postgres"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"attributes")," - see ",(0,i.kt)("inlineCode",{parentName:"li"},"recordCodec")," instead"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"polymorphism")," - see ",(0,i.kt)("a",{parentName:"li",href:"/grafast/step-library/dataplan-pg/polymorphism"},"polymorphism"))))}u.isMDXComponent=!0}}]);