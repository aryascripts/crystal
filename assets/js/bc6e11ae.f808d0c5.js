"use strict";(self.webpackChunk_localrepo_postgraphile_website=self.webpackChunk_localrepo_postgraphile_website||[]).push([[9963],{30876:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var r=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=p(n),f=a,h=u["".concat(s,".").concat(f)]||u[f]||c[f]||i;return n?r.createElement(h,o(o({ref:t},m),{},{components:n})):r.createElement(h,o({ref:t},m))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=f;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:a,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},21468:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var r=n(7896),a=(n(2784),n(30876));const i={},o="Refs",l={unversionedId:"refs",id:"refs",title:"Refs",description:"When you have two database tables with a foreign key constraint between them,",source:"@site/postgraphile/refs.md",sourceDirName:".",slug:"/refs",permalink:"/postgraphile/next/refs",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/postgraphile/website/postgraphile/refs.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Polymorphism",permalink:"/postgraphile/next/polymorphism"},next:{title:"Aggregates",permalink:"/postgraphile/next/aggregates"}},s={},p=[{value:"@ref and @refVia",id:"ref-and-refvia",level:2},{value:"Route strings",id:"route-strings",level:2}],m={toc:p},u="wrapper";function c(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"refs"},"Refs"),(0,a.kt)("p",null,"When you have two database tables with a foreign key constraint between them,\nPostGraphile will automatically add that relation to your GraphQL schema in\nboth directions. Sometimes you want to add additional links between types,\nperhaps links that traverse multiple relationships (e.g.\n",(0,a.kt)("inlineCode",{parentName:"p"},"post -> topic -> forum"),"), or links that perform polymorphism over relations.\nFor this need, we have refs. Refs are uni-directional (they do not\nautomatically create a reverse field) and may be plural or singular. Plural\nrefs support both list and connection interfaces in GraphQL."),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Refs follow relations defined via foreign key constraints (or\n",(0,a.kt)("inlineCode",{parentName:"p"},"@foreignKey")," smart tags), attempts to build relations via a ",(0,a.kt)("inlineCode",{parentName:"p"},"@ref"),"\nwithout having an underlying foreign key relation will be ignored, though you\nmay see a warning in the console such as:"),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre"},"When processing ref for resource 'posts', could not find matching relation for\nvia:'(author_id)->users'\n"))),(0,a.kt)("h2",{id:"ref-and-refvia"},"@ref and @refVia"),(0,a.kt)("p",null,"The easiest way to define a ref is with a ",(0,a.kt)("inlineCode",{parentName:"p"},"@ref")," smart tag. The first argument to your ",(0,a.kt)("inlineCode",{parentName:"p"},"@ref")," smart tag\nis the name for your reference, and then it supports the following optional parameters:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"to:")," - the name of the GraphQL type we're referencing (required if ",(0,a.kt)("inlineCode",{parentName:"li"},"via:")," is not present)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"from:")," - the name of the GraphQL type we're applying the reference to when using polymorphism"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"via:"),"- the route string (see below) through which we can reach the target"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"singular")," - present if this is a singular relationship"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"plural")," - indicates that the ref is plural (default). Not allowed if\n",(0,a.kt)("inlineCode",{parentName:"li"},"singular")," is specified.")),(0,a.kt)("p",null,"For example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"comment on table posts is $$\n  @ref author via:(author_id)->people(id) singular\n  $$;`\n")),(0,a.kt)("p",null,"Sometimes we want a ref to use multiple routes; this might be because there's\nmultiple join tables we want to traverse to the same target table, or because\nwe want to target multiple tables. When we need this, instead of specifying a\n",(0,a.kt)("inlineCode",{parentName:"p"},"via:")," directly on the ",(0,a.kt)("inlineCode",{parentName:"p"},"@ref")," smart tag, we add multiple ",(0,a.kt)("inlineCode",{parentName:"p"},"@refVia")," smart tags,\neach with the ref name followed by a ",(0,a.kt)("inlineCode",{parentName:"p"},"via:"),' (see "Route strings" below):'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"comment on table books is $$\n  @ref relatedPeople to:Person\n  @refVia relatedPeople via:book_authors;people\n  @refVia relatedPeople via:book_editors;people\n  $$;\n")),(0,a.kt)("p",null,"We can also use multiple targets to indicate polymorphism (see ",(0,a.kt)("a",{parentName:"p",href:"./polymorphism"},"the polymorphism\ndocs")," for full details):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"comment on table log_entries is $$\n  @ref author to:PersonOrOrganization singular\n  @refVia author via:(person_id)->people(person_id)\n  @refVia author via:(organization_id)->organizations(organization_id)\n  $$;\n")),(0,a.kt)("h2",{id:"route-strings"},"Route strings"),(0,a.kt)("p",null,"The value for a ",(0,a.kt)("inlineCode",{parentName:"p"},"via:")," parameter takes the form of a chain of one or more\nrelationships separated by semicolons. Each relationship is either:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"<table_name>")," - a table name (in which case there must be exactly one\nforeign key referencing this table), or"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"(<column>,...)-><table_name>")," - a list of local columns referencing a\nremote table's primary key"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"(<column>,...)-><table_name>(<column>,...)")," - a list of local columns\nreferencing a remote table's list of columns")))}c.isMDXComponent=!0}}]);