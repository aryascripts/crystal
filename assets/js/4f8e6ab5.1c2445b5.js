"use strict";(self.webpackChunk_localrepo_grafast_website=self.webpackChunk_localrepo_grafast_website||[]).push([[3516],{30876:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var a=n(2784);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=u(n),h=i,d=c["".concat(l,".").concat(h)]||c[h]||m[h]||r;return n?a.createElement(d,o(o({ref:t},p),{},{components:n})):a.createElement(d,o({ref:t},p))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:i,o[1]=s;for(var u=2;u<r;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},20563:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var a=n(7896),i=(n(2784),n(30876));const r={},o="Production Considerations",s={unversionedId:"production-considerations",id:"production-considerations",title:"Production Considerations",description:"Overview",source:"@site/grafast/production-considerations.md",sourceDirName:".",slug:"/production-considerations",permalink:"/grafast/production-considerations",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/grafast/website/grafast/production-considerations.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Polymorphism",permalink:"/grafast/polymorphism"}},l={},u=[{value:"Overview",id:"overview",level:2},{value:"Static queries",id:"static-queries",level:2},{value:"Persisted operations",id:"persisted-operations",level:2},{value:"Denial of Service",id:"denial-of-service",level:2},{value:"Limits",id:"limits",level:2},{value:"Rate-limiting / blocking",id:"rate-limiting--blocking",level:3},{value:"Timeouts",id:"timeouts",level:3},{value:"Planning timeout",id:"planning-timeout",level:4},{value:"Execution timeout",id:"execution-timeout",level:4}],p={toc:u},c="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(c,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"production-considerations"},"Production Considerations"),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"Gra",(0,i.kt)("em",{parentName:"p"},"fast")," works best with ",(0,i.kt)("a",{parentName:"p",href:"#static-queries"},"static queries"),", which is most\nlikely what you will be using already (unless you're using string concatenation\nto build up your queries, in which case you should switch to using\n",(0,i.kt)("a",{parentName:"p",href:"https://graphql.org/learn/queries/#variables"},"variables"),")."),(0,i.kt)("p",null,"Assuming you're consuming your GraphQL schema via an HTTP API, we recommend\nthat you use ",(0,i.kt)("a",{parentName:"p",href:"#persisted-operations"},"persisted operations")," (e.g. via\n",(0,i.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@grafserv/persisted"},(0,i.kt)("inlineCode",{parentName:"a"},"@grafserv/persisted")),') to\nact as an operation "allow list." This helps to protect your server against bad\nactors sending malicious queries trying to instigate a ',(0,i.kt)("a",{parentName:"p",href:"#denial-of-service"},"Denial of\nService")," attack."),(0,i.kt)("p",null,"If you choose not to use persisted operations, or if you want to be extra safe\n(especially if your team are not extremely disciplined about adding pagination\nlimits or careful about placement of variables), then you should also consider\nsetting planning and execution timeouts:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const preset = {\n  grafast: {\n    timeouts: {\n      /** Planning timeout in ms */\n      planning: 500,\n\n      /** Execution timeout in ms */\n      execution: 30_000,\n    },\n  },\n};\n")),(0,i.kt)("p",null,"In either case, it may be wise to track bad actors and block/rate limit\nrequests from them. You can typically do this via a middleware in your\nwebserver."),(0,i.kt)("p",null,"Below, we'll go into a little more detail on each of these topics."),(0,i.kt)("h2",{id:"static-queries"},"Static queries"),(0,i.kt)("p",null,"Building a GraphQL query via string concatination is generally considered bad\npractice (both in Gra",(0,i.kt)("em",{parentName:"p"},"fast")," and in the wider GraphQL ecosystem):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"function getUserDetails(userId) {\n  // DON'T DO THIS\n  const source = `\n    query UserDetails {\n      userById(id: ${userId}) { # <<< STRING CONCATENATION IS BAD!\n        username\n        avatarUrl\n      }\n    }\n  `;\n  return runGraphQLQuery(source);\n}\n")),(0,i.kt)("p",null,'Instead, declare the query text once (a "static query"), and then use ',(0,i.kt)("a",{parentName:"p",href:"https://graphql.org/learn/queries/#variables"},"GraphQL\nvariables")," to pass parameters\nalongside the query text:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"// Declare the query once:\nconst UserDetailsQuery = /* GraphQL */ `\n  query UserDetails($userId: Int!) {\n    userById(id: $userId) {\n      username\n      avatarUrl\n    }\n  }\n`;\n\nfunction getUserDetails(userId) {\n  // Run the static query using the dynamic variable:\n  return runGraphQLQuery(UserDetailsQuery, { userId });\n}\n")),(0,i.kt)("p",null,"Over HTTP this might look like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-http"},'POST /graphql HTTP/1.1\nHost: example.com\nContent-Type: application/json\nAccept: application/json\n\n{\n  "query": "query UserDetails($userId: Int!) { userById(id: $userId) { username avatarUrl } }",\n  "variables": {\n    "userId": 7\n  }\n}\n')),(0,i.kt)("p",null,"In Gra",(0,i.kt)("em",{parentName:"p"},"fast")," this is especially important because each time we see a new\nGraphQL document we will need to plan it, so by reusing the same document over\nand over again we can reduce our planning costs many times over."),(0,i.kt)("h2",{id:"persisted-operations"},"Persisted operations"),(0,i.kt)("p",null,"If you do not intend to allow third parties to run arbitrary operations against\nyour API then using\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/graphile/persisted-operations"},"persisted operations")," as a\nquery allowlist is a highly recommended solution to protect any GraphQL\nendpoint (Gra",(0,i.kt)("em",{parentName:"p"},"fast")," or otherwise). This technique ensures that only the\noperations you use in your own applications (website, mobile apps, desktop app,\netc) can be executed on the server, preventing malicious (or merely curious)\nactors from executing operations which may be more expensive than those you\nhave written."),(0,i.kt)("p",null,"This technique is suitable for the vast majority of use cases and supports many\nGraphQL clients, but it does have a few caveats:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Your API will only accept operations that you've approved, so it is not\nsuitable if you want third parties to run arbitrary custom operations."),(0,i.kt)("li",{parentName:"ul"},"You must be able to generate a unique ID (e.g. a hash) from each operation at\nbuild time of your application/web page - you must use ",(0,i.kt)("a",{parentName:"li",href:"#static-queries"},"static\nqueries"),". It's important to note this only applies to the\noperation document itself, the variables can of course change at runtime."),(0,i.kt)("li",{parentName:"ul"},"You must have a way of sharing these static operations from the application\nbuild process to the server so that the server will know what operation the ID\nrepresents."),(0,i.kt)("li",{parentName:"ul"},"You should be careful not to use variables in dangerous places within your\noperation; for example if you were to use ",(0,i.kt)("inlineCode",{parentName:"li"},"allPosts(first: $myVar)")," a\nmalicious attacker could set ",(0,i.kt)("inlineCode",{parentName:"li"},"$myVar")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"2147483647")," to cause your server to\nprocess as much data as possible. Use fixed limits, conditions and orders\nwhere possible, even if it means having additional static operations\n(alternatively, have you schema enforce the presence and/or valid ranges for\nthese)."),(0,i.kt)("li",{parentName:"ul"},"Persisted operations do not protect you from writing expensive queries\nyourself; it may be wise to combine this technique with a cost estimation\ntechnique to help guide your developers and avoid accidentally writing\nexpensive queries.")),(0,i.kt)("p",null,"Grafserv has first-party support for persisted operations via the open\nsource\n",(0,i.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@grafserv/persisted"},(0,i.kt)("inlineCode",{parentName:"a"},"@grafserv/persisted")),"\nmodule; we recommend its use to the vast majority of our users. If you're using\nan Envelop-powered server, check out\n",(0,i.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@envelop/persisted-operations"},(0,i.kt)("inlineCode",{parentName:"a"},"@envelop/persisted-operations")),"."),(0,i.kt)("h2",{id:"denial-of-service"},"Denial of Service"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"TL;DR"),": Use ",(0,i.kt)("a",{parentName:"p",href:"#persisted-operations"},"persisted operations"),", or configure\n",(0,i.kt)("a",{parentName:"p",href:"#timeouts"},"timeouts"),"."),(0,i.kt)("p",null,"Gra",(0,i.kt)("em",{parentName:"p"},"fast"),", like all technologies, makes tradeoffs. Gra",(0,i.kt)("em",{parentName:"p"},"fast"),"'s main trade-off\nis that it does work the first time it sees a GraphQL operation (\"planning\") in\norder to significantly reduce the amount of work that operation will need each\ntime it runs (even with different variables/context/etc). Sometimes this\nplanning pays off on that same request, but often it might take another request\nor two to recoup the planning cost via the efficiency gains (after which it's\nall pure gains!)"),(0,i.kt)("p",null,"Since planning is synchronous JavaScript code, and Node.js is single-threaded,\nthis planning will hold up the event loop for a short period whilst it\ncompletes. For simple operations this might only be fractions of a millisecond,\nbut it can grow for larger and more complex requests, especially if you are\nutilising step classes that have complex ",(0,i.kt)("inlineCode",{parentName:"p"},"deduplicate"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"optimize")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"finalize"),"\nmethods. It's not uncommon for planning of larger queries, especially those\ninvolving polymorphism, to take 50+ms to plan."),(0,i.kt)("p",null,"An adversary might attempt to exploit this planning time to instigate a Denial\nof Service attack, so it's essential that we do not allow adversaries to have\nour servers plan excessively complex queries. There are two main approaches to\nthis:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},'Use an "allow list" of approved queries - see ',(0,i.kt)("a",{parentName:"li",href:"#persisted-operations"},"Persisted operations")),(0,i.kt)("li",{parentName:"ol"},"Place limits on requests - see ",(0,i.kt)("a",{parentName:"li",href:"#limits"},"Limits"))),(0,i.kt)("p",null,"You can use one or, preferably, both of these techniques to protect your server."),(0,i.kt)("h2",{id:"limits"},"Limits"),(0,i.kt)("p",null,"There are many ways of placing limits on the requests that your server accepts.\nGenerally you want to catch bad actors without interfering with legitimate\nusers, so you're looking for anomalies - usage outside the norms - and you want\nto rate-limit or block these."),(0,i.kt)("p",null,"On top of this, you want to ensure that any one request cannot take more than a\ncertain threshold of time/resources, and this is where timeouts come in."),(0,i.kt)("h3",{id:"rate-limiting--blocking"},"Rate-limiting / blocking"),(0,i.kt)("p",null,"Your webserver is generally best placed to decide whether or not to execute a\nrequest."),(0,i.kt)("p",null,"A simple protection is to require authentication to use your API. This is not\nsuitable for all APIs, but if it works for you it could significantly decrease\nyour attack surface - particularly protecting you from untargeted automated\nattacks. Another approach to protect against untargeted attacks is to check\nthe origin of requests, or to require the inclusion of a randomly generated\nvalue such as a CSRF token."),(0,i.kt)("p",null,"Each version of an application (website, mobile app, etc) is likely to have a\nsmall-ish number of static queries (a few hundred, perhaps). Users of GraphiQL\nor similar IDEs are unlikely to send your server more than, say, 50 new unique\nqueries in any five minute period. One option is to configure your server to\ncount the unique queries coming from a particular source over a particular\nperiod, and block future queries from that source once the limit has been met."),(0,i.kt)("p",null,"Similarly you might track how long each request is taking to execute, and give\neach client a maximum execution time per time window - once this time has been\nexceeded you could block future requests from this client until their window\nrefreshes."),(0,i.kt)("p",null,"Most of this is standard fare for web servers, and you should be able to find\nmodules in your server ecosystem to help you address them."),(0,i.kt)("h3",{id:"timeouts"},"Timeouts"),(0,i.kt)("p",null,"Once you've started executing a GraphQL operation, you probably shouldn't let\nit run forever. Gra",(0,i.kt)("em",{parentName:"p"},"fast")," gives you two options for configuring timeouts: a\n",(0,i.kt)("inlineCode",{parentName:"p"},"planning")," timeout that applies when an operation is being planned, and an\n",(0,i.kt)("inlineCode",{parentName:"p"},"execution")," timeout that applies each time a plan is executed. Timeouts are\nconfigured in the ",(0,i.kt)("inlineCode",{parentName:"p"},"preset"),", which is the second (and optional) argument that\nyou pass to ",(0,i.kt)("inlineCode",{parentName:"p"},"grafast()")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"execute()")," (or is the configuration file you use\nfor ",(0,i.kt)("inlineCode",{parentName:"p"},"grafserv"),")."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const preset = {\n  grafast: {\n    timeouts: {\n      /** Planning timeout in ms */\n      planning: 500,\n\n      /** Execution timeout in ms */\n      execution: 30_000,\n    },\n  },\n};\n")),(0,i.kt)("h4",{id:"planning-timeout"},"Planning timeout"),(0,i.kt)("p",null,"The planning timeout applies each time an operation is planned."),(0,i.kt)("p",null,"Planning can be time consuming, and especially so when the server has just\nstarted and V8 hasn't had a chance to warm up the JIT caches yet. Therefore, we\nincrease the allowed timeout for the first few operations planned."),(0,i.kt)("p",null,"The planning timeout is only checked at certain stages whilst planning the\nquery, so it can be exceeded (generally only by a few tens of\nmilliseconds). Should you find this problematic, please get in touch and we can\ndiscuss adding timeout checks in more locations."),(0,i.kt)("p",null,"Most importantly, note that the planning time required for an operation will\nvary depending on the load on your machine, how powerful it is, and what has\nbeen planned previously. We recommend setting a high limit such as 500ms and\ncombining this with the rate limiting described in the section above."),(0,i.kt)("h4",{id:"execution-timeout"},"Execution timeout"),(0,i.kt)("p",null,"The execution timeout applies each time an operation plan is executed."),(0,i.kt)("p",null,"When an operation is first seen, it will undergo planning (adhering to the\nplanning timeout) and then execution (adhering to the execution timeout) - the\nexecution timeout ",(0,i.kt)("em",{parentName:"p"},"does not")," include the planning."),(0,i.kt)("p",null,"The execution timeout is only checked just before an asynchronous step (a\nnormal step - one that doesn't have ",(0,i.kt)("inlineCode",{parentName:"p"},"step.isSyncAndSafe === true"),") is about to\nbe executed - it is assumed that synchronous steps are fast enough that a\ntimeout need not be applied to them. Note that this means that steps themselves\nare responsible for adhering to the timeout - they will be passed a ",(0,i.kt)("inlineCode",{parentName:"p"},"stopTime"),'\nproperty on the "extra" argument to ',(0,i.kt)("inlineCode",{parentName:"p"},"execute()"),", and when the value of\n",(0,i.kt)("inlineCode",{parentName:"p"},"performance.now()")," is greater than or equal to ",(0,i.kt)("inlineCode",{parentName:"p"},"stopTime")," they should abort\ntheir active operation."))}m.isMDXComponent=!0}}]);