"use strict";(self.webpackChunk_localrepo_grafast_website=self.webpackChunk_localrepo_grafast_website||[]).push([[8469],{30876:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),c=u(n),m=r,h=c["".concat(l,".").concat(m)]||c[m]||d[m]||s;return n?a.createElement(h,o(o({ref:t},p),{},{components:n})):a.createElement(h,o({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[c]="string"==typeof e?e:r,o[1]=i;for(var u=2;u<s;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},82009:(e,t,n)=>{n.d(t,{Z:()=>o});var a=n(2784),r=n(524);const s={tabItem:"tabItem_OMyP"};function o(e){let{children:t,hidden:n,className:o}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(s.tabItem,o),hidden:n},t)}},77336:(e,t,n)=>{n.d(t,{Z:()=>w});var a=n(7896),r=n(2784),s=n(524),o=n(24126),i=n(7267),l=n(32424),u=n(42244),p=n(24155);function c(e){return function(e){return r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}function d(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??c(n);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function m(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function h(e){let{queryString:t=!1,groupId:n}=e;const a=(0,i.k6)(),s=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l._X)(s),(0,r.useCallback)((e=>{if(!s)return;const t=new URLSearchParams(a.location.search);t.set(s,e),a.replace({...a.location,search:t.toString()})}),[s,a])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,s=d(e),[o,i]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:s}))),[l,u]=h({queryString:n,groupId:a}),[c,f]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,s]=(0,p.Nk)(n);return[a,(0,r.useCallback)((e=>{n&&s.set(e)}),[n,s])]}({groupId:a}),g=(()=>{const e=l??c;return m({value:e,tabValues:s})?e:null})();(0,r.useLayoutEffect)((()=>{g&&i(g)}),[g]);return{selectedValue:o,selectValue:(0,r.useCallback)((e=>{if(!m({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);i(e),u(e),f(e)}),[u,f,s]),tabValues:s}}var g=n(89741);const b={tabList:"tabList_M0Dn",tabItem:"tabItem_ysIP"};function y(e){let{className:t,block:n,selectedValue:i,selectValue:l,tabValues:u}=e;const p=[],{blockElementScrollPositionUntilNextRender:c}=(0,o.o5)(),d=e=>{const t=e.currentTarget,n=p.indexOf(t),a=u[n].value;a!==i&&(c(t),l(a))},m=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const n=p.indexOf(e.currentTarget)+1;t=p[n]??p[0];break}case"ArrowLeft":{const n=p.indexOf(e.currentTarget)-1;t=p[n]??p[p.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":n},t)},u.map((e=>{let{value:t,label:n,attributes:o}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:i===t?0:-1,"aria-selected":i===t,key:t,ref:e=>p.push(e),onKeyDown:m,onClick:d},o,{className:(0,s.Z)("tabs__item",b.tabItem,o?.className,{"tabs__item--active":i===t})}),n??t)})))}function k(e){let{lazy:t,children:n,selectedValue:a}=e;const s=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=s.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},s.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function v(e){const t=f(e);return r.createElement("div",{className:(0,s.Z)("tabs-container",b.tabList)},r.createElement(y,(0,a.Z)({},e,t)),r.createElement(k,(0,a.Z)({},e,t)))}function w(e){const t=(0,g.Z)();return r.createElement(v,(0,a.Z)({key:String(t)},e))}},63955:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>u,toc:()=>c});var a=n(7896),r=(n(2784),n(30876)),s=n(77336),o=n(82009);const i={sidebar_position:2},l="Getting started",u={unversionedId:"getting-started/index",id:"getting-started/index",title:"Getting started",description:"Installation",source:"@site/grafast/getting-started/index.mdx",sourceDirName:"getting-started",slug:"/getting-started/",permalink:"/grafast/getting-started/",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/grafast/website/grafast/getting-started/index.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Grafast Introduction",permalink:"/grafast/"},next:{title:"Using with existing schema",permalink:"/grafast/getting-started/existing-schema"}},p={},c=[{value:"Installation",id:"installation",level:2},{value:"TypeScript v5.0.0+ (optional)",id:"typescript-v500-optional",level:2},{value:"My first plan",id:"my-first-plan",level:2},{value:"My first step class",id:"my-first-step-class",level:2}],d={toc:c},m="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"getting-started"},"Getting started"),(0,r.kt)("h2",{id:"installation"},"Installation"),(0,r.kt)("p",null,"​",(0,r.kt)("grafast",null)," is an alternative ",(0,r.kt)("em",{parentName:"p"},"execution")," layer for GraphQL; we still need GraphQL.js\nfor building the schema, and parsing and validating requests. So the first thing\nyou need to do to get started is to install ",(0,r.kt)("inlineCode",{parentName:"p"},"grafast")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"graphql"),":"),(0,r.kt)(s.Z,{groupId:"npm2yarn",mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"npm",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm install --save grafast@beta graphql\n"))),(0,r.kt)(o.Z,{value:"yarn",label:"Yarn",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"yarn add grafast@beta graphql\n"))),(0,r.kt)(o.Z,{value:"pnpm",label:"pnpm",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"pnpm add grafast@beta graphql\n")))),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"We intend to write up a specification so that other languages may implement\nthe ",(0,r.kt)("grafast",null)," execution strategy, but for now ",(0,r.kt)("grafast",null)," is JavaScript/TypeScript only.")),(0,r.kt)("p",null,"If you have an existing GraphQL.js schema, you can run it through ",(0,r.kt)("grafast",null)," ─ see\n",(0,r.kt)("a",{parentName:"p",href:"./existing-schema"},"using with an existing schema"),"."),(0,r.kt)("h2",{id:"typescript-v500-optional"},"TypeScript v5.0.0+ (optional)"),(0,r.kt)("p",null,"We recommend that you use TypeScript for the best experience - auto-completion,\ninline documentation, etc."),(0,r.kt)("p",null,"You do not need to use TypeScript to use ",(0,r.kt)("grafast",null),", but if you do then you\nmust use a version from TypeScript v5.0.0 upward and configure it to support\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"exports")," property in ",(0,r.kt)("inlineCode",{parentName:"p"},"package.json"),", you can do so by adding this to your\nTypeScript configuration:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'    "moduleResolution": "node16", // Or "nodenext"\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"Our adherence to semver ",(0,r.kt)("strong",{parentName:"p"},"does not cover types")," - we ",(0,r.kt)("em",{parentName:"p"},"may")," make breaking\nchanges to TypeScript types in patch-level updates. The reason for this is that\nTypeScript itself is ever-changing, and the libraries we depend on often make\nbreaking type changes, forcing us to do so too. Further, improvements to types\nare generally a good thing for developer experience, even if it might mean you\nhave to spend a couple minutes after updating to address any issues."),(0,r.kt)("p",{parentName:"admonition"},"However, we try and keep the TypeScript types as stable as possible, only\nmaking breaking changes when their benefits outweigh the costs (as determined\nby our maintainer), and we do our best to detail in the release notes how to\ndeal with these changes (if any action is necessary).")),(0,r.kt)("h2",{id:"my-first-plan"},"My first plan"),(0,r.kt)("p",null,"Let's build a simple GraphQL schema powered by ",(0,r.kt)("grafast",null)," plans and query it."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"There are many ways to build a GraphQL schema, we're going to use the \"schema\nfirst\" approach in this example, but there's no reason that a ",(0,r.kt)("grafast",null),' schema\ncouldn\'t be produced "code first" or "database first" or any other approach.')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"We have a ",(0,r.kt)("a",{parentName:"p",href:"/playground/"},"playground")," you can use for experimenting with ",(0,r.kt)("grafast",null),"\nwithout having to install any software.")),(0,r.kt)("p",null,"First, lets define our GraphQL schema. We're going to go with an incredibly\nsimple schema with a single field that adds together its two arguments:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const typeDefs = /* GraphQL */ `\n  type Query {\n    addTwoNumbers(a: Int!, b: Int!): Int\n  }\n`;\n")),(0,r.kt)("p",null,"Now we need to define the ",(0,r.kt)("inlineCode",{parentName:"p"},"plans")," for the schema. The plan for our\n",(0,r.kt)("inlineCode",{parentName:"p"},"Query.addTwoNumbers")," field is to ",(0,r.kt)("a",{parentName:"p",href:"../plan-resolvers#field-arguments-fieldargs"},"read the arguments"),", then use the\n",(0,r.kt)("a",{parentName:"p",href:"../step-library/standard-steps/lambda"},"lambda")," step to add them together. The lambda step takes a list of other\nsteps, and then determines the result by calling the given callback for each set\nof resulting values."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const { lambda } = require("grafast");\n\nconst plans = {\n  Query: {\n    addTwoNumbers(_, fieldArgs) {\n      const $a = fieldArgs.get("a");\n      const $b = fieldArgs.get("b");\n      return lambda([$a, $b], ([a, b]) => a + b);\n    },\n  },\n};\n')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("inlineCode",{parentName:"p"},"lambda")," is a bit of an escape hatch ─ it enables one-by-one processing of\nvalues rather than the batched processing that ",(0,r.kt)("grafast",null)," prefers for efficiency.\nIt can be handy as a utility function when batching would confer no benefit,\nbut in general you should pick a ",(0,r.kt)("a",{parentName:"p",href:"../step-library"},"more suitable step"),".")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Making the callback function to ",(0,r.kt)("inlineCode",{parentName:"p"},"lambda")," a global (defined once) function\nwould enable ",(0,r.kt)("grafast",null)," to potentially detect multiple uses of it and\ndeduplicate them. This is important for performance if a similar lambda\ncallback is used in lots of places in a query.")),(0,r.kt)("p",null,"To turn this into a schema, we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"makeGrafastSchema")," helper which will\nstitch the ",(0,r.kt)("inlineCode",{parentName:"p"},"typeDefs")," and the ",(0,r.kt)("inlineCode",{parentName:"p"},"plans")," together:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const { makeGrafastSchema } = require("grafast");\n\nconst schema = makeGrafastSchema({\n  typeDefs,\n  plans,\n});\n')),(0,r.kt)("p",null,"Finally, we can run our query:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const { grafastSync } = require("grafast");\n\nconst result = grafastSync({\n  schema,\n  source: /* GraphQL */ `\n    {\n      addTwoNumbers(a: 40, b: 2)\n    }\n  `,\n});\n')),(0,r.kt)("p",null,"The result is what we'd expect:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "data": {\n    "addTwoNumbers": 42\n  }\n}\n')),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Our schema is so simple the query could be ran synchronously with\n",(0,r.kt)("inlineCode",{parentName:"p"},"grafastSync(...)"),", but most queries in the real world should be executed\nthrough ",(0,r.kt)("inlineCode",{parentName:"p"},"grafast(...)")," and will return either the result, a promise to the\nresult, or even an async iterable for ",(0,r.kt)("inlineCode",{parentName:"p"},"@stream"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"@defer"),", subscriptions and\nsimilar!")),(0,r.kt)("p",null,"We could then ",(0,r.kt)("a",{parentName:"p",href:"../servers"},"serve this schema over HTTP")," using a server such as\n",(0,r.kt)("a",{parentName:"p",href:"/grafserv"},"grafserv")," or any ",(0,r.kt)("a",{parentName:"p",href:"../servers#envelop"},"envelop-capable server"),"."),(0,r.kt)("h2",{id:"my-first-step-class"},"My first step class"),(0,r.kt)("p",null,'The building blocks of an operation plan are "steps." Steps are instances of\n"step classes," and ',(0,r.kt)("grafast",null)," makes available a modest range of ",(0,r.kt)("a",{parentName:"p",href:"../step-library/standard-steps"},"standard steps"),"\nthat you can use; but when these aren't enough you can write your own.\nStep classes extend the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExecutableStep")," class. The only required method to\ndefine is ",(0,r.kt)("inlineCode",{parentName:"p"},"execute"),", however most steps will also have a ",(0,r.kt)("inlineCode",{parentName:"p"},"constructor")," in which\nthey accept their arguments (some of which may be dependencies) and may also\nhave the various lifecycle methods."),(0,r.kt)("p",null,"Full details for doing so can be found in ",(0,r.kt)("a",{parentName:"p",href:"../step-classes"},"Step classes"),", but let's build\nourselves a simple one now to replace the ",(0,r.kt)("inlineCode",{parentName:"p"},"lambda")," usage above:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const { ExecutableStep } = require("grafast");\n\nclass AddStep extends ExecutableStep {\n  constructor($a, $b) {\n    super();\n    this.addDependency($a);\n    this.addDependency($b);\n  }\n\n  execute({ indexMap, values: [aDep, bDep] }) {\n    return indexMap((i) => {\n      const a = aDep.at(i);\n      const b = bDep.at(i);\n      return a + b;\n    });\n  }\n}\n')),(0,r.kt)("p",null,"By convention, we always define a function that constructs an instance of our\nclass:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"function add($a, $b) {\n  return new AddStep($a, $b);\n}\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"There's multiple reasons for this, a simple one is to make the plan code\neasier to read: we won't see the ",(0,r.kt)("inlineCode",{parentName:"p"},"new")," calls in our plan resolver functions,\nnor the redundant ",(0,r.kt)("inlineCode",{parentName:"p"},"Step")," wording, resulting in a higher signal-to-noise ratio.\nMore importantly, though, is that the small layer of indirection allows us to\ndo some minor manipulations before handing off to the class constructor, and\nmakes the APIs more future-proof since we can have the function return\nsomething different in future without having to refactor our plans in the\nschema. And remember that this cost is only incurred at planning time (which is\ngenerally cached and can be re-used for similar future requests), and each\nfield is only planned once, so the overhead of an additional function call is\nnegligible.")),(0,r.kt)("p",null,"Now we can use this function to add our numbers, rather than the lambda plan:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},' const plans = {\n   Query: {\n     addTwoNumbers(_, args) {\n       const $a = args.get("a");\n       const $b = args.get("b");\n-      return lambda([$a, $b], ([a, b]) => a + b);\n+      return add($a, $b);\n     },\n   },\n };\n')),(0,r.kt)("p",null,"You may well be able to write an entire ",(0,r.kt)("grafast",null)," schema using off-the-shelf step\nclasses, but it's worth being aware of how step classes work in case you want to\npush your optimizations further. ",(0,r.kt)("a",{parentName:"p",href:"../step-classes"},"Read more about step classes"),",\nor continue through the documentation."))}h.isMDXComponent=!0}}]);