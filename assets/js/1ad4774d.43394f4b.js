"use strict";(self.webpackChunk_localrepo_postgraphile_website=self.webpackChunk_localrepo_postgraphile_website||[]).push([[8549],{30876:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var a=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=p(n),c=r,h=u["".concat(s,".").concat(c)]||u[c]||d[c]||o;return n?a.createElement(h,i(i({ref:t},m),{},{components:n})):a.createElement(h,i({ref:t},m))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},80265:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7896),r=(n(2784),n(30876));const o={title:"makeWrapResolversPlugin"},i="No makeWrapResolversPlugin",l={unversionedId:"migrating-from-v4/make-wrap-resolvers-plugin",id:"migrating-from-v4/make-wrap-resolvers-plugin",title:"makeWrapResolversPlugin",description:"Since PostGraphile V5 no longer uses resolvers, wrapping resolvers is",source:"@site/postgraphile/migrating-from-v4/make-wrap-resolvers-plugin.md",sourceDirName:"migrating-from-v4",slug:"/migrating-from-v4/make-wrap-resolvers-plugin",permalink:"/postgraphile/next/migrating-from-v4/make-wrap-resolvers-plugin",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/postgraphile/website/postgraphile/migrating-from-v4/make-wrap-resolvers-plugin.md",tags:[],version:"current",frontMatter:{title:"makeWrapResolversPlugin"},sidebar:"docs",previous:{title:"makePluginByCombiningPlugins",permalink:"/postgraphile/next/migrating-from-v4/make-plugin-by-combining-plugins"},next:{title:"makeAddInflectorsPlugin",permalink:"/postgraphile/next/migrating-from-v4/make-add-inflectors-plugin"}},s={},p=[{value:"Setting a create/update mutation column value",id:"setting-a-createupdate-mutation-column-value",level:2},{value:"Performing an access check before a field plan",id:"performing-an-access-check-before-a-field-plan",level:2},{value:"Manipulating the data a field will return",id:"manipulating-the-data-a-field-will-return",level:2}],m={toc:p},u="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"no-makewrapresolversplugin"},"No makeWrapResolversPlugin"),(0,r.kt)("p",null,"Since PostGraphile V5 no longer uses resolvers, wrapping resolvers is\nmeaningless. And yet! Since we now use ",(0,r.kt)("inlineCode",{parentName:"p"},"plans"),", you can suddenly do a lot more\nby wrapping the plans than you ever could by wrapping resolvers - not only does\nit allow you to affect the data that's returned, it also allows you to change\nthe very plan of what will be done!"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"makeWrapPlansPlugin")," is the new plugin generator that replaces\n",(0,r.kt)("inlineCode",{parentName:"p"},"makeWrapResolversPlugin"),". It has a similar API, but it's somewhat simplified:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"No need for ",(0,r.kt)("inlineCode",{parentName:"li"},"requires")," any more, since you can use the methods on steps to get\nwhat you need"),(0,r.kt)("li",{parentName:"ul"},"No ",(0,r.kt)("inlineCode",{parentName:"li"},"resolveInfo")," since it's not needed in Gra",(0,r.kt)("em",{parentName:"li"},"fast")),(0,r.kt)("li",{parentName:"ul"},"No ",(0,r.kt)("inlineCode",{parentName:"li"},"context")," (but you can retrieve it via the ",(0,r.kt)("a",{parentName:"li",href:"https://grafast.org/grafast/step-library/standard-steps/context"},(0,r.kt)("inlineCode",{parentName:"a"},"context()")," step")," if you\nneed it)")),(0,r.kt)("p",null,"Now let's look at some of the things you might have used\n",(0,r.kt)("inlineCode",{parentName:"p"},"makeWrapResolversPlugin")," for in the past, and see how to map them into V5."),(0,r.kt)("h2",{id:"setting-a-createupdate-mutation-column-value"},"Setting a create/update mutation column value"),(0,r.kt)("p",null,"You could use ",(0,r.kt)("inlineCode",{parentName:"p"},"makeWrapResolversPlugin")," in V4 as a clumsy workaround to set\nspecific column values in a built-in CRUD mutation by overriding what the system\nthought the arguments were. Fortunately, V5's plan system means that you no\nlonger need to do this and you can address the problem more directly - you don't\neven have to have the column in your GraphQL schema in order to set it any more!\n\ud83d\ude05"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"makeWrapPlansPlugin({\n  Mutation: {\n    // This same pattern works for 'update' mutations too\n    createPost(plan, $source, { $firstName, $lastName }) {\n      // Call the original plan\n      const $planResult = plan();\n\n      // Get a reference to the `PgInsertSingleStep`.\n      // Remember: it's a step, it has not executed yet, so we can still\n      // augment what it will do.\n      const $insert = $planResult.get(\"result\");\n\n      // We have a legacy 'name' field that needs populating; build it from\n      // each tuple of firstName/lastName fields:\n      const $name = lambda(\n        [$firstName, $lastName],\n        ([firstName, lastName]) => `${firstName} ${lastName}`,\n        // Our callback is synchronous and won't throw\n        true,\n      );\n\n      // Now set this as the value of 'name' in the PgInsertSingleStep:\n      $insert.set(\"name\", $name);\n\n      // Our result is the same as before (otherwise dependent plans may fail)\n      return $planResult;\n    },\n  },\n});\n")),(0,r.kt)("h2",{id:"performing-an-access-check-before-a-field-plan"},"Performing an access check before a field plan"),(0,r.kt)("p",null,"Steps that have side effects never get tree shaken or de-duplicated, so if we\nwant to throw an error before the mutation takes place we can do so like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { sideEffect, context } from "postgraphile/grafast";\nimport { makeWrapPlansPlugin } from "postgraphile/utils";\n\nconst plugin = makeWrapPlansPlugin({\n  Mutation: {\n    createUser(plan) {\n      // Extract the \'isAdmin\' property from the GraphQL context\n      const $isAdmin = context().get("isAdmin");\n\n      // If the user isn\'t an admin, throw an error\n      const $preCheck = sideEffect($isAdmin, (isAdmin) => {\n        if (!isAdmin) {\n          throw new Error("Abort");\n        }\n      });\n\n      // Now call the underlying plans; these will never execute if the above throws\n      return plan();\n    },\n  },\n});\n')),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Plans with side effects are only expected/supported in field plans on the\n",(0,r.kt)("inlineCode",{parentName:"p"},"Mutation")," type. Side effect plans elsewhere may lead to unexpected results.")),(0,r.kt)("h2",{id:"manipulating-the-data-a-field-will-return"},"Manipulating the data a field will return"),(0,r.kt)("p",null,"It's quite common for developers to store a users ",(0,r.kt)("inlineCode",{parentName:"p"},"email")," into the ",(0,r.kt)("inlineCode",{parentName:"p"},"users")," table\n(see tip below on why you ",(0,r.kt)("em",{parentName:"p"},"shouldn't")," do this). You typically wouldn't want\nother users to be able to see someone's email address; so you could mask it out\nwith a field plan wrapper:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const plugin = makeWrapPlansPlugin({\n  User: {\n    email(plan, $user, args, info) {\n      // Get 'userId' from the GraphQL context\n      const $myUserId = context().get(\"userId\");\n\n      // Get the user's ID\n      const $theirUserId = $user.get(\"id\");\n\n      // Get the email via the original plan\n      const $email = plan();\n\n      // Now return a new plan that only returns the email if the IDs match\n      return lambda(\n        [$myUserId, $theirUserId, $email],\n        ([myUserId, theirUserId, email]) => {\n          if (myUserId === theirUserId) {\n            return email;\n          } else {\n            return null; // TODO: ensure the 'email' field is nullable!\n          }\n        },\n      );\n    },\n  },\n});\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"In my opinion, storing the ",(0,r.kt)("inlineCode",{parentName:"p"},"email")," onto the ",(0,r.kt)("inlineCode",{parentName:"p"},"users")," table is generally a bad\ndesign pattern. One reason is that it complicates security (see warning below),\nanother reason is ",(0,r.kt)("em",{parentName:"p"},"plurality"),": it's a lot harder to go from 1 to 2 of something\nthan it is to go from 2 to 3. You should design your system to allow users to\nhave more than one email address even if you don't allow it to start with, for\nexample by storing emails into a ",(0,r.kt)("inlineCode",{parentName:"p"},"user_emails")," table.")),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},"Though the above example may mask the ",(0,r.kt)("inlineCode",{parentName:"p"},"email")," field when fetched directly, there\nare side channel attacks that someone could use to determine someones email -\nfor example they could order by the email address and extract it from the\n",(0,r.kt)("inlineCode",{parentName:"p"},"cursor"),", or they could use advanced filtering to perform a dictionary search\nfor the users email address. We strongly advise that you store email addresses\nand other private information into a separate table for the best security.")))}d.isMDXComponent=!0}}]);