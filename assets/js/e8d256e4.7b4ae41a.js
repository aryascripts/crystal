"use strict";(self.webpackChunk_localrepo_postgraphile_website=self.webpackChunk_localrepo_postgraphile_website||[]).push([[7709],{30876:(e,n,a)=>{a.d(n,{Zo:()=>u,kt:()=>h});var t=a(2784);function r(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function l(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function i(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?l(Object(a),!0).forEach((function(n){r(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function o(e,n){if(null==e)return{};var a,t,r=function(e,n){if(null==e)return{};var a,t,r={},l=Object.keys(e);for(t=0;t<l.length;t++)a=l[t],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)a=l[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=t.createContext({}),p=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):i(i({},n),e)),a},u=function(e){var n=p(e.components);return t.createElement(s.Provider,{value:n},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},c=t.forwardRef((function(e,n){var a=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=p(a),c=r,h=m["".concat(s,".").concat(c)]||m[c]||d[c]||l;return a?t.createElement(h,i(i({ref:n},u),{},{components:a})):t.createElement(h,i({ref:n},u))}));function h(e,n){var a=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=c;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[m]="string"==typeof e?e:r,i[1]=o;for(var p=2;p<l;p++)i[p]=a[p];return t.createElement.apply(null,i)}return t.createElement.apply(null,a)}c.displayName="MDXCreateElement"},31851:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var t=a(7896),r=(a(2784),a(30876));const l={layout:"page",path:"/postgraphile/make-wrap-plans-plugin/",title:"makeWrapPlansPlugin"},i=void 0,o={unversionedId:"make-wrap-plans-plugin",id:"make-wrap-plans-plugin",title:"makeWrapPlansPlugin",description:"PostGraphile generates plan resolvers automatically for the fields that it",source:"@site/postgraphile/make-wrap-plans-plugin.md",sourceDirName:".",slug:"/make-wrap-plans-plugin",permalink:"/postgraphile/next/make-wrap-plans-plugin",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/postgraphile/website/postgraphile/make-wrap-plans-plugin.md",tags:[],version:"current",frontMatter:{layout:"page",path:"/postgraphile/make-wrap-plans-plugin/",title:"makeWrapPlansPlugin"},sidebar:"docs",previous:{title:"makeProcessSchemaPlugin",permalink:"/postgraphile/next/make-process-schema-plugin"},next:{title:"makeAddPgTableConditionPlugin",permalink:"/postgraphile/next/make-add-pg-table-condition-plugin"}},s={},p=[{value:"Signatures",id:"signatures",level:2},{value:"Method 1: wrapping individual resolvers of known fields",id:"method-1-wrapping-individual-resolvers-of-known-fields",level:2},{value:"Example: convert to lower case",id:"example-convert-to-lower-case",level:3},{value:"Example: multiple fields",id:"example-multiple-fields",level:3},{value:"Rules object",id:"rules-object",level:3},{value:"Example: null email unless own",id:"example-null-email-unless-own",level:3},{value:"Example: mask email",id:"example-mask-email",level:3},{value:"Method 2: wrap all resolvers matching a filter",id:"method-2-wrap-all-resolvers-matching-a-filter",level:2},{value:"Plan resolver wrapper functions",id:"plan-resolver-wrapper-functions",level:2}],u={toc:p},m="wrapper";function d(e){let{components:n,...a}=e;return(0,r.kt)(m,(0,t.Z)({},u,a,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,'PostGraphile generates plan resolvers automatically for the fields that it\ngenerates across your GraphQL API. But sometimes, you want to change what these\nplans do. Commonly you might want to apply additional filters to a collection,\nor perform additional actions (or validations) before performing a mutation.\nRather than rewriting the field and it\'s plans from scratch, you can "wrap" the\nplan that PostGraphile has made with one of your own.'),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"makeWrapPlansPlugin")," helps you to easily generate a ",(0,r.kt)("a",{parentName:"p",href:"./extending/"},'"schema\nplugin"')," for 'wrapping' the plan resolvers generated by\nPostGraphile. You can ",(0,r.kt)("a",{parentName:"p",href:"./extending/#loading-plugins"},"load the resulting schema\nplugin")," via your ",(0,r.kt)("inlineCode",{parentName:"p"},"graphile.config.mjs")," (or\nsimilar) preset."),(0,r.kt)("admonition",{type:"warning"},(0,r.kt)("p",{parentName:"admonition"},'Some of the fields in the GraphQL schema expect their parent value to be of a\nparticular step class, so in these cases you must be careful to ensure that you\ndon\'t break this expectation otherwise planning errors may occur. This is\ntypically not a concern with modifying the result of "leaf" fields (e.g.\nmasking a users email address) since generally these do not depend on the\nspecific step type.')),(0,r.kt)("h2",{id:"signatures"},"Signatures"),(0,r.kt)("p",null,"There are two ",(0,r.kt)("em",{parentName:"p"},"variants")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"makeWrapPlansPlugin")," with slightly different\nsignatures (function overloading). These reflect the two methods of calling\n",(0,r.kt)("inlineCode",{parentName:"p"},"makeWrapPlansPlugin"),". If you want to wrap one or two specific resolvers (where\nyou know the type name and field name) then method 1 is a handy shortcut. If,\nhowever, you want to wrap a number of resolvers in the same way then the more\nflexible method 2 is what you want."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// Method 1: wrap individual resolvers of known fields\nfunction makeWrapPlansPlugin(\n  rulesOrGenerator: PlanWrapperRules | PlanWrapperRulesGenerator,\n): GraphileConfig.Plugin;\n\ninterface PlanWrapperRules {\n  [typeName: string]: {\n    [fieldName: string]: PlanWrapperRule | PlanWrapperFn;\n  };\n}\n\ninterface PlanWrapperRule {\n  plan?: PlanWrapperFn;\n}\n\ntype PlanWrapperFn = (\n  plan: SmartFieldPlanResolver,\n  $source: ExecutableStep,\n  fieldArgs: FieldArgs,\n  info: FieldInfo,\n) => any;\n\ntype PlanWrapperRulesGenerator = (\n  build: Partial<GraphileBuild.Build> & GraphileBuild.BuildBase,\n) => PlanWrapperRules;\n\n/****************************************/\n\n// Method 2: wrap all resolvers that match a filter function\nfunction makeWrapPlansPlugin<T>(\n  filter: (\n    context: GraphileBuild.ContextObjectFieldsField,\n    build: GraphileBuild.Build,\n    field: GrafastFieldConfig,\n  ) => T | null,\n  rule: (match: T) => PlanWrapperRule | PlanWrapperFn,\n): GraphileConfig.Plugin;\n")),(0,r.kt)("h2",{id:"method-1-wrapping-individual-resolvers-of-known-fields"},"Method 1: wrapping individual resolvers of known fields"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"// Method 1: wrap individual resolvers of known fields\nfunction makeWrapPlansPlugin(\n  rulesOrGenerator: PlanWrapperRules | PlanWrapperRulesGenerator,\n): GraphileConfig.Plugin;\n")),(0,r.kt)("p",null,"In this method, ",(0,r.kt)("inlineCode",{parentName:"p"},"makeWrapPlansPlugin")," takes either the resolver wrapper\nrules object directly, or a generator for this rules object, and returns a\nplugin."),(0,r.kt)("h3",{id:"example-convert-to-lower-case"},"Example: convert to lower case"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { makeWrapPlansPlugin } from "postgraphile/utils";\nimport { lambda } from "postgraphile/grafast";\n\nexport default makeWrapPlansPlugin({\n  User: {\n    email(plan) {\n      const $email = plan();\n      return lambda($email, (email) => email.toLowerCase());\n    },\n  },\n});\n')),(0,r.kt)("h3",{id:"example-multiple-fields"},"Example: multiple fields"),(0,r.kt)("p",null,"When there's an explicit list of fields that you want to wrap in the same way,\nthis method can still be useful:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { sideEffect } from "postgraphile/grafast";\n\nfunction assertValidUserData(data) {\n  if (!data || data.username?.length === 0) {\n    throw new Error("Invalid data");\n  }\n}\n\nconst validateUserData = (propName) => {\n  return (plan, $source, fieldArgs) => {\n    const $user = fieldArgs.getRaw(["input", propName]);\n\n    // Callback throws error if invalid\n    sideEffect($user, (user) => assertValidUserData(user));\n\n    return plan();\n  };\n};\n\nexport default makeWrapPlansPlugin({\n  Mutation: {\n    createUser: validateUserData("user"),\n    updateUser: validateUserData("userPatch"),\n    updateUserById: validateUserData("userPatch"),\n    updateUserByEmail: validateUserData("userPatch"),\n  },\n});\n')),(0,r.kt)("h3",{id:"rules-object"},"Rules object"),(0,r.kt)("p",null,"The rules object is a two-level map of ",(0,r.kt)("inlineCode",{parentName:"p"},"typeName")," (the name of a\nGraphQLObjectType) and ",(0,r.kt)("inlineCode",{parentName:"p"},"fieldName")," (the name of one of the fields of this type)\nto either a rule for that field, or a resolver wrapper function for that field.\nThe generator function accepts the Build object which can sometimes be useful,\ne.g. to get the preset's schema options, or to retrieve things from the registry."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"interface PlanWrapperRules {\n  [typeName: string]: {\n    [fieldName: string]: PlanWrapperRule | PlanWrapperFn;\n  };\n}\n\ntype PlanWrapperRulesGenerator = (\n  build: Partial<GraphileBuild.Build> & GraphileBuild.BuildBase,\n) => PlanWrapperRules;\n")),(0,r.kt)("p",null,"Read about ",(0,r.kt)("a",{parentName:"p",href:"#plan-resolver-wrapper-functions"},"plan resolver wrapper functions below"),"."),(0,r.kt)("h3",{id:"example-null-email-unless-own"},"Example: null email unless own"),(0,r.kt)("p",null,"For example, this plugin wraps the ",(0,r.kt)("inlineCode",{parentName:"p"},"User.email")," field, returning ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," if the\nuser requesting the field is not the same as the user for which the email was\nrequested. (Note that the email is still retrieved from the database, it is just\nnot returned to the user.)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { makeWrapPlansPlugin } from "postgraphile/utils";\nimport { context, lambda } from "postgraphile/grafast";\n\nexport default makeWrapPlansPlugin({\n  User: {\n    email(plan, $user) {\n      const $userId = $user.get("id");\n      const $currentUserId = context().get("jwtClaims").get("user_id");\n      const $email = plan();\n      return lambda(\n        [$userId, $currentUserId, $email],\n        ([userId, currentUserId, email]) =>\n          userId === currentUserId ? email : null,\n      );\n    },\n  },\n});\n')),(0,r.kt)("h3",{id:"example-mask-email"},"Example: mask email"),(0,r.kt)("p",null,"This example uses the default resolver of the ",(0,r.kt)("inlineCode",{parentName:"p"},"User.email")," field to get the\nactual value, then masks the value instead of omitting it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { makeWrapPlansPlugin } from "postgraphile/utils";\nimport { lambda } from "postgraphile/grafast";\n\nexport default makeWrapPlansPlugin({\n  User: {\n    email(plan) {\n      const $email = plan();\n      return lambda($email, (email) =>\n        // someone@sub.example.com -> so***@su***.com\n        email.replace(\n          /^(.{1,2})[^@]*@(.{,2})[^.]*\\.([A-z]{2,})$/,\n          "$1***@$2***.$3",\n        ),\n      );\n    },\n  },\n});\n')),(0,r.kt)("h2",{id:"method-2-wrap-all-resolvers-matching-a-filter"},"Method 2: wrap all resolvers matching a filter"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"function makeWrapPlansPlugin<T>(\n  filter: (\n    context: GraphileBuild.ContextObjectFieldsField,\n    build: GraphileBuild.Build,\n    field: GrafastFieldConfig,\n  ) => T | null,\n  rule: (match: T) => PlanWrapperRule | PlanWrapperFn,\n): GraphileConfig.Plugin;\n")),(0,r.kt)("p",null,"In this method, ",(0,r.kt)("inlineCode",{parentName:"p"},"makeWrapPlansPlugin")," takes two function arguments. The\nfirst function is a filter that is called for each field; it should return a\ntruthy value if the field is to be wrapped (or ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," otherwise). The second\nfunction is called for each field that passes the filter, it will be passed the\nreturn value of the filter and must return a resolve wrapper function or rule\n(see ",(0,r.kt)("a",{parentName:"p",href:"#plan-resolver-wrapper-functions"},"plan resolver wrapper functions")," below)."),(0,r.kt)("p",null,"The filter is called with the following arguments:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"context"),": the ",(0,r.kt)("inlineCode",{parentName:"li"},"Context")," value of the field, the ",(0,r.kt)("inlineCode",{parentName:"li"},"context.scope")," property is\nthe most likely to be used"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"build"),": the ",(0,r.kt)("inlineCode",{parentName:"li"},"Build")," objects which contains a lot of helpers"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"field"),": the field specification itself")),(0,r.kt)("p",null,"The value you return can be any arbitrary truthy value, it should contain\nanything from the above arguments that you need to create your resolver wrapper."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { makeWrapPlansPlugin } from \"postgraphile/utils\";\nimport { sideEffect } from \"postgraphile/grafast\";\n\n// Example: log before and after each mutation runs\nexport default makeWrapPlansPlugin(\n  (context) => {\n    if (context.scope.isRootMutation) {\n      return { scope: context.scope };\n    }\n    return null;\n  },\n  ({ scope }) =>\n    (plan, _, fieldArgs) => {\n      sideEffect(fieldArgs.getRaw(), (args) => {\n        console.log(\n          `Mutation '${scope.fieldName}' starting with arguments:`,\n          args,\n        );\n      });\n\n      const $result = plan();\n\n      sideEffect($result, (result) => {\n        console.log(`Mutation '${scope.fieldName}' result:`, result);\n      });\n\n      return $result;\n    },\n);\n")),(0,r.kt)("h2",{id:"plan-resolver-wrapper-functions"},"Plan resolver wrapper functions"),(0,r.kt)("p",null,"A resolver wrapper function is similar to a Gra",(0,r.kt)("em",{parentName:"p"},"fast")," plan resolver, except it\ntakes an additional argument (at the start) which allows delegating to the plan\nresolver that is being wrapped. If and when you call the ",(0,r.kt)("inlineCode",{parentName:"p"},"plan")," function, you\nmay optionally pass one or more of the arguments ",(0,r.kt)("inlineCode",{parentName:"p"},"$source, fieldArgs, info"),";\nthese will then override the values that the resolver will be passed. Calling\n",(0,r.kt)("inlineCode",{parentName:"p"},"plan()")," with no arguments will just pass through the original values\nunmodified."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"type PlanWrapperFn = (\n  plan: SmartFieldPlanResolver,\n  $source: ExecutableStep,\n  fieldArgs: FieldArgs,\n  info: FieldInfo,\n) => any;\n")))}d.isMDXComponent=!0}}]);