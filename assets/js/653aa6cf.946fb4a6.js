"use strict";(self.webpackChunk_localrepo_postgraphile_website=self.webpackChunk_localrepo_postgraphile_website||[]).push([[3320],{30876:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(2784);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=a.createContext({}),m=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=m(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),c=m(n),u=s,h=c["".concat(l,".").concat(u)]||c[u]||d[u]||r;return n?a.createElement(h,o(o({ref:t},p),{},{components:n})):a.createElement(h,o({ref:t},p))}));function h(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=n.length,o=new Array(r);o[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[c]="string"==typeof e?e:s,o[1]=i;for(var m=2;m<r;m++)o[m]=n[m];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},37369:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>m});var a=n(7896),s=(n(2784),n(30876));const r={layout:"page",path:"/postgraphile/smart-comments/",title:"Smart Comments"},o=void 0,i={unversionedId:"smart-comments",id:"smart-comments",title:"Smart Comments",description:"Ensure you've read the Smart Tags page before referring here.",source:"@site/postgraphile/smart-comments.md",sourceDirName:".",slug:"/smart-comments",permalink:"/postgraphile/next/smart-comments",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/postgraphile/website/postgraphile/smart-comments.md",tags:[],version:"current",frontMatter:{layout:"page",path:"/postgraphile/smart-comments/",title:"Smart Comments"},sidebar:"docs",previous:{title:"The postgraphile.tags.json5 file",permalink:"/postgraphile/next/smart-tags-file"},next:{title:"GraphQL Schema Plugins",permalink:"/postgraphile/next/extending"}},l={},m=[{value:"Smart comment spec",id:"smart-comment-spec",level:3},{value:"Adding newlines",id:"adding-newlines",level:3},{value:"Applying smart tags to database entities",id:"applying-smart-tags-to-database-entities",level:3},{value:"Tables",id:"tables",level:4},{value:"Views",id:"views",level:4},{value:"Materialized Views",id:"materialized-views",level:4},{value:"Types",id:"types",level:4},{value:"Columns",id:"columns",level:4},{value:"Constraints",id:"constraints",level:4},{value:"Functions",id:"functions",level:4},{value:"Adding smart tags to fake constraints",id:"adding-smart-tags-to-fake-constraints",level:3}],p={toc:m},c="wrapper";function d(e){let{components:t,...n}=e;return(0,s.kt)(c,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Ensure you've read the ",(0,s.kt)("a",{parentName:"em",href:"./smart-tags/"},"Smart Tags")," page before referring here.")),(0,s.kt)("p",null,'You can customise your PostGraphile GraphQL schema without making breaking\nchanges to your database schema by adding specially formatted comments to\ntables, columns, functions, relations, etc. within your PostgreSQL database. We\ncall these "smart comments".'),(0,s.kt)("h3",{id:"smart-comment-spec"},"Smart comment spec"),(0,s.kt)("p",null,"Comments can be added to various entities within PostgreSQL using\n",(0,s.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/current/sql-comment.html"},"the ",(0,s.kt)("inlineCode",{parentName:"a"},"COMMENT")," statement"),";\nwe add a special syntax to these comments that enables PostGraphile to treat\nthem as smart comments."),(0,s.kt)("p",null,'A smart comment is made up of one or more "tags" and optionally followed by the\nremaining comment. Leading spaces and tabs are ignored. If the very first line\nis blank, that is also ignored. Tags may have a string payload (which follows\nthe tag and a space, and must not contain newline characters) and are separated\nby newlines (',(0,s.kt)("inlineCode",{parentName:"p"},"\\n")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"\\r\\n"),"). Tags always start with an ",(0,s.kt)("inlineCode",{parentName:"p"},"@")," symbol and must\nalways come before the remaining comment, hence all smart comments start with\nan ",(0,s.kt)("inlineCode",{parentName:"p"},"@")," symbol. If a tag has no payload then its value will be the boolean\n",(0,s.kt)("inlineCode",{parentName:"p"},"true"),", otherwise it will be a string. If the same tag is present more than\nonce in a smart comment then its final value will become an array of the\nindividual values for that tag."),(0,s.kt)("p",null,"The following text could be parsed as a smart comment (",(0,s.kt)("strong",{parentName:"p"},"the smart comment\nvalues shown are examples only, and don't have any meaning"),"):"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"@name meta\n@isImportant\n@jsonField date timestamp\n@jsonField name text\n@jsonField episode enum ONE=1 TWO=2\nThis field has a load of arbitrary tags.\n")),(0,s.kt)("p",null,"and would result in the following JSON tags object:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "name": "meta",\n  "isImportant": true,\n  "jsonField": ["date timestamp", "name text", "episode enum ONE=1 TWO=2"]\n}\n')),(0,s.kt)("p",null,"and the description on the last line\n(",(0,s.kt)("inlineCode",{parentName:"p"},"This field has a load of arbitrary tags."),") would be made available as\ndocumentation as regular comments are."),(0,s.kt)("p",null,"Note that the parser is deliberately very strict currently, we might make it\nmore flexible in future; you might want to check out the\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/graphile/graphile-engine/blob/master/packages/graphile-build-pg/__tests__/tags.test.js"},"test suite"),"."),(0,s.kt)("h3",{id:"adding-newlines"},"Adding newlines"),(0,s.kt)("p",null,"We recommend you define smart tags using ",(0,s.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-DOLLAR-QUOTING"},"dollar\nquoting"),",\nwhich makes adding newlines natural. We support both LF and CRLF line endings\n(and treat them the same)."),(0,s.kt)("p",null,"Traditionally we recommended the use of the\n",(0,s.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/current/static/sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS"},(0,s.kt)("inlineCode",{parentName:"a"},"E"),' "escape" string constants'),",\nwherein you can use ",(0,s.kt)("inlineCode",{parentName:"p"},"\\n")," for newlines, but that was before we made the parser less strict."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"comment on column my_schema.my_table.my_column is $$\n@name meta\n@isImportant\n@jsonField date timestamp\n@jsonField name text\n@jsonField episode enum ONE=1 TWO=2\nThis field has a load of arbitrary tags.\n$$;\n")),(0,s.kt)("p",null,"Note that adding two newlines in a row separates the smart tags section from the\ndescriptive prose. Content after two newlines will not be parsed for smart tags\neven if it starts with an ",(0,s.kt)("inlineCode",{parentName:"p"},"@")," character."),(0,s.kt)("p",null,"For example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"comment on column my_schema.my_table.my_column is $$\n@name meta\n@isImportant\n@jsonField date timestamp\n@jsonField name text\n\nThis field has a load of arbitrary tags.\n@jsonField episode enum ONE=1 TWO=2\n$$;\n")),(0,s.kt)("p",null,"results in the following JSON tags object:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "name": "meta",\n  "isImportant": true,\n  "jsonField": ["date timestamp", "name text"]\n}\n')),(0,s.kt)("p",null,"and the description:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"This field has a load of arbitrary tags.\n@jsonField episode enum ONE=1 TWO=2\n")),(0,s.kt)("h3",{id:"applying-smart-tags-to-database-entities"},"Applying smart tags to database entities"),(0,s.kt)("h4",{id:"tables"},"Tables"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"comment on table my_schema.my_table is\n  E'@name my_new_table_name\\n@omit update,delete\\nThis is the documentation.';\n")),(0,s.kt)("h4",{id:"views"},"Views"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"comment on view my_schema.mv_view is\n  E'@name my_new_view_name\\n@omit update,delete\\nThis is the documentation.';\n")),(0,s.kt)("h4",{id:"materialized-views"},"Materialized Views"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"comment on materialized view my_schema.mv_view is\n  E'@name my_new_view_name\\n@omit update,delete\\nThis is the documentation.';\n")),(0,s.kt)("h4",{id:"types"},"Types"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"comment on type my_schema.my_type is\n  E'@name my_new_type_name\\nThis is the documentation.';\n")),(0,s.kt)("h4",{id:"columns"},"Columns"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"comment on column my_schema.my_table.my_column is\n  E'@name my_new_column\\n@omit create,update\\nThis is the documentation.';\n")),(0,s.kt)("h4",{id:"constraints"},"Constraints"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"comment on constraint my_constraint on my_schema.my_table is\n  E'@foreignFieldName foos\\n@fieldName bar\\nDocumentation here.';\n")),(0,s.kt)("h4",{id:"functions"},"Functions"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"comment on function my_function(arg_type_1, arg_type_2) is\n  E'@name my_new_function_name\\nDocumentation here.';\n")),(0,s.kt)("h3",{id:"adding-smart-tags-to-fake-constraints"},"Adding smart tags to fake constraints"),(0,s.kt)("p",null,"If you need to apply any smart comments to a fake constraint, you cannot use\nnewlines (",(0,s.kt)("inlineCode",{parentName:"p"},"\\n"),") because they will be interpretted as separate smart comments on\nthe original entity. We've added a workaround for this: you can use the pipe\n(",(0,s.kt)("inlineCode",{parentName:"p"},"|"),") symbol to assign smart comments to the fake constraint, for example to\nrename the fake constraint:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-sql"},"comment on materialized view my_materialized_view is\n  E'@foreignKey (post_id) references posts (id)|@fieldName yourNameHere';\n")))}d.isMDXComponent=!0}}]);