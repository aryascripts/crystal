"use strict";(self.webpackChunk_localrepo_postgraphile_website=self.webpackChunk_localrepo_postgraphile_website||[]).push([[3758],{30876:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var o=n(2784);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(n),h=a,m=c["".concat(l,".").concat(h)]||c[h]||d[h]||r;return n?o.createElement(m,i(i({ref:t},u),{},{components:n})):o.createElement(m,i({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:a,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},41484:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var o=n(7896),a=(n(2784),n(30876));const r={layout:"page",path:"/postgraphile/production/",title:"Production considerations"},i=void 0,s={unversionedId:"production",id:"production",title:"Production considerations",description:"When it comes time to deploy your PostGraphile application to production,",source:"@site/postgraphile/production.md",sourceDirName:".",slug:"/production",permalink:"/postgraphile/next/production",draft:!1,editUrl:"https://github.com/graphile/crystal/tree/main/postgraphile/website/postgraphile/production.md",tags:[],version:"current",frontMatter:{layout:"page",path:"/postgraphile/production/",title:"Production considerations"},sidebar:"docs",previous:{title:"PostGraphile best practices",permalink:"/postgraphile/next/best-practices"},next:{title:"PostGraphile JWT guide",permalink:"/postgraphile/next/jwt-guide"}},l={},p=[{value:"Database Access Considerations",id:"database-access-considerations",level:2},{value:"Database Latency",id:"database-latency",level:2},{value:"Grafast Considerations",id:"grafast-considerations",level:2},{value:"Common Middleware Considerations",id:"common-middleware-considerations",level:2},{value:"Denial of Service Considerations",id:"denial-of-service-considerations",level:2},{value:"Statement Timeout",id:"statement-timeout",level:3},{value:"Simple: Query Allowlist (&quot;persisted queries&quot; / &quot;persisted operations&quot;)",id:"simple-query-allowlist-persisted-queries--persisted-operations",level:3}],u={toc:p},c="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"When it comes time to deploy your PostGraphile application to production,\nthere's a few things you'll want to think about including topics such as\nlogging, security and stability. This article outlines some of the issues you\nmight face, and how to solve them."),(0,a.kt)("h2",{id:"database-access-considerations"},"Database Access Considerations"),(0,a.kt)("p",null,"PostGraphile is just a node app / middleware, so you can deploy it to any number\nof places: Heroku, Now.sh, a VM, a container such as Docker, or of course onto\nbare metal. Typically you won't run PostGraphile on the same\nhardware/container/VM as the database, so PostGraphile needs to be able to\nconnect to your database without you putting your DB at risk."),(0,a.kt)("p",null,"A standard way of doing this is to put the DB behind a firewall. However, if\nyou're using a system like Heroku or Now.sh you probably can't do that, so\ninstead you must make your DB accessible to the internet. When doing so here are\na few things we recommend:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Only allow connections over SSL (",(0,a.kt)("inlineCode",{parentName:"li"},"force_ssl")," setting)"),(0,a.kt)("li",{parentName:"ol"},"Use a secure username (not ",(0,a.kt)("inlineCode",{parentName:"li"},"root"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"admin"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"postgres"),", etc which are all\nfairly commonly used)"),(0,a.kt)("li",{parentName:"ol"},"Use a super secure password; you can use a command like this to generate\none: ",(0,a.kt)("inlineCode",{parentName:"li"},"openssl rand -base64 30 | tr '+/' '-_'")),(0,a.kt)("li",{parentName:"ol"},"Use a non-standard port for your PostgreSQL server if you can (pick a random\nport number)"),(0,a.kt)("li",{parentName:"ol"},"Use a hard-to-guess hostname, and never reveal the hostname to anyone who\ndoesn't need to know it"),(0,a.kt)("li",{parentName:"ol"},"If possible, limit the IP addresses that can connect to your DB to be just\nthose of your hosting provider.")),(0,a.kt)("p",null,"Heroku have some instructions on making RDS available for use under Heroku which\nshould also work for Now.sh or any other service:\n",(0,a.kt)("a",{parentName:"p",href:"https://devcenter.heroku.com/articles/amazon-rds"},"https://devcenter.heroku.com/articles/amazon-rds")),(0,a.kt)("p",null,"By default ",(0,a.kt)("inlineCode",{parentName:"p"},"PgRBACPlugin")," is enabled which inspects the RBAC (GRANT / REVOKE)\nprivileges in the database and reflects these in your GraphQL schema. As is\nGraphQL best practices, this still only results in one GraphQL schema (not one\nper user), so it takes the user account you connect to PostgreSQL with (from\nyour connection string) and walks all the roles that this user can become\nwithin the database, and uses the union of all these permissions. Using this\nplugin is recommended, as it results in a much leaner schema that doesn't\ncontain functionality that you can't actually use. You can, however, disable it\nvia ",(0,a.kt)("inlineCode",{parentName:"p"},"disablePlugins: ['PgRBACPlugin']"),"."),(0,a.kt)("h2",{id:"database-latency"},"Database Latency"),(0,a.kt)("p",null,"PostGraphile needs to issue queries to your database. For a transaction this\nmight be multiple statements (",(0,a.kt)("inlineCode",{parentName:"p"},"begin"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"set local ..."),", ",(0,a.kt)("inlineCode",{parentName:"p"},"select ..."),", ",(0,a.kt)("inlineCode",{parentName:"p"},"commit"),")\nand each of these requires a roundtrip to the database. Thus the latency\nbetween your database and your PostGraphile server can easily be multiplied.\nIf your database is in London but your PostGraphile server is in Tokyo then the\n~300ms roundtrip time times 4 is a base latency that users will see of 1.2\nseconds, no matter how fast your queries actually are."),(0,a.kt)("p",null,"Run PostGraphile in the same city as your database, preferably in the same data\ncentre."),(0,a.kt)("h2",{id:"grafast-considerations"},"Grafast Considerations"),(0,a.kt)("p",null,"Since PostGraphile uses Gra",(0,a.kt)("em",{parentName:"p"},"fast")," under the hood, you should also familiarize\nyourself with ",(0,a.kt)("a",{parentName:"p",href:"https://grafast.org/grafast/production-considerations"},"Gra",(0,a.kt)("em",{parentName:"a"},"fast"),"'s production\nconsiderations"),"."),(0,a.kt)("h2",{id:"common-middleware-considerations"},"Common Middleware Considerations"),(0,a.kt)("p",null,"In a production app, you typically want to add a few common enhancements, e.g."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Logging"),(0,a.kt)("li",{parentName:"ul"},"Gzip or similar compression"),(0,a.kt)("li",{parentName:"ul"},"Security protections"),(0,a.kt)("li",{parentName:"ul"},"Rate limiting")),(0,a.kt)("p",null,"Since there's already a lot of options and opinions in this space, and they're\nnot directly related to the problem of serving GraphQL from your PostgreSQL\ndatabase, PostGraphile does not include these things by default. We recommend\nthat you use something like Express middlewares to implement these common\nrequirements. This is why we recommend\n",(0,a.kt)("a",{parentName:"p",href:"./usage-library/"},"using PostGraphile as a library")," for production usage."),(0,a.kt)("p",null,"Picking the Express (or similar) middlewares that work for you is beyond the\nscope of this article; but you should ensure that they're installed before you\nadd your PostGraphile server to the middleware stack."),(0,a.kt)("h2",{id:"denial-of-service-considerations"},"Denial of Service Considerations"),(0,a.kt)("p",null,"When you run PostGraphile in production you'll want to ensure that people cannot\neasily trigger denial of service (DOS) attacks against you. Due to the nature of\nGraphQL it's easy to construct a small query that could be very expensive for\nthe server to run, for example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},"allUsers {\n  nodes {\n    postsByAuthorId {\n      nodes {\n        commentsByPostId {\n          userByAuthorId {\n            postsByAuthorId {\n              nodes {\n                commentsByPostId {\n                  userByAuthorId {\n                    postsByAuthorId {\n                      nodes {\n                        commentsByPostId {\n                          userByAuthorId {\n                            id\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n")),(0,a.kt)("p",null,"There's lots of techniques for protecting your server from these kinds of\nqueries; a great introduction to this subject is\n",(0,a.kt)("a",{parentName:"p",href:"https://dev-blog.apollodata.com/securing-your-graphql-api-from-malicious-queries-16130a324a6b"},"this blog post"),"\nfrom Apollo."),(0,a.kt)("p",null,"These techniques should be used in conjunction with common HTTP protection\nmethods such as rate limiting which are typically better implemented at a\nseparate layer; for example you could use\n",(0,a.kt)("a",{parentName:"p",href:"https://www.cloudflare.com/rate-limiting/"},"Cloudflare rate limiting")," for this,\nor an Express.js middleware."),(0,a.kt)("h3",{id:"statement-timeout"},"Statement Timeout"),(0,a.kt)("p",null,"One simple solution to this issue is to place a timeout on the database\noperations via the\n",(0,a.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/current/runtime-config-client.html#GUC-STATEMENT-TIMEOUT"},(0,a.kt)("inlineCode",{parentName:"a"},"statement_timeout")," PostgreSQL setting"),".\nThis will halt any query that takes longer than the specified number of\nmilliseconds to execute. This can still enable nefarious actors to have your\ndatabase work hard for that duration, but it does prevent these malicious\nqueries from running for an extended period, reducing the ease of a DoS (Denial\nof Service) attack. This solution is a good way to catch anything that may have\nslipped through the cracks of your other defences, or just to get you up and\nrunning while you work on more robust/lower level solutions, but when you expose\nyour GraphQL endpoint to the world it's better to cut things off at the source\nbefore a query is ever sent to the database using one or more of the techniques\ndetailed below."),(0,a.kt)("p",null,"Currently you can set this on a per-transaction basis using the\n",(0,a.kt)("a",{parentName:"p",href:"./config#exposing-http-request-data-to-postgresql"},(0,a.kt)("inlineCode",{parentName:"a"},"pgSettings")," functionality")," in\nPostGraphile library mode, e.g.:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="graphile.config.mjs"',title:'"graphile.config.mjs"'},'export default {\n  // ...\n  grafast: {\n    context(requestContext, args) {\n      return {\n        // highlight-next-line\n        statement_timeout: "3000",\n        // ...\n      };\n    },\n  },\n};\n')),(0,a.kt)("p",null,"To be more efficient (only setting this once per database connection rather\nthan once per GraphQL request) you can also set this up on a per connection\nbasis if you pass a correctly configured ",(0,a.kt)("inlineCode",{parentName:"p"},"pg.Pool")," instance to PostGraphile\ndirectly, e.g.:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="graphile.config.mjs"',title:'"graphile.config.mjs"'},'import { Pool } from "pg";\nimport { makePgService } from "postgraphile/adaptors/pg";\n\n/** does nothing */\nfunction noop() {}\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n});\npool.on("error", noop);\npool.on("connect", (client) => {\n  client.on("error", noop);\n  // highlight-next-line\n  client.query("SET statement_timeout TO 3000");\n});\n\nexport default {\n  // ...\n  pgServices: [\n    makePgService({\n      pool,\n      schemas: ["app_public"],\n    }),\n  ],\n};\n')),(0,a.kt)("h3",{id:"simple-query-allowlist-persisted-queries--persisted-operations"},'Simple: Query Allowlist ("persisted queries" / "persisted operations")'),(0,a.kt)("p",null,"If you do not intend to allow third parties to run arbitrary operations against\nyour API then using\n",(0,a.kt)("a",{parentName:"p",href:"https://npmjs.com/package/@grafserv/persisted"},"persisted operations")," as a\nquery allowlist is a highly recommended solution to protect your GraphQL\nendpoint. This technique ensures that only the operations you use in your own\napplications can be executed on the server, preventing malicious (or merely\ncurious) actors from executing operations which may be more expensive than those\nyou have written."),(0,a.kt)("p",null,"This technique is suitable for the vast majority of use cases and supports many\nGraphQL clients, but it does have a few caveats:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Your API will only accept operations that you've approved, so it's not\nsuitable if you want third parties to run arbitrary custom operations."),(0,a.kt)("li",{parentName:"ul"},'You must be able to generate a unique ID (e.g. a hash) from each operation at\nbuild time of your application/web page - your GraphQL operations must be\n"static". It\'s important to note this only applies to the operation document\nitself, the variables can of course change at runtime.'),(0,a.kt)("li",{parentName:"ul"},"You must have a way of sharing these static operations from the application\nbuild process to the server so that the server will know what operation the ID\nrepresents."),(0,a.kt)("li",{parentName:"ul"},"You must be careful not to use variables in dangerous places within your\noperation; for example if you were to use ",(0,a.kt)("inlineCode",{parentName:"li"},"allUsers(first: $myVar)")," a\nmalicious attacker could set ",(0,a.kt)("inlineCode",{parentName:"li"},"$myVar")," to 2147483647 to cause your server to\nprocess as much data as possible. Use fixed limits, conditions and orders\nwhere possible, even if it means having additional static operations."),(0,a.kt)("li",{parentName:"ul"},"It does not protect you from writing expensive queries yourself; it may be\nwise to combine this technique with a cost estimation technique "," to help guide your developers\nand avoid accidentally writing expensive queries.")),(0,a.kt)("p",null,"PostGraphile has first-party support for persisted operations via the open\nsource ",(0,a.kt)("a",{parentName:"p",href:"https://npmjs.com/package/@grafserv/persisted"},"@grafserv/persisted"),"\nplugin; we recommend its use to the vast majority of our users."))}d.isMDXComponent=!0}}]);